// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protocol/commands.proto

package org.mozc.android.inputmethod.japanese.protobuf;

public final class ProtoCommands {
  private ProtoCommands() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }
  /**
   * <pre>
   * This enum is used by SessionCommand::input_mode with
   * CHANGE_INPUT_MODE and Output::mode.
   * </pre>
   *
   * Protobuf enum {@code mozc.commands.CompositionMode}
   */
  public enum CompositionMode
      implements com.google.protobuf.Internal.EnumLite {
    /**
     * <code>DIRECT = 0;</code>
     */
    DIRECT(0),
    /**
     * <code>HIRAGANA = 1;</code>
     */
    HIRAGANA(1),
    /**
     * <code>FULL_KATAKANA = 2;</code>
     */
    FULL_KATAKANA(2),
    /**
     * <code>HALF_ASCII = 3;</code>
     */
    HALF_ASCII(3),
    /**
     * <code>FULL_ASCII = 4;</code>
     */
    FULL_ASCII(4),
    /**
     * <code>HALF_KATAKANA = 5;</code>
     */
    HALF_KATAKANA(5),
    /**
     * <code>NUM_OF_COMPOSITIONS = 6;</code>
     */
    NUM_OF_COMPOSITIONS(6),
    ;

    /**
     * <code>DIRECT = 0;</code>
     */
    public static final int DIRECT_VALUE = 0;
    /**
     * <code>HIRAGANA = 1;</code>
     */
    public static final int HIRAGANA_VALUE = 1;
    /**
     * <code>FULL_KATAKANA = 2;</code>
     */
    public static final int FULL_KATAKANA_VALUE = 2;
    /**
     * <code>HALF_ASCII = 3;</code>
     */
    public static final int HALF_ASCII_VALUE = 3;
    /**
     * <code>FULL_ASCII = 4;</code>
     */
    public static final int FULL_ASCII_VALUE = 4;
    /**
     * <code>HALF_KATAKANA = 5;</code>
     */
    public static final int HALF_KATAKANA_VALUE = 5;
    /**
     * <code>NUM_OF_COMPOSITIONS = 6;</code>
     */
    public static final int NUM_OF_COMPOSITIONS_VALUE = 6;


    @java.lang.Override
    public final int getNumber() {
      return value;
    }

    /**
     * @param value The number of the enum to look for.
     * @return The enum associated with the given number.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static CompositionMode valueOf(int value) {
      return forNumber(value);
    }

    public static CompositionMode forNumber(int value) {
      switch (value) {
        case 0: return DIRECT;
        case 1: return HIRAGANA;
        case 2: return FULL_KATAKANA;
        case 3: return HALF_ASCII;
        case 4: return FULL_ASCII;
        case 5: return HALF_KATAKANA;
        case 6: return NUM_OF_COMPOSITIONS;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<CompositionMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        CompositionMode> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<CompositionMode>() {
            @java.lang.Override
            public CompositionMode findValueByNumber(int number) {
              return CompositionMode.forNumber(number);
            }
          };

    public static com.google.protobuf.Internal.EnumVerifier 
        internalGetVerifier() {
      return CompositionModeVerifier.INSTANCE;
    }

    private static final class CompositionModeVerifier implements 
         com.google.protobuf.Internal.EnumVerifier { 
            static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new CompositionModeVerifier();
            @java.lang.Override
            public boolean isInRange(int number) {
              return CompositionMode.forNumber(number) != null;
            }
          };

    private final int value;

    private CompositionMode(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mozc.commands.CompositionMode)
  }

  public interface KeyEventOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mozc.commands.KeyEvent)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Printable key in UCS4.  If key_code is empty, key_string is used
     * as a raw input.
     * </pre>
     *
     * <code>optional uint32 key_code = 1;</code>
     * @return Whether the keyCode field is set.
     */
    boolean hasKeyCode();
    /**
     * <pre>
     * Printable key in UCS4.  If key_code is empty, key_string is used
     * as a raw input.
     * </pre>
     *
     * <code>optional uint32 key_code = 1;</code>
     * @return The keyCode.
     */
    int getKeyCode();

    /**
     * <pre>
     * Going to be obsolete.
     * </pre>
     *
     * <code>optional uint32 modifiers = 2;</code>
     * @return Whether the modifiers field is set.
     */
    boolean hasModifiers();
    /**
     * <pre>
     * Going to be obsolete.
     * </pre>
     *
     * <code>optional uint32 modifiers = 2;</code>
     * @return The modifiers.
     */
    int getModifiers();

    /**
     * <pre>
     * Unprintable key listed above.
     * </pre>
     *
     * <code>optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;</code>
     * @return Whether the specialKey field is set.
     */
    boolean hasSpecialKey();
    /**
     * <pre>
     * Unprintable key listed above.
     * </pre>
     *
     * <code>optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;</code>
     * @return The specialKey.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.SpecialKey getSpecialKey();

    /**
     * <pre>
     * ModifierKeys
     * </pre>
     *
     * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
     * @return A list containing the modifierKeys.
     */
    java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey> getModifierKeysList();
    /**
     * <pre>
     * ModifierKeys
     * </pre>
     *
     * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
     * @return The count of modifierKeys.
     */
    int getModifierKeysCount();
    /**
     * <pre>
     * ModifierKeys
     * </pre>
     *
     * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
     * @param index The index of the element to return.
     * @return The modifierKeys at the given index.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey getModifierKeys(int index);

    /**
     * <pre>
     * String used for preedit.  Kana characters and strings typed from
     * a software keyboard are supposed to be stored here.  If key_code
     * is also set, key_code is treated as the raw input and key_string is
     * treated as the composition input.  For example, to set Kana value,
     * when key_string is "ち", key_code should be 'a' (97).  If key_code
     * is empty, key_string is also treated as the raw input.
     * </pre>
     *
     * <code>optional string key_string = 5;</code>
     * @return Whether the keyString field is set.
     */
    boolean hasKeyString();
    /**
     * <pre>
     * String used for preedit.  Kana characters and strings typed from
     * a software keyboard are supposed to be stored here.  If key_code
     * is also set, key_code is treated as the raw input and key_string is
     * treated as the composition input.  For example, to set Kana value,
     * when key_string is "ち", key_code should be 'a' (97).  If key_code
     * is empty, key_string is also treated as the raw input.
     * </pre>
     *
     * <code>optional string key_string = 5;</code>
     * @return The keyString.
     */
    java.lang.String getKeyString();
    /**
     * <pre>
     * String used for preedit.  Kana characters and strings typed from
     * a software keyboard are supposed to be stored here.  If key_code
     * is also set, key_code is treated as the raw input and key_string is
     * treated as the composition input.  For example, to set Kana value,
     * when key_string is "ち", key_code should be 'a' (97).  If key_code
     * is empty, key_string is also treated as the raw input.
     * </pre>
     *
     * <code>optional string key_string = 5;</code>
     * @return The bytes for keyString.
     */
    com.google.protobuf.ByteString
        getKeyStringBytes();

    /**
     * <code>optional .mozc.commands.KeyEvent.InputStyle input_style = 6 [default = FOLLOW_MODE];</code>
     * @return Whether the inputStyle field is set.
     */
    boolean hasInputStyle();
    /**
     * <code>optional .mozc.commands.KeyEvent.InputStyle input_style = 6 [default = FOLLOW_MODE];</code>
     * @return The inputStyle.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.InputStyle getInputStyle();

    /**
     * <pre>
     * Composition mode
     * For histrical reasons, this field expects a temporary conversion
     * mode rather than comeback input mode.
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode mode = 7;</code>
     * @return Whether the mode field is set.
     */
    boolean hasMode();
    /**
     * <pre>
     * Composition mode
     * For histrical reasons, this field expects a temporary conversion
     * mode rather than comeback input mode.
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode mode = 7;</code>
     * @return The mode.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode getMode();

    /**
     * <pre>
     * Probable key events
     * Even if you can fill this field,
     * don't omit Input.key_code and so on
     * because preedit string is composed based on them.
     * </pre>
     *
     * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
     */
    java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent> 
        getProbableKeyEventList();
    /**
     * <pre>
     * Probable key events
     * Even if you can fill this field,
     * don't omit Input.key_code and so on
     * because preedit string is composed based on them.
     * </pre>
     *
     * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent getProbableKeyEvent(int index);
    /**
     * <pre>
     * Probable key events
     * Even if you can fill this field,
     * don't omit Input.key_code and so on
     * because preedit string is composed based on them.
     * </pre>
     *
     * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
     */
    int getProbableKeyEventCount();

    /**
     * <pre>
     * IME on/off mode
     * You can use this field to change the IME on/off mode indirectly without
     * sending SpecialKey:ON or SpecialKey:OFF events.
     * If the internal ImeContext::State is DIRECT and this field is true, the
     * converter will change the state to PRECONPOSITION and then handles this key
     * event.
     * If the internal ImeContext::State is not DIRECT and this field is false,
     * the converter will change the state to DIRECT and then handles this key
     * event.
     * Implementation note: We need both |mode| and |activated| to support
     * indirect IME off, where |mode| should contain the next mode. If this field
     * is not set, the server will act as if indirect on/off was not supported.
     * </pre>
     *
     * <code>optional bool activated = 9;</code>
     * @return Whether the activated field is set.
     */
    boolean hasActivated();
    /**
     * <pre>
     * IME on/off mode
     * You can use this field to change the IME on/off mode indirectly without
     * sending SpecialKey:ON or SpecialKey:OFF events.
     * If the internal ImeContext::State is DIRECT and this field is true, the
     * converter will change the state to PRECONPOSITION and then handles this key
     * event.
     * If the internal ImeContext::State is not DIRECT and this field is false,
     * the converter will change the state to DIRECT and then handles this key
     * event.
     * Implementation note: We need both |mode| and |activated| to support
     * indirect IME off, where |mode| should contain the next mode. If this field
     * is not set, the server will act as if indirect on/off was not supported.
     * </pre>
     *
     * <code>optional bool activated = 9;</code>
     * @return The activated.
     */
    boolean getActivated();

    /**
     * <pre>
     * Timestamp of this key event in millisecond.
     * </pre>
     *
     * <code>optional int64 timestamp_msec = 10;</code>
     * @return Whether the timestampMsec field is set.
     */
    boolean hasTimestampMsec();
    /**
     * <pre>
     * Timestamp of this key event in millisecond.
     * </pre>
     *
     * <code>optional int64 timestamp_msec = 10;</code>
     * @return The timestampMsec.
     */
    long getTimestampMsec();
  }
  /**
   * Protobuf type {@code mozc.commands.KeyEvent}
   */
  public  static final class KeyEvent extends
      com.google.protobuf.GeneratedMessageLite<
          KeyEvent, KeyEvent.Builder> implements
      // @@protoc_insertion_point(message_implements:mozc.commands.KeyEvent)
      KeyEventOrBuilder {
    private KeyEvent() {
      modifierKeys_ = emptyIntList();
      keyString_ = "";
      probableKeyEvent_ = emptyProtobufList();
    }
    /**
     * <pre>
     * LINT.IfChange
     * </pre>
     *
     * Protobuf enum {@code mozc.commands.KeyEvent.SpecialKey}
     */
    public enum SpecialKey
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>NO_SPECIALKEY = 0;</code>
       */
      NO_SPECIALKEY(0),
      /**
       * <code>DIGIT = 1;</code>
       */
      DIGIT(1),
      /**
       * <pre>
       * On Windows, SpecialKey::On and SpecialKey::OFF are obsolete. Use
       * TURN_ON_IME session command should be used instead. See b/10216365.
       * On other platforms, especially on Mac, please note that
       * client/client.cc still relies on SpecialKey::On for session playback.
       * We need to fix b/10250883 first.
       * TODO(team): Unsupport SpecialKey::On and SpecialKey::OFF.
       * </pre>
       *
       * <code>ON = 2;</code>
       */
      ON(2),
      /**
       * <code>OFF = 3;</code>
       */
      OFF(3),
      /**
       * <code>SPACE = 4;</code>
       */
      SPACE(4),
      /**
       * <code>ENTER = 5;</code>
       */
      ENTER(5),
      /**
       * <code>LEFT = 6;</code>
       */
      LEFT(6),
      /**
       * <code>RIGHT = 7;</code>
       */
      RIGHT(7),
      /**
       * <code>UP = 8;</code>
       */
      UP(8),
      /**
       * <code>DOWN = 9;</code>
       */
      DOWN(9),
      /**
       * <code>ESCAPE = 10;</code>
       */
      ESCAPE(10),
      /**
       * <pre>
       * Not DELETE because DELETE is reserved in MSVC.
       * </pre>
       *
       * <code>DEL = 11;</code>
       */
      DEL(11),
      /**
       * <code>BACKSPACE = 12;</code>
       */
      BACKSPACE(12),
      /**
       * <code>HENKAN = 13;</code>
       */
      HENKAN(13),
      /**
       * <code>MUHENKAN = 14;</code>
       */
      MUHENKAN(14),
      /**
       * <pre>
       * VK_DBE_HIRAGANA(Win), kVK_JIS_Kana(Mac)
       * The "Katakana Hiragana Romaji" key (w/o modifiers) returns this key code.
       * </pre>
       *
       * <code>KANA = 15;</code>
       */
      KANA(15),
      /**
       * <code>HOME = 16;</code>
       */
      HOME(16),
      /**
       * <code>END = 17;</code>
       */
      END(17),
      /**
       * <code>TAB = 18;</code>
       */
      TAB(18),
      /**
       * <code>F1 = 19;</code>
       */
      F1(19),
      /**
       * <code>F2 = 20;</code>
       */
      F2(20),
      /**
       * <code>F3 = 21;</code>
       */
      F3(21),
      /**
       * <code>F4 = 22;</code>
       */
      F4(22),
      /**
       * <code>F5 = 23;</code>
       */
      F5(23),
      /**
       * <code>F6 = 24;</code>
       */
      F6(24),
      /**
       * <code>F7 = 25;</code>
       */
      F7(25),
      /**
       * <code>F8 = 26;</code>
       */
      F8(26),
      /**
       * <code>F9 = 27;</code>
       */
      F9(27),
      /**
       * <code>F10 = 28;</code>
       */
      F10(28),
      /**
       * <code>F11 = 29;</code>
       */
      F11(29),
      /**
       * <code>F12 = 30;</code>
       */
      F12(30),
      /**
       * <code>PAGE_UP = 31;</code>
       */
      PAGE_UP(31),
      /**
       * <code>PAGE_DOWN = 32;</code>
       */
      PAGE_DOWN(32),
      /**
       * <code>INSERT = 33;</code>
       */
      INSERT(33),
      /**
       * <code>F13 = 34;</code>
       */
      F13(34),
      /**
       * <code>F14 = 35;</code>
       */
      F14(35),
      /**
       * <code>F15 = 36;</code>
       */
      F15(36),
      /**
       * <code>F16 = 37;</code>
       */
      F16(37),
      /**
       * <code>F17 = 38;</code>
       */
      F17(38),
      /**
       * <code>F18 = 39;</code>
       */
      F18(39),
      /**
       * <code>F19 = 40;</code>
       */
      F19(40),
      /**
       * <code>F20 = 41;</code>
       */
      F20(41),
      /**
       * <code>F21 = 42;</code>
       */
      F21(42),
      /**
       * <code>F22 = 43;</code>
       */
      F22(43),
      /**
       * <code>F23 = 44;</code>
       */
      F23(44),
      /**
       * <code>F24 = 45;</code>
       */
      F24(45),
      /**
       * <pre>
       * alphanumeric  VK_DBE_ALPHANUMERIC(Win), kVK_JIS_Eisu(Mac)
       * </pre>
       *
       * <code>EISU = 46;</code>
       */
      EISU(46),
      /**
       * <code>NUMPAD0 = 47;</code>
       */
      NUMPAD0(47),
      /**
       * <code>NUMPAD1 = 48;</code>
       */
      NUMPAD1(48),
      /**
       * <code>NUMPAD2 = 49;</code>
       */
      NUMPAD2(49),
      /**
       * <code>NUMPAD3 = 50;</code>
       */
      NUMPAD3(50),
      /**
       * <code>NUMPAD4 = 51;</code>
       */
      NUMPAD4(51),
      /**
       * <code>NUMPAD5 = 52;</code>
       */
      NUMPAD5(52),
      /**
       * <code>NUMPAD6 = 53;</code>
       */
      NUMPAD6(53),
      /**
       * <code>NUMPAD7 = 54;</code>
       */
      NUMPAD7(54),
      /**
       * <code>NUMPAD8 = 55;</code>
       */
      NUMPAD8(55),
      /**
       * <code>NUMPAD9 = 56;</code>
       */
      NUMPAD9(56),
      /**
       * <pre>
       * Numpad [*]
       * </pre>
       *
       * <code>MULTIPLY = 57;</code>
       */
      MULTIPLY(57),
      /**
       * <pre>
       * Numpad [+]
       * </pre>
       *
       * <code>ADD = 58;</code>
       */
      ADD(58),
      /**
       * <pre>
       * Numpad [enter]
       * </pre>
       *
       * <code>SEPARATOR = 59;</code>
       */
      SEPARATOR(59),
      /**
       * <pre>
       * Numpad [-]
       * </pre>
       *
       * <code>SUBTRACT = 60;</code>
       */
      SUBTRACT(60),
      /**
       * <pre>
       * Numpad [.]
       * </pre>
       *
       * <code>DECIMAL = 61;</code>
       */
      DECIMAL(61),
      /**
       * <pre>
       * Numpad [/]
       * </pre>
       *
       * <code>DIVIDE = 62;</code>
       */
      DIVIDE(62),
      /**
       * <pre>
       * Numpad [=]
       * </pre>
       *
       * <code>EQUALS = 63;</code>
       */
      EQUALS(63),
      /**
       * <pre>
       * Meta key event representing any text input.
       * </pre>
       *
       * <code>TEXT_INPUT = 64;</code>
       */
      TEXT_INPUT(64),
      /**
       * <pre>
       * GUI label is "Hankaku/Zenkaku".
       * </pre>
       *
       * <code>HANKAKU = 65;</code>
       */
      HANKAKU(65),
      /**
       * <code>KANJI = 66;</code>
       */
      KANJI(66),
      /**
       * <pre>
       * The "Katakana Hiragana Romaji" key with Shift returns this key code.
       * </pre>
       *
       * <code>KATAKANA = 67;</code>
       */
      KATAKANA(67),
      /**
       * <code>CAPS_LOCK = 68;</code>
       */
      CAPS_LOCK(68),
      /**
       * <pre>
       * Unsupported keys (e.g. PrtSc, Pause) fall back to UNDEFINED_KEY.
       * </pre>
       *
       * <code>UNDEFINED_KEY = 69;</code>
       */
      UNDEFINED_KEY(69),
      /**
       * <pre>
       * Numpad [,]
       * </pre>
       *
       * <code>COMMA = 70;</code>
       */
      COMMA(70),
      /**
       * <pre>
       * Numpad [5] without NUMLOCK
       * </pre>
       *
       * <code>CLEAR = 71;</code>
       */
      CLEAR(71),
      /**
       * <pre>
       * Left key on virtual (software) keyboard
       * </pre>
       *
       * <code>VIRTUAL_LEFT = 72;</code>
       */
      VIRTUAL_LEFT(72),
      /**
       * <pre>
       * Right key on virtual (software) keyboard
       * </pre>
       *
       * <code>VIRTUAL_RIGHT = 73;</code>
       */
      VIRTUAL_RIGHT(73),
      /**
       * <pre>
       * Enter key on virtual (software) keyboard
       * </pre>
       *
       * <code>VIRTUAL_ENTER = 74;</code>
       */
      VIRTUAL_ENTER(74),
      /**
       * <pre>
       * Up key on virtual (software) keyboard
       * </pre>
       *
       * <code>VIRTUAL_UP = 75;</code>
       */
      VIRTUAL_UP(75),
      /**
       * <pre>
       * Down key on virtual (software) keyboard
       * </pre>
       *
       * <code>VIRTUAL_DOWN = 76;</code>
       */
      VIRTUAL_DOWN(76),
      /**
       * <pre>
       * Special IME action on mobile software keyboard.
       * The actual content is in key_string.
       * </pre>
       *
       * <code>IME_ACTION = 77;</code>
       */
      IME_ACTION(77),
      /**
       * <code>NUM_SPECIALKEYS = 78;</code>
       */
      NUM_SPECIALKEYS(78),
      ;

      /**
       * <code>NO_SPECIALKEY = 0;</code>
       */
      public static final int NO_SPECIALKEY_VALUE = 0;
      /**
       * <code>DIGIT = 1;</code>
       */
      public static final int DIGIT_VALUE = 1;
      /**
       * <pre>
       * On Windows, SpecialKey::On and SpecialKey::OFF are obsolete. Use
       * TURN_ON_IME session command should be used instead. See b/10216365.
       * On other platforms, especially on Mac, please note that
       * client/client.cc still relies on SpecialKey::On for session playback.
       * We need to fix b/10250883 first.
       * TODO(team): Unsupport SpecialKey::On and SpecialKey::OFF.
       * </pre>
       *
       * <code>ON = 2;</code>
       */
      public static final int ON_VALUE = 2;
      /**
       * <code>OFF = 3;</code>
       */
      public static final int OFF_VALUE = 3;
      /**
       * <code>SPACE = 4;</code>
       */
      public static final int SPACE_VALUE = 4;
      /**
       * <code>ENTER = 5;</code>
       */
      public static final int ENTER_VALUE = 5;
      /**
       * <code>LEFT = 6;</code>
       */
      public static final int LEFT_VALUE = 6;
      /**
       * <code>RIGHT = 7;</code>
       */
      public static final int RIGHT_VALUE = 7;
      /**
       * <code>UP = 8;</code>
       */
      public static final int UP_VALUE = 8;
      /**
       * <code>DOWN = 9;</code>
       */
      public static final int DOWN_VALUE = 9;
      /**
       * <code>ESCAPE = 10;</code>
       */
      public static final int ESCAPE_VALUE = 10;
      /**
       * <pre>
       * Not DELETE because DELETE is reserved in MSVC.
       * </pre>
       *
       * <code>DEL = 11;</code>
       */
      public static final int DEL_VALUE = 11;
      /**
       * <code>BACKSPACE = 12;</code>
       */
      public static final int BACKSPACE_VALUE = 12;
      /**
       * <code>HENKAN = 13;</code>
       */
      public static final int HENKAN_VALUE = 13;
      /**
       * <code>MUHENKAN = 14;</code>
       */
      public static final int MUHENKAN_VALUE = 14;
      /**
       * <pre>
       * VK_DBE_HIRAGANA(Win), kVK_JIS_Kana(Mac)
       * The "Katakana Hiragana Romaji" key (w/o modifiers) returns this key code.
       * </pre>
       *
       * <code>KANA = 15;</code>
       */
      public static final int KANA_VALUE = 15;
      /**
       * <code>HOME = 16;</code>
       */
      public static final int HOME_VALUE = 16;
      /**
       * <code>END = 17;</code>
       */
      public static final int END_VALUE = 17;
      /**
       * <code>TAB = 18;</code>
       */
      public static final int TAB_VALUE = 18;
      /**
       * <code>F1 = 19;</code>
       */
      public static final int F1_VALUE = 19;
      /**
       * <code>F2 = 20;</code>
       */
      public static final int F2_VALUE = 20;
      /**
       * <code>F3 = 21;</code>
       */
      public static final int F3_VALUE = 21;
      /**
       * <code>F4 = 22;</code>
       */
      public static final int F4_VALUE = 22;
      /**
       * <code>F5 = 23;</code>
       */
      public static final int F5_VALUE = 23;
      /**
       * <code>F6 = 24;</code>
       */
      public static final int F6_VALUE = 24;
      /**
       * <code>F7 = 25;</code>
       */
      public static final int F7_VALUE = 25;
      /**
       * <code>F8 = 26;</code>
       */
      public static final int F8_VALUE = 26;
      /**
       * <code>F9 = 27;</code>
       */
      public static final int F9_VALUE = 27;
      /**
       * <code>F10 = 28;</code>
       */
      public static final int F10_VALUE = 28;
      /**
       * <code>F11 = 29;</code>
       */
      public static final int F11_VALUE = 29;
      /**
       * <code>F12 = 30;</code>
       */
      public static final int F12_VALUE = 30;
      /**
       * <code>PAGE_UP = 31;</code>
       */
      public static final int PAGE_UP_VALUE = 31;
      /**
       * <code>PAGE_DOWN = 32;</code>
       */
      public static final int PAGE_DOWN_VALUE = 32;
      /**
       * <code>INSERT = 33;</code>
       */
      public static final int INSERT_VALUE = 33;
      /**
       * <code>F13 = 34;</code>
       */
      public static final int F13_VALUE = 34;
      /**
       * <code>F14 = 35;</code>
       */
      public static final int F14_VALUE = 35;
      /**
       * <code>F15 = 36;</code>
       */
      public static final int F15_VALUE = 36;
      /**
       * <code>F16 = 37;</code>
       */
      public static final int F16_VALUE = 37;
      /**
       * <code>F17 = 38;</code>
       */
      public static final int F17_VALUE = 38;
      /**
       * <code>F18 = 39;</code>
       */
      public static final int F18_VALUE = 39;
      /**
       * <code>F19 = 40;</code>
       */
      public static final int F19_VALUE = 40;
      /**
       * <code>F20 = 41;</code>
       */
      public static final int F20_VALUE = 41;
      /**
       * <code>F21 = 42;</code>
       */
      public static final int F21_VALUE = 42;
      /**
       * <code>F22 = 43;</code>
       */
      public static final int F22_VALUE = 43;
      /**
       * <code>F23 = 44;</code>
       */
      public static final int F23_VALUE = 44;
      /**
       * <code>F24 = 45;</code>
       */
      public static final int F24_VALUE = 45;
      /**
       * <pre>
       * alphanumeric  VK_DBE_ALPHANUMERIC(Win), kVK_JIS_Eisu(Mac)
       * </pre>
       *
       * <code>EISU = 46;</code>
       */
      public static final int EISU_VALUE = 46;
      /**
       * <code>NUMPAD0 = 47;</code>
       */
      public static final int NUMPAD0_VALUE = 47;
      /**
       * <code>NUMPAD1 = 48;</code>
       */
      public static final int NUMPAD1_VALUE = 48;
      /**
       * <code>NUMPAD2 = 49;</code>
       */
      public static final int NUMPAD2_VALUE = 49;
      /**
       * <code>NUMPAD3 = 50;</code>
       */
      public static final int NUMPAD3_VALUE = 50;
      /**
       * <code>NUMPAD4 = 51;</code>
       */
      public static final int NUMPAD4_VALUE = 51;
      /**
       * <code>NUMPAD5 = 52;</code>
       */
      public static final int NUMPAD5_VALUE = 52;
      /**
       * <code>NUMPAD6 = 53;</code>
       */
      public static final int NUMPAD6_VALUE = 53;
      /**
       * <code>NUMPAD7 = 54;</code>
       */
      public static final int NUMPAD7_VALUE = 54;
      /**
       * <code>NUMPAD8 = 55;</code>
       */
      public static final int NUMPAD8_VALUE = 55;
      /**
       * <code>NUMPAD9 = 56;</code>
       */
      public static final int NUMPAD9_VALUE = 56;
      /**
       * <pre>
       * Numpad [*]
       * </pre>
       *
       * <code>MULTIPLY = 57;</code>
       */
      public static final int MULTIPLY_VALUE = 57;
      /**
       * <pre>
       * Numpad [+]
       * </pre>
       *
       * <code>ADD = 58;</code>
       */
      public static final int ADD_VALUE = 58;
      /**
       * <pre>
       * Numpad [enter]
       * </pre>
       *
       * <code>SEPARATOR = 59;</code>
       */
      public static final int SEPARATOR_VALUE = 59;
      /**
       * <pre>
       * Numpad [-]
       * </pre>
       *
       * <code>SUBTRACT = 60;</code>
       */
      public static final int SUBTRACT_VALUE = 60;
      /**
       * <pre>
       * Numpad [.]
       * </pre>
       *
       * <code>DECIMAL = 61;</code>
       */
      public static final int DECIMAL_VALUE = 61;
      /**
       * <pre>
       * Numpad [/]
       * </pre>
       *
       * <code>DIVIDE = 62;</code>
       */
      public static final int DIVIDE_VALUE = 62;
      /**
       * <pre>
       * Numpad [=]
       * </pre>
       *
       * <code>EQUALS = 63;</code>
       */
      public static final int EQUALS_VALUE = 63;
      /**
       * <pre>
       * Meta key event representing any text input.
       * </pre>
       *
       * <code>TEXT_INPUT = 64;</code>
       */
      public static final int TEXT_INPUT_VALUE = 64;
      /**
       * <pre>
       * GUI label is "Hankaku/Zenkaku".
       * </pre>
       *
       * <code>HANKAKU = 65;</code>
       */
      public static final int HANKAKU_VALUE = 65;
      /**
       * <code>KANJI = 66;</code>
       */
      public static final int KANJI_VALUE = 66;
      /**
       * <pre>
       * The "Katakana Hiragana Romaji" key with Shift returns this key code.
       * </pre>
       *
       * <code>KATAKANA = 67;</code>
       */
      public static final int KATAKANA_VALUE = 67;
      /**
       * <code>CAPS_LOCK = 68;</code>
       */
      public static final int CAPS_LOCK_VALUE = 68;
      /**
       * <pre>
       * Unsupported keys (e.g. PrtSc, Pause) fall back to UNDEFINED_KEY.
       * </pre>
       *
       * <code>UNDEFINED_KEY = 69;</code>
       */
      public static final int UNDEFINED_KEY_VALUE = 69;
      /**
       * <pre>
       * Numpad [,]
       * </pre>
       *
       * <code>COMMA = 70;</code>
       */
      public static final int COMMA_VALUE = 70;
      /**
       * <pre>
       * Numpad [5] without NUMLOCK
       * </pre>
       *
       * <code>CLEAR = 71;</code>
       */
      public static final int CLEAR_VALUE = 71;
      /**
       * <pre>
       * Left key on virtual (software) keyboard
       * </pre>
       *
       * <code>VIRTUAL_LEFT = 72;</code>
       */
      public static final int VIRTUAL_LEFT_VALUE = 72;
      /**
       * <pre>
       * Right key on virtual (software) keyboard
       * </pre>
       *
       * <code>VIRTUAL_RIGHT = 73;</code>
       */
      public static final int VIRTUAL_RIGHT_VALUE = 73;
      /**
       * <pre>
       * Enter key on virtual (software) keyboard
       * </pre>
       *
       * <code>VIRTUAL_ENTER = 74;</code>
       */
      public static final int VIRTUAL_ENTER_VALUE = 74;
      /**
       * <pre>
       * Up key on virtual (software) keyboard
       * </pre>
       *
       * <code>VIRTUAL_UP = 75;</code>
       */
      public static final int VIRTUAL_UP_VALUE = 75;
      /**
       * <pre>
       * Down key on virtual (software) keyboard
       * </pre>
       *
       * <code>VIRTUAL_DOWN = 76;</code>
       */
      public static final int VIRTUAL_DOWN_VALUE = 76;
      /**
       * <pre>
       * Special IME action on mobile software keyboard.
       * The actual content is in key_string.
       * </pre>
       *
       * <code>IME_ACTION = 77;</code>
       */
      public static final int IME_ACTION_VALUE = 77;
      /**
       * <code>NUM_SPECIALKEYS = 78;</code>
       */
      public static final int NUM_SPECIALKEYS_VALUE = 78;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static SpecialKey valueOf(int value) {
        return forNumber(value);
      }

      public static SpecialKey forNumber(int value) {
        switch (value) {
          case 0: return NO_SPECIALKEY;
          case 1: return DIGIT;
          case 2: return ON;
          case 3: return OFF;
          case 4: return SPACE;
          case 5: return ENTER;
          case 6: return LEFT;
          case 7: return RIGHT;
          case 8: return UP;
          case 9: return DOWN;
          case 10: return ESCAPE;
          case 11: return DEL;
          case 12: return BACKSPACE;
          case 13: return HENKAN;
          case 14: return MUHENKAN;
          case 15: return KANA;
          case 16: return HOME;
          case 17: return END;
          case 18: return TAB;
          case 19: return F1;
          case 20: return F2;
          case 21: return F3;
          case 22: return F4;
          case 23: return F5;
          case 24: return F6;
          case 25: return F7;
          case 26: return F8;
          case 27: return F9;
          case 28: return F10;
          case 29: return F11;
          case 30: return F12;
          case 31: return PAGE_UP;
          case 32: return PAGE_DOWN;
          case 33: return INSERT;
          case 34: return F13;
          case 35: return F14;
          case 36: return F15;
          case 37: return F16;
          case 38: return F17;
          case 39: return F18;
          case 40: return F19;
          case 41: return F20;
          case 42: return F21;
          case 43: return F22;
          case 44: return F23;
          case 45: return F24;
          case 46: return EISU;
          case 47: return NUMPAD0;
          case 48: return NUMPAD1;
          case 49: return NUMPAD2;
          case 50: return NUMPAD3;
          case 51: return NUMPAD4;
          case 52: return NUMPAD5;
          case 53: return NUMPAD6;
          case 54: return NUMPAD7;
          case 55: return NUMPAD8;
          case 56: return NUMPAD9;
          case 57: return MULTIPLY;
          case 58: return ADD;
          case 59: return SEPARATOR;
          case 60: return SUBTRACT;
          case 61: return DECIMAL;
          case 62: return DIVIDE;
          case 63: return EQUALS;
          case 64: return TEXT_INPUT;
          case 65: return HANKAKU;
          case 66: return KANJI;
          case 67: return KATAKANA;
          case 68: return CAPS_LOCK;
          case 69: return UNDEFINED_KEY;
          case 70: return COMMA;
          case 71: return CLEAR;
          case 72: return VIRTUAL_LEFT;
          case 73: return VIRTUAL_RIGHT;
          case 74: return VIRTUAL_ENTER;
          case 75: return VIRTUAL_UP;
          case 76: return VIRTUAL_DOWN;
          case 77: return IME_ACTION;
          case 78: return NUM_SPECIALKEYS;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<SpecialKey>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          SpecialKey> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<SpecialKey>() {
              @java.lang.Override
              public SpecialKey findValueByNumber(int number) {
                return SpecialKey.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return SpecialKeyVerifier.INSTANCE;
      }

      private static final class SpecialKeyVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new SpecialKeyVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return SpecialKey.forNumber(number) != null;
              }
            };

      private final int value;

      private SpecialKey(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.commands.KeyEvent.SpecialKey)
    }

    /**
     * Protobuf enum {@code mozc.commands.KeyEvent.ModifierKey}
     */
    public enum ModifierKey
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>CTRL = 1;</code>
       */
      CTRL(1),
      /**
       * <code>ALT = 2;</code>
       */
      ALT(2),
      /**
       * <code>SHIFT = 4;</code>
       */
      SHIFT(4),
      /**
       * <code>KEY_DOWN = 8;</code>
       */
      KEY_DOWN(8),
      /**
       * <code>KEY_UP = 16;</code>
       */
      KEY_UP(16),
      /**
       * <code>LEFT_CTRL = 32;</code>
       */
      LEFT_CTRL(32),
      /**
       * <code>LEFT_ALT = 64;</code>
       */
      LEFT_ALT(64),
      /**
       * <code>LEFT_SHIFT = 128;</code>
       */
      LEFT_SHIFT(128),
      /**
       * <code>RIGHT_CTRL = 256;</code>
       */
      RIGHT_CTRL(256),
      /**
       * <code>RIGHT_ALT = 512;</code>
       */
      RIGHT_ALT(512),
      /**
       * <code>RIGHT_SHIFT = 1024;</code>
       */
      RIGHT_SHIFT(1024),
      /**
       * <code>CAPS = 2048;</code>
       */
      CAPS(2048),
      ;

      /**
       * <code>CTRL = 1;</code>
       */
      public static final int CTRL_VALUE = 1;
      /**
       * <code>ALT = 2;</code>
       */
      public static final int ALT_VALUE = 2;
      /**
       * <code>SHIFT = 4;</code>
       */
      public static final int SHIFT_VALUE = 4;
      /**
       * <code>KEY_DOWN = 8;</code>
       */
      public static final int KEY_DOWN_VALUE = 8;
      /**
       * <code>KEY_UP = 16;</code>
       */
      public static final int KEY_UP_VALUE = 16;
      /**
       * <code>LEFT_CTRL = 32;</code>
       */
      public static final int LEFT_CTRL_VALUE = 32;
      /**
       * <code>LEFT_ALT = 64;</code>
       */
      public static final int LEFT_ALT_VALUE = 64;
      /**
       * <code>LEFT_SHIFT = 128;</code>
       */
      public static final int LEFT_SHIFT_VALUE = 128;
      /**
       * <code>RIGHT_CTRL = 256;</code>
       */
      public static final int RIGHT_CTRL_VALUE = 256;
      /**
       * <code>RIGHT_ALT = 512;</code>
       */
      public static final int RIGHT_ALT_VALUE = 512;
      /**
       * <code>RIGHT_SHIFT = 1024;</code>
       */
      public static final int RIGHT_SHIFT_VALUE = 1024;
      /**
       * <code>CAPS = 2048;</code>
       */
      public static final int CAPS_VALUE = 2048;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static ModifierKey valueOf(int value) {
        return forNumber(value);
      }

      public static ModifierKey forNumber(int value) {
        switch (value) {
          case 1: return CTRL;
          case 2: return ALT;
          case 4: return SHIFT;
          case 8: return KEY_DOWN;
          case 16: return KEY_UP;
          case 32: return LEFT_CTRL;
          case 64: return LEFT_ALT;
          case 128: return LEFT_SHIFT;
          case 256: return RIGHT_CTRL;
          case 512: return RIGHT_ALT;
          case 1024: return RIGHT_SHIFT;
          case 2048: return CAPS;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<ModifierKey>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          ModifierKey> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<ModifierKey>() {
              @java.lang.Override
              public ModifierKey findValueByNumber(int number) {
                return ModifierKey.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return ModifierKeyVerifier.INSTANCE;
      }

      private static final class ModifierKeyVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new ModifierKeyVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return ModifierKey.forNumber(number) != null;
              }
            };

      private final int value;

      private ModifierKey(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.commands.KeyEvent.ModifierKey)
    }

    /**
     * Protobuf enum {@code mozc.commands.KeyEvent.InputStyle}
     */
    public enum InputStyle
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <pre>
       * Follow the current input mode (default).
       * </pre>
       *
       * <code>FOLLOW_MODE = 0;</code>
       */
      FOLLOW_MODE(0),
      /**
       * <pre>
       * Do not transliterate key_string and use it as-is.
       * </pre>
       *
       * <code>AS_IS = 1;</code>
       */
      AS_IS(1),
      /**
       * <pre>
       * Immediately output key_string on the precomposition mode.
       * Same with AS_IS on the preedit mode.
       * </pre>
       *
       * <code>DIRECT_INPUT = 2;</code>
       */
      DIRECT_INPUT(2),
      ;

      /**
       * <pre>
       * Follow the current input mode (default).
       * </pre>
       *
       * <code>FOLLOW_MODE = 0;</code>
       */
      public static final int FOLLOW_MODE_VALUE = 0;
      /**
       * <pre>
       * Do not transliterate key_string and use it as-is.
       * </pre>
       *
       * <code>AS_IS = 1;</code>
       */
      public static final int AS_IS_VALUE = 1;
      /**
       * <pre>
       * Immediately output key_string on the precomposition mode.
       * Same with AS_IS on the preedit mode.
       * </pre>
       *
       * <code>DIRECT_INPUT = 2;</code>
       */
      public static final int DIRECT_INPUT_VALUE = 2;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static InputStyle valueOf(int value) {
        return forNumber(value);
      }

      public static InputStyle forNumber(int value) {
        switch (value) {
          case 0: return FOLLOW_MODE;
          case 1: return AS_IS;
          case 2: return DIRECT_INPUT;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<InputStyle>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          InputStyle> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<InputStyle>() {
              @java.lang.Override
              public InputStyle findValueByNumber(int number) {
                return InputStyle.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return InputStyleVerifier.INSTANCE;
      }

      private static final class InputStyleVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new InputStyleVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return InputStyle.forNumber(number) != null;
              }
            };

      private final int value;

      private InputStyle(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.commands.KeyEvent.InputStyle)
    }

    public interface ProbableKeyEventOrBuilder extends
        // @@protoc_insertion_point(interface_extends:mozc.commands.KeyEvent.ProbableKeyEvent)
        com.google.protobuf.MessageLiteOrBuilder {

      /**
       * <pre>
       * message ID is the same as Input message.
       * </pre>
       *
       * <code>optional uint32 key_code = 1;</code>
       * @return Whether the keyCode field is set.
       */
      boolean hasKeyCode();
      /**
       * <pre>
       * message ID is the same as Input message.
       * </pre>
       *
       * <code>optional uint32 key_code = 1;</code>
       * @return The keyCode.
       */
      int getKeyCode();

      /**
       * <pre>
       * Unprintable key listed above.
       * </pre>
       *
       * <code>optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;</code>
       * @return Whether the specialKey field is set.
       */
      boolean hasSpecialKey();
      /**
       * <pre>
       * Unprintable key listed above.
       * </pre>
       *
       * <code>optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;</code>
       * @return The specialKey.
       */
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.SpecialKey getSpecialKey();

      /**
       * <pre>
       * ModifierKeys
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
       * @return A list containing the modifierKeys.
       */
      java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey> getModifierKeysList();
      /**
       * <pre>
       * ModifierKeys
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
       * @return The count of modifierKeys.
       */
      int getModifierKeysCount();
      /**
       * <pre>
       * ModifierKeys
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
       * @param index The index of the element to return.
       * @return The modifierKeys at the given index.
       */
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey getModifierKeys(int index);

      /**
       * <pre>
       * Sum of probabilities must be lesser or equal than 1.
       * 0&lt;= probability &lt;= 1
       * </pre>
       *
       * <code>optional double probability = 10;</code>
       * @return Whether the probability field is set.
       */
      boolean hasProbability();
      /**
       * <pre>
       * Sum of probabilities must be lesser or equal than 1.
       * 0&lt;= probability &lt;= 1
       * </pre>
       *
       * <code>optional double probability = 10;</code>
       * @return The probability.
       */
      double getProbability();
    }
    /**
     * <pre>
     * Probable key event, mainly for touch screen.
     * User's input has ambiguity (e.g. the touch position is merginal)
     * so this message expresses the probable event.
     * </pre>
     *
     * Protobuf type {@code mozc.commands.KeyEvent.ProbableKeyEvent}
     */
    public  static final class ProbableKeyEvent extends
        com.google.protobuf.GeneratedMessageLite<
            ProbableKeyEvent, ProbableKeyEvent.Builder> implements
        // @@protoc_insertion_point(message_implements:mozc.commands.KeyEvent.ProbableKeyEvent)
        ProbableKeyEventOrBuilder {
      private ProbableKeyEvent() {
        modifierKeys_ = emptyIntList();
      }
      private int bitField0_;
      public static final int KEY_CODE_FIELD_NUMBER = 1;
      private int keyCode_;
      /**
       * <pre>
       * message ID is the same as Input message.
       * </pre>
       *
       * <code>optional uint32 key_code = 1;</code>
       * @return Whether the keyCode field is set.
       */
      @java.lang.Override
      public boolean hasKeyCode() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * message ID is the same as Input message.
       * </pre>
       *
       * <code>optional uint32 key_code = 1;</code>
       * @return The keyCode.
       */
      @java.lang.Override
      public int getKeyCode() {
        return keyCode_;
      }
      /**
       * <pre>
       * message ID is the same as Input message.
       * </pre>
       *
       * <code>optional uint32 key_code = 1;</code>
       * @param value The keyCode to set.
       */
      private void setKeyCode(int value) {
        bitField0_ |= 0x00000001;
        keyCode_ = value;
      }
      /**
       * <pre>
       * message ID is the same as Input message.
       * </pre>
       *
       * <code>optional uint32 key_code = 1;</code>
       */
      private void clearKeyCode() {
        bitField0_ = (bitField0_ & ~0x00000001);
        keyCode_ = 0;
      }

      public static final int SPECIAL_KEY_FIELD_NUMBER = 3;
      private int specialKey_;
      /**
       * <pre>
       * Unprintable key listed above.
       * </pre>
       *
       * <code>optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;</code>
       * @return Whether the specialKey field is set.
       */
      @java.lang.Override
      public boolean hasSpecialKey() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Unprintable key listed above.
       * </pre>
       *
       * <code>optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;</code>
       * @return The specialKey.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.SpecialKey getSpecialKey() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.SpecialKey result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.SpecialKey.forNumber(specialKey_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.SpecialKey.NO_SPECIALKEY : result;
      }
      /**
       * <pre>
       * Unprintable key listed above.
       * </pre>
       *
       * <code>optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;</code>
       * @param value The specialKey to set.
       */
      private void setSpecialKey(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.SpecialKey value) {
        specialKey_ = value.getNumber();
        bitField0_ |= 0x00000002;
      }
      /**
       * <pre>
       * Unprintable key listed above.
       * </pre>
       *
       * <code>optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;</code>
       */
      private void clearSpecialKey() {
        bitField0_ = (bitField0_ & ~0x00000002);
        specialKey_ = 0;
      }

      public static final int MODIFIER_KEYS_FIELD_NUMBER = 4;
      private com.google.protobuf.Internal.IntList modifierKeys_;
      private static final com.google.protobuf.Internal.ListAdapter.Converter<
          java.lang.Integer, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey> modifierKeys_converter_ =
              new com.google.protobuf.Internal.ListAdapter.Converter<
                  java.lang.Integer, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey>() {
                @java.lang.Override
                public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey convert(java.lang.Integer from) {
                  org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey.forNumber(from);
                  return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey.CTRL : result;
                }
              };
      /**
       * <pre>
       * ModifierKeys
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
       * @return A list containing the modifierKeys.
       */
      @java.lang.Override
      public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey> getModifierKeysList() {
        return new com.google.protobuf.Internal.ListAdapter<
            java.lang.Integer, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey>(modifierKeys_, modifierKeys_converter_);
      }
      /**
       * <pre>
       * ModifierKeys
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
       * @return The count of modifierKeys.
       */
      @java.lang.Override
      public int getModifierKeysCount() {
        return modifierKeys_.size();
      }
      /**
       * <pre>
       * ModifierKeys
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
       * @param index The index of the element to return.
       * @return The modifierKeys at the given index.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey getModifierKeys(int index) {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey.forNumber(modifierKeys_.getInt(index));
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey.CTRL : result;
      }
      private void ensureModifierKeysIsMutable() {
        com.google.protobuf.Internal.IntList tmp = modifierKeys_;
        if (!tmp.isModifiable()) {
          modifierKeys_ =
              com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
        }
      }
      /**
       * <pre>
       * ModifierKeys
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
       * @param index The index to set the value at.
       * @param value The modifierKeys to set.
       */
      private void setModifierKeys(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey value) {
        value.getClass();
  ensureModifierKeysIsMutable();
        modifierKeys_.setInt(index, value.getNumber());
      }
      /**
       * <pre>
       * ModifierKeys
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
       * @param value The modifierKeys to add.
       */
      private void addModifierKeys(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey value) {
        value.getClass();
  ensureModifierKeysIsMutable();
        modifierKeys_.addInt(value.getNumber());
      }
      /**
       * <pre>
       * ModifierKeys
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
       * @param values The modifierKeys to add.
       */
      private void addAllModifierKeys(
          java.lang.Iterable<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey> values) {
        ensureModifierKeysIsMutable();
        for (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey value : values) {
          modifierKeys_.addInt(value.getNumber());
        }
      }
      /**
       * <pre>
       * ModifierKeys
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
       */
      private void clearModifierKeys() {
        modifierKeys_ = emptyIntList();
      }

      public static final int PROBABILITY_FIELD_NUMBER = 10;
      private double probability_;
      /**
       * <pre>
       * Sum of probabilities must be lesser or equal than 1.
       * 0&lt;= probability &lt;= 1
       * </pre>
       *
       * <code>optional double probability = 10;</code>
       * @return Whether the probability field is set.
       */
      @java.lang.Override
      public boolean hasProbability() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Sum of probabilities must be lesser or equal than 1.
       * 0&lt;= probability &lt;= 1
       * </pre>
       *
       * <code>optional double probability = 10;</code>
       * @return The probability.
       */
      @java.lang.Override
      public double getProbability() {
        return probability_;
      }
      /**
       * <pre>
       * Sum of probabilities must be lesser or equal than 1.
       * 0&lt;= probability &lt;= 1
       * </pre>
       *
       * <code>optional double probability = 10;</code>
       * @param value The probability to set.
       */
      private void setProbability(double value) {
        bitField0_ |= 0x00000004;
        probability_ = value;
      }
      /**
       * <pre>
       * Sum of probabilities must be lesser or equal than 1.
       * 0&lt;= probability &lt;= 1
       * </pre>
       *
       * <code>optional double probability = 10;</code>
       */
      private void clearProbability() {
        bitField0_ = (bitField0_ & ~0x00000004);
        probability_ = 0D;
      }

      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }

      public static Builder newBuilder() {
        return (Builder) DEFAULT_INSTANCE.createBuilder();
      }
      public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent prototype) {
        return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
      }

      /**
       * <pre>
       * Probable key event, mainly for touch screen.
       * User's input has ambiguity (e.g. the touch position is merginal)
       * so this message expresses the probable event.
       * </pre>
       *
       * Protobuf type {@code mozc.commands.KeyEvent.ProbableKeyEvent}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageLite.Builder<
            org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent, Builder> implements
          // @@protoc_insertion_point(builder_implements:mozc.commands.KeyEvent.ProbableKeyEvent)
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEventOrBuilder {
        // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent.newBuilder()
        private Builder() {
          super(DEFAULT_INSTANCE);
        }


        /**
         * <pre>
         * message ID is the same as Input message.
         * </pre>
         *
         * <code>optional uint32 key_code = 1;</code>
         * @return Whether the keyCode field is set.
         */
        @java.lang.Override
        public boolean hasKeyCode() {
          return instance.hasKeyCode();
        }
        /**
         * <pre>
         * message ID is the same as Input message.
         * </pre>
         *
         * <code>optional uint32 key_code = 1;</code>
         * @return The keyCode.
         */
        @java.lang.Override
        public int getKeyCode() {
          return instance.getKeyCode();
        }
        /**
         * <pre>
         * message ID is the same as Input message.
         * </pre>
         *
         * <code>optional uint32 key_code = 1;</code>
         * @param value The keyCode to set.
         * @return This builder for chaining.
         */
        public Builder setKeyCode(int value) {
          copyOnWrite();
          instance.setKeyCode(value);
          return this;
        }
        /**
         * <pre>
         * message ID is the same as Input message.
         * </pre>
         *
         * <code>optional uint32 key_code = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearKeyCode() {
          copyOnWrite();
          instance.clearKeyCode();
          return this;
        }

        /**
         * <pre>
         * Unprintable key listed above.
         * </pre>
         *
         * <code>optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;</code>
         * @return Whether the specialKey field is set.
         */
        @java.lang.Override
        public boolean hasSpecialKey() {
          return instance.hasSpecialKey();
        }
        /**
         * <pre>
         * Unprintable key listed above.
         * </pre>
         *
         * <code>optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;</code>
         * @return The specialKey.
         */
        @java.lang.Override
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.SpecialKey getSpecialKey() {
          return instance.getSpecialKey();
        }
        /**
         * <pre>
         * Unprintable key listed above.
         * </pre>
         *
         * <code>optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;</code>
         * @param value The enum numeric value on the wire for specialKey to set.
         * @return This builder for chaining.
         */
        public Builder setSpecialKey(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.SpecialKey value) {
          copyOnWrite();
          instance.setSpecialKey(value);
          return this;
        }
        /**
         * <pre>
         * Unprintable key listed above.
         * </pre>
         *
         * <code>optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;</code>
         * @return This builder for chaining.
         */
        public Builder clearSpecialKey() {
          copyOnWrite();
          instance.clearSpecialKey();
          return this;
        }

        /**
         * <pre>
         * ModifierKeys
         * </pre>
         *
         * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
         * @return A list containing the modifierKeys.
         */
        @java.lang.Override
        public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey> getModifierKeysList() {
          return instance.getModifierKeysList();
        }
        /**
         * <pre>
         * ModifierKeys
         * </pre>
         *
         * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
         * @return The count of modifierKeys.
         */
        @java.lang.Override
        public int getModifierKeysCount() {
          return instance.getModifierKeysCount();
        }
        /**
         * <pre>
         * ModifierKeys
         * </pre>
         *
         * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
         * @param index The index of the element to return.
         * @return The modifierKeys at the given index.
         */
        @java.lang.Override
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey getModifierKeys(int index) {
          return instance.getModifierKeys(index);
        }
        /**
         * <pre>
         * ModifierKeys
         * </pre>
         *
         * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
         * @param index The index to set the value at.
         * @param value The modifierKeys to set.
         * @return This builder for chaining.
         */
        public Builder setModifierKeys(
            int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey value) {
          copyOnWrite();
          instance.setModifierKeys(index, value);
          return this;
        }
        /**
         * <pre>
         * ModifierKeys
         * </pre>
         *
         * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
         * @param value The modifierKeys to add.
         * @return This builder for chaining.
         */
        public Builder addModifierKeys(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey value) {
          copyOnWrite();
          instance.addModifierKeys(value);
          return this;
        }
        /**
         * <pre>
         * ModifierKeys
         * </pre>
         *
         * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
         * @param values The modifierKeys to add.
         * @return This builder for chaining.
         */
        public Builder addAllModifierKeys(
            java.lang.Iterable<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey> values) {
          copyOnWrite();
          instance.addAllModifierKeys(values);  return this;
        }
        /**
         * <pre>
         * ModifierKeys
         * </pre>
         *
         * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
         * @return This builder for chaining.
         */
        public Builder clearModifierKeys() {
          copyOnWrite();
          instance.clearModifierKeys();
          return this;
        }

        /**
         * <pre>
         * Sum of probabilities must be lesser or equal than 1.
         * 0&lt;= probability &lt;= 1
         * </pre>
         *
         * <code>optional double probability = 10;</code>
         * @return Whether the probability field is set.
         */
        @java.lang.Override
        public boolean hasProbability() {
          return instance.hasProbability();
        }
        /**
         * <pre>
         * Sum of probabilities must be lesser or equal than 1.
         * 0&lt;= probability &lt;= 1
         * </pre>
         *
         * <code>optional double probability = 10;</code>
         * @return The probability.
         */
        @java.lang.Override
        public double getProbability() {
          return instance.getProbability();
        }
        /**
         * <pre>
         * Sum of probabilities must be lesser or equal than 1.
         * 0&lt;= probability &lt;= 1
         * </pre>
         *
         * <code>optional double probability = 10;</code>
         * @param value The probability to set.
         * @return This builder for chaining.
         */
        public Builder setProbability(double value) {
          copyOnWrite();
          instance.setProbability(value);
          return this;
        }
        /**
         * <pre>
         * Sum of probabilities must be lesser or equal than 1.
         * 0&lt;= probability &lt;= 1
         * </pre>
         *
         * <code>optional double probability = 10;</code>
         * @return This builder for chaining.
         */
        public Builder clearProbability() {
          copyOnWrite();
          instance.clearProbability();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:mozc.commands.KeyEvent.ProbableKeyEvent)
      }
      @java.lang.Override
      @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
      protected final java.lang.Object dynamicMethod(
          com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
          java.lang.Object arg0, java.lang.Object arg1) {
        switch (method) {
          case NEW_MUTABLE_INSTANCE: {
            return new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent();
          }
          case NEW_BUILDER: {
            return new Builder();
          }
          case BUILD_MESSAGE_INFO: {
              java.lang.Object[] objects = new java.lang.Object[] {
                "bitField0_",
                "keyCode_",
                "specialKey_",
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.SpecialKey.internalGetVerifier(),
                "modifierKeys_",
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey.internalGetVerifier(),
                "probability_",
              };
              java.lang.String info =
                  "\u0001\u0004\u0000\u0001\u0001\n\u0004\u0000\u0001\u0000\u0001\u100b\u0000\u0003" +
                  "\u100c\u0001\u0004\u001e\n\u1000\u0002";
              return newMessageInfo(DEFAULT_INSTANCE, info, objects);
          }
          // fall through
          case GET_DEFAULT_INSTANCE: {
            return DEFAULT_INSTANCE;
          }
          case GET_PARSER: {
            com.google.protobuf.Parser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent> parser = PARSER;
            if (parser == null) {
              synchronized (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent.class) {
                parser = PARSER;
                if (parser == null) {
                  parser =
                      new DefaultInstanceBasedParser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent>(
                          DEFAULT_INSTANCE);
                  PARSER = parser;
                }
              }
            }
            return parser;
        }
        case GET_MEMOIZED_IS_INITIALIZED: {
          return (byte) 1;
        }
        case SET_MEMOIZED_IS_INITIALIZED: {
          return null;
        }
        }
        throw new UnsupportedOperationException();
      }


      // @@protoc_insertion_point(class_scope:mozc.commands.KeyEvent.ProbableKeyEvent)
      private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent DEFAULT_INSTANCE;
      static {
        ProbableKeyEvent defaultInstance = new ProbableKeyEvent();
        // New instances are implicitly immutable so no need to make
        // immutable.
        DEFAULT_INSTANCE = defaultInstance;
        com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
          ProbableKeyEvent.class, defaultInstance);
      }

      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static volatile com.google.protobuf.Parser<ProbableKeyEvent> PARSER;

      public static com.google.protobuf.Parser<ProbableKeyEvent> parser() {
        return DEFAULT_INSTANCE.getParserForType();
      }
    }

    private int bitField0_;
    public static final int KEY_CODE_FIELD_NUMBER = 1;
    private int keyCode_;
    /**
     * <pre>
     * Printable key in UCS4.  If key_code is empty, key_string is used
     * as a raw input.
     * </pre>
     *
     * <code>optional uint32 key_code = 1;</code>
     * @return Whether the keyCode field is set.
     */
    @java.lang.Override
    public boolean hasKeyCode() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Printable key in UCS4.  If key_code is empty, key_string is used
     * as a raw input.
     * </pre>
     *
     * <code>optional uint32 key_code = 1;</code>
     * @return The keyCode.
     */
    @java.lang.Override
    public int getKeyCode() {
      return keyCode_;
    }
    /**
     * <pre>
     * Printable key in UCS4.  If key_code is empty, key_string is used
     * as a raw input.
     * </pre>
     *
     * <code>optional uint32 key_code = 1;</code>
     * @param value The keyCode to set.
     */
    private void setKeyCode(int value) {
      bitField0_ |= 0x00000001;
      keyCode_ = value;
    }
    /**
     * <pre>
     * Printable key in UCS4.  If key_code is empty, key_string is used
     * as a raw input.
     * </pre>
     *
     * <code>optional uint32 key_code = 1;</code>
     */
    private void clearKeyCode() {
      bitField0_ = (bitField0_ & ~0x00000001);
      keyCode_ = 0;
    }

    public static final int MODIFIERS_FIELD_NUMBER = 2;
    private int modifiers_;
    /**
     * <pre>
     * Going to be obsolete.
     * </pre>
     *
     * <code>optional uint32 modifiers = 2;</code>
     * @return Whether the modifiers field is set.
     */
    @java.lang.Override
    public boolean hasModifiers() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Going to be obsolete.
     * </pre>
     *
     * <code>optional uint32 modifiers = 2;</code>
     * @return The modifiers.
     */
    @java.lang.Override
    public int getModifiers() {
      return modifiers_;
    }
    /**
     * <pre>
     * Going to be obsolete.
     * </pre>
     *
     * <code>optional uint32 modifiers = 2;</code>
     * @param value The modifiers to set.
     */
    private void setModifiers(int value) {
      bitField0_ |= 0x00000002;
      modifiers_ = value;
    }
    /**
     * <pre>
     * Going to be obsolete.
     * </pre>
     *
     * <code>optional uint32 modifiers = 2;</code>
     */
    private void clearModifiers() {
      bitField0_ = (bitField0_ & ~0x00000002);
      modifiers_ = 0;
    }

    public static final int SPECIAL_KEY_FIELD_NUMBER = 3;
    private int specialKey_;
    /**
     * <pre>
     * Unprintable key listed above.
     * </pre>
     *
     * <code>optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;</code>
     * @return Whether the specialKey field is set.
     */
    @java.lang.Override
    public boolean hasSpecialKey() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Unprintable key listed above.
     * </pre>
     *
     * <code>optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;</code>
     * @return The specialKey.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.SpecialKey getSpecialKey() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.SpecialKey result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.SpecialKey.forNumber(specialKey_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.SpecialKey.NO_SPECIALKEY : result;
    }
    /**
     * <pre>
     * Unprintable key listed above.
     * </pre>
     *
     * <code>optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;</code>
     * @param value The specialKey to set.
     */
    private void setSpecialKey(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.SpecialKey value) {
      specialKey_ = value.getNumber();
      bitField0_ |= 0x00000004;
    }
    /**
     * <pre>
     * Unprintable key listed above.
     * </pre>
     *
     * <code>optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;</code>
     */
    private void clearSpecialKey() {
      bitField0_ = (bitField0_ & ~0x00000004);
      specialKey_ = 0;
    }

    public static final int MODIFIER_KEYS_FIELD_NUMBER = 4;
    private com.google.protobuf.Internal.IntList modifierKeys_;
    private static final com.google.protobuf.Internal.ListAdapter.Converter<
        java.lang.Integer, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey> modifierKeys_converter_ =
            new com.google.protobuf.Internal.ListAdapter.Converter<
                java.lang.Integer, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey>() {
              @java.lang.Override
              public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey convert(java.lang.Integer from) {
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey.forNumber(from);
                return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey.CTRL : result;
              }
            };
    /**
     * <pre>
     * ModifierKeys
     * </pre>
     *
     * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
     * @return A list containing the modifierKeys.
     */
    @java.lang.Override
    public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey> getModifierKeysList() {
      return new com.google.protobuf.Internal.ListAdapter<
          java.lang.Integer, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey>(modifierKeys_, modifierKeys_converter_);
    }
    /**
     * <pre>
     * ModifierKeys
     * </pre>
     *
     * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
     * @return The count of modifierKeys.
     */
    @java.lang.Override
    public int getModifierKeysCount() {
      return modifierKeys_.size();
    }
    /**
     * <pre>
     * ModifierKeys
     * </pre>
     *
     * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
     * @param index The index of the element to return.
     * @return The modifierKeys at the given index.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey getModifierKeys(int index) {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey.forNumber(modifierKeys_.getInt(index));
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey.CTRL : result;
    }
    private void ensureModifierKeysIsMutable() {
      com.google.protobuf.Internal.IntList tmp = modifierKeys_;
      if (!tmp.isModifiable()) {
        modifierKeys_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
      }
    }
    /**
     * <pre>
     * ModifierKeys
     * </pre>
     *
     * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
     * @param index The index to set the value at.
     * @param value The modifierKeys to set.
     */
    private void setModifierKeys(
        int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey value) {
      value.getClass();
  ensureModifierKeysIsMutable();
      modifierKeys_.setInt(index, value.getNumber());
    }
    /**
     * <pre>
     * ModifierKeys
     * </pre>
     *
     * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
     * @param value The modifierKeys to add.
     */
    private void addModifierKeys(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey value) {
      value.getClass();
  ensureModifierKeysIsMutable();
      modifierKeys_.addInt(value.getNumber());
    }
    /**
     * <pre>
     * ModifierKeys
     * </pre>
     *
     * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
     * @param values The modifierKeys to add.
     */
    private void addAllModifierKeys(
        java.lang.Iterable<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey> values) {
      ensureModifierKeysIsMutable();
      for (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey value : values) {
        modifierKeys_.addInt(value.getNumber());
      }
    }
    /**
     * <pre>
     * ModifierKeys
     * </pre>
     *
     * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
     */
    private void clearModifierKeys() {
      modifierKeys_ = emptyIntList();
    }

    public static final int KEY_STRING_FIELD_NUMBER = 5;
    private java.lang.String keyString_;
    /**
     * <pre>
     * String used for preedit.  Kana characters and strings typed from
     * a software keyboard are supposed to be stored here.  If key_code
     * is also set, key_code is treated as the raw input and key_string is
     * treated as the composition input.  For example, to set Kana value,
     * when key_string is "ち", key_code should be 'a' (97).  If key_code
     * is empty, key_string is also treated as the raw input.
     * </pre>
     *
     * <code>optional string key_string = 5;</code>
     * @return Whether the keyString field is set.
     */
    @java.lang.Override
    public boolean hasKeyString() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * String used for preedit.  Kana characters and strings typed from
     * a software keyboard are supposed to be stored here.  If key_code
     * is also set, key_code is treated as the raw input and key_string is
     * treated as the composition input.  For example, to set Kana value,
     * when key_string is "ち", key_code should be 'a' (97).  If key_code
     * is empty, key_string is also treated as the raw input.
     * </pre>
     *
     * <code>optional string key_string = 5;</code>
     * @return The keyString.
     */
    @java.lang.Override
    public java.lang.String getKeyString() {
      return keyString_;
    }
    /**
     * <pre>
     * String used for preedit.  Kana characters and strings typed from
     * a software keyboard are supposed to be stored here.  If key_code
     * is also set, key_code is treated as the raw input and key_string is
     * treated as the composition input.  For example, to set Kana value,
     * when key_string is "ち", key_code should be 'a' (97).  If key_code
     * is empty, key_string is also treated as the raw input.
     * </pre>
     *
     * <code>optional string key_string = 5;</code>
     * @return The bytes for keyString.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getKeyStringBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(keyString_);
    }
    /**
     * <pre>
     * String used for preedit.  Kana characters and strings typed from
     * a software keyboard are supposed to be stored here.  If key_code
     * is also set, key_code is treated as the raw input and key_string is
     * treated as the composition input.  For example, to set Kana value,
     * when key_string is "ち", key_code should be 'a' (97).  If key_code
     * is empty, key_string is also treated as the raw input.
     * </pre>
     *
     * <code>optional string key_string = 5;</code>
     * @param value The keyString to set.
     */
    private void setKeyString(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000008;
      keyString_ = value;
    }
    /**
     * <pre>
     * String used for preedit.  Kana characters and strings typed from
     * a software keyboard are supposed to be stored here.  If key_code
     * is also set, key_code is treated as the raw input and key_string is
     * treated as the composition input.  For example, to set Kana value,
     * when key_string is "ち", key_code should be 'a' (97).  If key_code
     * is empty, key_string is also treated as the raw input.
     * </pre>
     *
     * <code>optional string key_string = 5;</code>
     */
    private void clearKeyString() {
      bitField0_ = (bitField0_ & ~0x00000008);
      keyString_ = getDefaultInstance().getKeyString();
    }
    /**
     * <pre>
     * String used for preedit.  Kana characters and strings typed from
     * a software keyboard are supposed to be stored here.  If key_code
     * is also set, key_code is treated as the raw input and key_string is
     * treated as the composition input.  For example, to set Kana value,
     * when key_string is "ち", key_code should be 'a' (97).  If key_code
     * is empty, key_string is also treated as the raw input.
     * </pre>
     *
     * <code>optional string key_string = 5;</code>
     * @param value The bytes for keyString to set.
     */
    private void setKeyStringBytes(
        com.google.protobuf.ByteString value) {
      keyString_ = value.toStringUtf8();
      bitField0_ |= 0x00000008;
    }

    public static final int INPUT_STYLE_FIELD_NUMBER = 6;
    private int inputStyle_;
    /**
     * <code>optional .mozc.commands.KeyEvent.InputStyle input_style = 6 [default = FOLLOW_MODE];</code>
     * @return Whether the inputStyle field is set.
     */
    @java.lang.Override
    public boolean hasInputStyle() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <code>optional .mozc.commands.KeyEvent.InputStyle input_style = 6 [default = FOLLOW_MODE];</code>
     * @return The inputStyle.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.InputStyle getInputStyle() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.InputStyle result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.InputStyle.forNumber(inputStyle_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.InputStyle.FOLLOW_MODE : result;
    }
    /**
     * <code>optional .mozc.commands.KeyEvent.InputStyle input_style = 6 [default = FOLLOW_MODE];</code>
     * @param value The inputStyle to set.
     */
    private void setInputStyle(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.InputStyle value) {
      inputStyle_ = value.getNumber();
      bitField0_ |= 0x00000010;
    }
    /**
     * <code>optional .mozc.commands.KeyEvent.InputStyle input_style = 6 [default = FOLLOW_MODE];</code>
     */
    private void clearInputStyle() {
      bitField0_ = (bitField0_ & ~0x00000010);
      inputStyle_ = 0;
    }

    public static final int MODE_FIELD_NUMBER = 7;
    private int mode_;
    /**
     * <pre>
     * Composition mode
     * For histrical reasons, this field expects a temporary conversion
     * mode rather than comeback input mode.
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode mode = 7;</code>
     * @return Whether the mode field is set.
     */
    @java.lang.Override
    public boolean hasMode() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * Composition mode
     * For histrical reasons, this field expects a temporary conversion
     * mode rather than comeback input mode.
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode mode = 7;</code>
     * @return The mode.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode getMode() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode.forNumber(mode_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode.DIRECT : result;
    }
    /**
     * <pre>
     * Composition mode
     * For histrical reasons, this field expects a temporary conversion
     * mode rather than comeback input mode.
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode mode = 7;</code>
     * @param value The mode to set.
     */
    private void setMode(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode value) {
      mode_ = value.getNumber();
      bitField0_ |= 0x00000020;
    }
    /**
     * <pre>
     * Composition mode
     * For histrical reasons, this field expects a temporary conversion
     * mode rather than comeback input mode.
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode mode = 7;</code>
     */
    private void clearMode() {
      bitField0_ = (bitField0_ & ~0x00000020);
      mode_ = 0;
    }

    public static final int PROBABLE_KEY_EVENT_FIELD_NUMBER = 8;
    private com.google.protobuf.Internal.ProtobufList<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent> probableKeyEvent_;
    /**
     * <pre>
     * Probable key events
     * Even if you can fill this field,
     * don't omit Input.key_code and so on
     * because preedit string is composed based on them.
     * </pre>
     *
     * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
     */
    @java.lang.Override
    public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent> getProbableKeyEventList() {
      return probableKeyEvent_;
    }
    /**
     * <pre>
     * Probable key events
     * Even if you can fill this field,
     * don't omit Input.key_code and so on
     * because preedit string is composed based on them.
     * </pre>
     *
     * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
     */
    public java.util.List<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEventOrBuilder> 
        getProbableKeyEventOrBuilderList() {
      return probableKeyEvent_;
    }
    /**
     * <pre>
     * Probable key events
     * Even if you can fill this field,
     * don't omit Input.key_code and so on
     * because preedit string is composed based on them.
     * </pre>
     *
     * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
     */
    @java.lang.Override
    public int getProbableKeyEventCount() {
      return probableKeyEvent_.size();
    }
    /**
     * <pre>
     * Probable key events
     * Even if you can fill this field,
     * don't omit Input.key_code and so on
     * because preedit string is composed based on them.
     * </pre>
     *
     * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent getProbableKeyEvent(int index) {
      return probableKeyEvent_.get(index);
    }
    /**
     * <pre>
     * Probable key events
     * Even if you can fill this field,
     * don't omit Input.key_code and so on
     * because preedit string is composed based on them.
     * </pre>
     *
     * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
     */
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEventOrBuilder getProbableKeyEventOrBuilder(
        int index) {
      return probableKeyEvent_.get(index);
    }
    private void ensureProbableKeyEventIsMutable() {
      com.google.protobuf.Internal.ProtobufList<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent> tmp = probableKeyEvent_;
      if (!tmp.isModifiable()) {
        probableKeyEvent_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * Probable key events
     * Even if you can fill this field,
     * don't omit Input.key_code and so on
     * because preedit string is composed based on them.
     * </pre>
     *
     * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
     */
    private void setProbableKeyEvent(
        int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent value) {
      value.getClass();
  ensureProbableKeyEventIsMutable();
      probableKeyEvent_.set(index, value);
    }
    /**
     * <pre>
     * Probable key events
     * Even if you can fill this field,
     * don't omit Input.key_code and so on
     * because preedit string is composed based on them.
     * </pre>
     *
     * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
     */
    private void addProbableKeyEvent(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent value) {
      value.getClass();
  ensureProbableKeyEventIsMutable();
      probableKeyEvent_.add(value);
    }
    /**
     * <pre>
     * Probable key events
     * Even if you can fill this field,
     * don't omit Input.key_code and so on
     * because preedit string is composed based on them.
     * </pre>
     *
     * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
     */
    private void addProbableKeyEvent(
        int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent value) {
      value.getClass();
  ensureProbableKeyEventIsMutable();
      probableKeyEvent_.add(index, value);
    }
    /**
     * <pre>
     * Probable key events
     * Even if you can fill this field,
     * don't omit Input.key_code and so on
     * because preedit string is composed based on them.
     * </pre>
     *
     * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
     */
    private void addAllProbableKeyEvent(
        java.lang.Iterable<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent> values) {
      ensureProbableKeyEventIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, probableKeyEvent_);
    }
    /**
     * <pre>
     * Probable key events
     * Even if you can fill this field,
     * don't omit Input.key_code and so on
     * because preedit string is composed based on them.
     * </pre>
     *
     * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
     */
    private void clearProbableKeyEvent() {
      probableKeyEvent_ = emptyProtobufList();
    }
    /**
     * <pre>
     * Probable key events
     * Even if you can fill this field,
     * don't omit Input.key_code and so on
     * because preedit string is composed based on them.
     * </pre>
     *
     * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
     */
    private void removeProbableKeyEvent(int index) {
      ensureProbableKeyEventIsMutable();
      probableKeyEvent_.remove(index);
    }

    public static final int ACTIVATED_FIELD_NUMBER = 9;
    private boolean activated_;
    /**
     * <pre>
     * IME on/off mode
     * You can use this field to change the IME on/off mode indirectly without
     * sending SpecialKey:ON or SpecialKey:OFF events.
     * If the internal ImeContext::State is DIRECT and this field is true, the
     * converter will change the state to PRECONPOSITION and then handles this key
     * event.
     * If the internal ImeContext::State is not DIRECT and this field is false,
     * the converter will change the state to DIRECT and then handles this key
     * event.
     * Implementation note: We need both |mode| and |activated| to support
     * indirect IME off, where |mode| should contain the next mode. If this field
     * is not set, the server will act as if indirect on/off was not supported.
     * </pre>
     *
     * <code>optional bool activated = 9;</code>
     * @return Whether the activated field is set.
     */
    @java.lang.Override
    public boolean hasActivated() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * IME on/off mode
     * You can use this field to change the IME on/off mode indirectly without
     * sending SpecialKey:ON or SpecialKey:OFF events.
     * If the internal ImeContext::State is DIRECT and this field is true, the
     * converter will change the state to PRECONPOSITION and then handles this key
     * event.
     * If the internal ImeContext::State is not DIRECT and this field is false,
     * the converter will change the state to DIRECT and then handles this key
     * event.
     * Implementation note: We need both |mode| and |activated| to support
     * indirect IME off, where |mode| should contain the next mode. If this field
     * is not set, the server will act as if indirect on/off was not supported.
     * </pre>
     *
     * <code>optional bool activated = 9;</code>
     * @return The activated.
     */
    @java.lang.Override
    public boolean getActivated() {
      return activated_;
    }
    /**
     * <pre>
     * IME on/off mode
     * You can use this field to change the IME on/off mode indirectly without
     * sending SpecialKey:ON or SpecialKey:OFF events.
     * If the internal ImeContext::State is DIRECT and this field is true, the
     * converter will change the state to PRECONPOSITION and then handles this key
     * event.
     * If the internal ImeContext::State is not DIRECT and this field is false,
     * the converter will change the state to DIRECT and then handles this key
     * event.
     * Implementation note: We need both |mode| and |activated| to support
     * indirect IME off, where |mode| should contain the next mode. If this field
     * is not set, the server will act as if indirect on/off was not supported.
     * </pre>
     *
     * <code>optional bool activated = 9;</code>
     * @param value The activated to set.
     */
    private void setActivated(boolean value) {
      bitField0_ |= 0x00000040;
      activated_ = value;
    }
    /**
     * <pre>
     * IME on/off mode
     * You can use this field to change the IME on/off mode indirectly without
     * sending SpecialKey:ON or SpecialKey:OFF events.
     * If the internal ImeContext::State is DIRECT and this field is true, the
     * converter will change the state to PRECONPOSITION and then handles this key
     * event.
     * If the internal ImeContext::State is not DIRECT and this field is false,
     * the converter will change the state to DIRECT and then handles this key
     * event.
     * Implementation note: We need both |mode| and |activated| to support
     * indirect IME off, where |mode| should contain the next mode. If this field
     * is not set, the server will act as if indirect on/off was not supported.
     * </pre>
     *
     * <code>optional bool activated = 9;</code>
     */
    private void clearActivated() {
      bitField0_ = (bitField0_ & ~0x00000040);
      activated_ = false;
    }

    public static final int TIMESTAMP_MSEC_FIELD_NUMBER = 10;
    private long timestampMsec_;
    /**
     * <pre>
     * Timestamp of this key event in millisecond.
     * </pre>
     *
     * <code>optional int64 timestamp_msec = 10;</code>
     * @return Whether the timestampMsec field is set.
     */
    @java.lang.Override
    public boolean hasTimestampMsec() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * Timestamp of this key event in millisecond.
     * </pre>
     *
     * <code>optional int64 timestamp_msec = 10;</code>
     * @return The timestampMsec.
     */
    @java.lang.Override
    public long getTimestampMsec() {
      return timestampMsec_;
    }
    /**
     * <pre>
     * Timestamp of this key event in millisecond.
     * </pre>
     *
     * <code>optional int64 timestamp_msec = 10;</code>
     * @param value The timestampMsec to set.
     */
    private void setTimestampMsec(long value) {
      bitField0_ |= 0x00000080;
      timestampMsec_ = value;
    }
    /**
     * <pre>
     * Timestamp of this key event in millisecond.
     * </pre>
     *
     * <code>optional int64 timestamp_msec = 10;</code>
     */
    private void clearTimestampMsec() {
      bitField0_ = (bitField0_ & ~0x00000080);
      timestampMsec_ = 0L;
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code mozc.commands.KeyEvent}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent, Builder> implements
        // @@protoc_insertion_point(builder_implements:mozc.commands.KeyEvent)
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEventOrBuilder {
      // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Printable key in UCS4.  If key_code is empty, key_string is used
       * as a raw input.
       * </pre>
       *
       * <code>optional uint32 key_code = 1;</code>
       * @return Whether the keyCode field is set.
       */
      @java.lang.Override
      public boolean hasKeyCode() {
        return instance.hasKeyCode();
      }
      /**
       * <pre>
       * Printable key in UCS4.  If key_code is empty, key_string is used
       * as a raw input.
       * </pre>
       *
       * <code>optional uint32 key_code = 1;</code>
       * @return The keyCode.
       */
      @java.lang.Override
      public int getKeyCode() {
        return instance.getKeyCode();
      }
      /**
       * <pre>
       * Printable key in UCS4.  If key_code is empty, key_string is used
       * as a raw input.
       * </pre>
       *
       * <code>optional uint32 key_code = 1;</code>
       * @param value The keyCode to set.
       * @return This builder for chaining.
       */
      public Builder setKeyCode(int value) {
        copyOnWrite();
        instance.setKeyCode(value);
        return this;
      }
      /**
       * <pre>
       * Printable key in UCS4.  If key_code is empty, key_string is used
       * as a raw input.
       * </pre>
       *
       * <code>optional uint32 key_code = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearKeyCode() {
        copyOnWrite();
        instance.clearKeyCode();
        return this;
      }

      /**
       * <pre>
       * Going to be obsolete.
       * </pre>
       *
       * <code>optional uint32 modifiers = 2;</code>
       * @return Whether the modifiers field is set.
       */
      @java.lang.Override
      public boolean hasModifiers() {
        return instance.hasModifiers();
      }
      /**
       * <pre>
       * Going to be obsolete.
       * </pre>
       *
       * <code>optional uint32 modifiers = 2;</code>
       * @return The modifiers.
       */
      @java.lang.Override
      public int getModifiers() {
        return instance.getModifiers();
      }
      /**
       * <pre>
       * Going to be obsolete.
       * </pre>
       *
       * <code>optional uint32 modifiers = 2;</code>
       * @param value The modifiers to set.
       * @return This builder for chaining.
       */
      public Builder setModifiers(int value) {
        copyOnWrite();
        instance.setModifiers(value);
        return this;
      }
      /**
       * <pre>
       * Going to be obsolete.
       * </pre>
       *
       * <code>optional uint32 modifiers = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearModifiers() {
        copyOnWrite();
        instance.clearModifiers();
        return this;
      }

      /**
       * <pre>
       * Unprintable key listed above.
       * </pre>
       *
       * <code>optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;</code>
       * @return Whether the specialKey field is set.
       */
      @java.lang.Override
      public boolean hasSpecialKey() {
        return instance.hasSpecialKey();
      }
      /**
       * <pre>
       * Unprintable key listed above.
       * </pre>
       *
       * <code>optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;</code>
       * @return The specialKey.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.SpecialKey getSpecialKey() {
        return instance.getSpecialKey();
      }
      /**
       * <pre>
       * Unprintable key listed above.
       * </pre>
       *
       * <code>optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;</code>
       * @param value The enum numeric value on the wire for specialKey to set.
       * @return This builder for chaining.
       */
      public Builder setSpecialKey(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.SpecialKey value) {
        copyOnWrite();
        instance.setSpecialKey(value);
        return this;
      }
      /**
       * <pre>
       * Unprintable key listed above.
       * </pre>
       *
       * <code>optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearSpecialKey() {
        copyOnWrite();
        instance.clearSpecialKey();
        return this;
      }

      /**
       * <pre>
       * ModifierKeys
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
       * @return A list containing the modifierKeys.
       */
      @java.lang.Override
      public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey> getModifierKeysList() {
        return instance.getModifierKeysList();
      }
      /**
       * <pre>
       * ModifierKeys
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
       * @return The count of modifierKeys.
       */
      @java.lang.Override
      public int getModifierKeysCount() {
        return instance.getModifierKeysCount();
      }
      /**
       * <pre>
       * ModifierKeys
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
       * @param index The index of the element to return.
       * @return The modifierKeys at the given index.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey getModifierKeys(int index) {
        return instance.getModifierKeys(index);
      }
      /**
       * <pre>
       * ModifierKeys
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
       * @param index The index to set the value at.
       * @param value The modifierKeys to set.
       * @return This builder for chaining.
       */
      public Builder setModifierKeys(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey value) {
        copyOnWrite();
        instance.setModifierKeys(index, value);
        return this;
      }
      /**
       * <pre>
       * ModifierKeys
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
       * @param value The modifierKeys to add.
       * @return This builder for chaining.
       */
      public Builder addModifierKeys(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey value) {
        copyOnWrite();
        instance.addModifierKeys(value);
        return this;
      }
      /**
       * <pre>
       * ModifierKeys
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
       * @param values The modifierKeys to add.
       * @return This builder for chaining.
       */
      public Builder addAllModifierKeys(
          java.lang.Iterable<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey> values) {
        copyOnWrite();
        instance.addAllModifierKeys(values);  return this;
      }
      /**
       * <pre>
       * ModifierKeys
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearModifierKeys() {
        copyOnWrite();
        instance.clearModifierKeys();
        return this;
      }

      /**
       * <pre>
       * String used for preedit.  Kana characters and strings typed from
       * a software keyboard are supposed to be stored here.  If key_code
       * is also set, key_code is treated as the raw input and key_string is
       * treated as the composition input.  For example, to set Kana value,
       * when key_string is "ち", key_code should be 'a' (97).  If key_code
       * is empty, key_string is also treated as the raw input.
       * </pre>
       *
       * <code>optional string key_string = 5;</code>
       * @return Whether the keyString field is set.
       */
      @java.lang.Override
      public boolean hasKeyString() {
        return instance.hasKeyString();
      }
      /**
       * <pre>
       * String used for preedit.  Kana characters and strings typed from
       * a software keyboard are supposed to be stored here.  If key_code
       * is also set, key_code is treated as the raw input and key_string is
       * treated as the composition input.  For example, to set Kana value,
       * when key_string is "ち", key_code should be 'a' (97).  If key_code
       * is empty, key_string is also treated as the raw input.
       * </pre>
       *
       * <code>optional string key_string = 5;</code>
       * @return The keyString.
       */
      @java.lang.Override
      public java.lang.String getKeyString() {
        return instance.getKeyString();
      }
      /**
       * <pre>
       * String used for preedit.  Kana characters and strings typed from
       * a software keyboard are supposed to be stored here.  If key_code
       * is also set, key_code is treated as the raw input and key_string is
       * treated as the composition input.  For example, to set Kana value,
       * when key_string is "ち", key_code should be 'a' (97).  If key_code
       * is empty, key_string is also treated as the raw input.
       * </pre>
       *
       * <code>optional string key_string = 5;</code>
       * @return The bytes for keyString.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getKeyStringBytes() {
        return instance.getKeyStringBytes();
      }
      /**
       * <pre>
       * String used for preedit.  Kana characters and strings typed from
       * a software keyboard are supposed to be stored here.  If key_code
       * is also set, key_code is treated as the raw input and key_string is
       * treated as the composition input.  For example, to set Kana value,
       * when key_string is "ち", key_code should be 'a' (97).  If key_code
       * is empty, key_string is also treated as the raw input.
       * </pre>
       *
       * <code>optional string key_string = 5;</code>
       * @param value The keyString to set.
       * @return This builder for chaining.
       */
      public Builder setKeyString(
          java.lang.String value) {
        copyOnWrite();
        instance.setKeyString(value);
        return this;
      }
      /**
       * <pre>
       * String used for preedit.  Kana characters and strings typed from
       * a software keyboard are supposed to be stored here.  If key_code
       * is also set, key_code is treated as the raw input and key_string is
       * treated as the composition input.  For example, to set Kana value,
       * when key_string is "ち", key_code should be 'a' (97).  If key_code
       * is empty, key_string is also treated as the raw input.
       * </pre>
       *
       * <code>optional string key_string = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearKeyString() {
        copyOnWrite();
        instance.clearKeyString();
        return this;
      }
      /**
       * <pre>
       * String used for preedit.  Kana characters and strings typed from
       * a software keyboard are supposed to be stored here.  If key_code
       * is also set, key_code is treated as the raw input and key_string is
       * treated as the composition input.  For example, to set Kana value,
       * when key_string is "ち", key_code should be 'a' (97).  If key_code
       * is empty, key_string is also treated as the raw input.
       * </pre>
       *
       * <code>optional string key_string = 5;</code>
       * @param value The bytes for keyString to set.
       * @return This builder for chaining.
       */
      public Builder setKeyStringBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setKeyStringBytes(value);
        return this;
      }

      /**
       * <code>optional .mozc.commands.KeyEvent.InputStyle input_style = 6 [default = FOLLOW_MODE];</code>
       * @return Whether the inputStyle field is set.
       */
      @java.lang.Override
      public boolean hasInputStyle() {
        return instance.hasInputStyle();
      }
      /**
       * <code>optional .mozc.commands.KeyEvent.InputStyle input_style = 6 [default = FOLLOW_MODE];</code>
       * @return The inputStyle.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.InputStyle getInputStyle() {
        return instance.getInputStyle();
      }
      /**
       * <code>optional .mozc.commands.KeyEvent.InputStyle input_style = 6 [default = FOLLOW_MODE];</code>
       * @param value The enum numeric value on the wire for inputStyle to set.
       * @return This builder for chaining.
       */
      public Builder setInputStyle(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.InputStyle value) {
        copyOnWrite();
        instance.setInputStyle(value);
        return this;
      }
      /**
       * <code>optional .mozc.commands.KeyEvent.InputStyle input_style = 6 [default = FOLLOW_MODE];</code>
       * @return This builder for chaining.
       */
      public Builder clearInputStyle() {
        copyOnWrite();
        instance.clearInputStyle();
        return this;
      }

      /**
       * <pre>
       * Composition mode
       * For histrical reasons, this field expects a temporary conversion
       * mode rather than comeback input mode.
       * </pre>
       *
       * <code>optional .mozc.commands.CompositionMode mode = 7;</code>
       * @return Whether the mode field is set.
       */
      @java.lang.Override
      public boolean hasMode() {
        return instance.hasMode();
      }
      /**
       * <pre>
       * Composition mode
       * For histrical reasons, this field expects a temporary conversion
       * mode rather than comeback input mode.
       * </pre>
       *
       * <code>optional .mozc.commands.CompositionMode mode = 7;</code>
       * @return The mode.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode getMode() {
        return instance.getMode();
      }
      /**
       * <pre>
       * Composition mode
       * For histrical reasons, this field expects a temporary conversion
       * mode rather than comeback input mode.
       * </pre>
       *
       * <code>optional .mozc.commands.CompositionMode mode = 7;</code>
       * @param value The enum numeric value on the wire for mode to set.
       * @return This builder for chaining.
       */
      public Builder setMode(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode value) {
        copyOnWrite();
        instance.setMode(value);
        return this;
      }
      /**
       * <pre>
       * Composition mode
       * For histrical reasons, this field expects a temporary conversion
       * mode rather than comeback input mode.
       * </pre>
       *
       * <code>optional .mozc.commands.CompositionMode mode = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearMode() {
        copyOnWrite();
        instance.clearMode();
        return this;
      }

      /**
       * <pre>
       * Probable key events
       * Even if you can fill this field,
       * don't omit Input.key_code and so on
       * because preedit string is composed based on them.
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
       */
      @java.lang.Override
      public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent> getProbableKeyEventList() {
        return java.util.Collections.unmodifiableList(
            instance.getProbableKeyEventList());
      }
      /**
       * <pre>
       * Probable key events
       * Even if you can fill this field,
       * don't omit Input.key_code and so on
       * because preedit string is composed based on them.
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
       */
      @java.lang.Override
      public int getProbableKeyEventCount() {
        return instance.getProbableKeyEventCount();
      }/**
       * <pre>
       * Probable key events
       * Even if you can fill this field,
       * don't omit Input.key_code and so on
       * because preedit string is composed based on them.
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent getProbableKeyEvent(int index) {
        return instance.getProbableKeyEvent(index);
      }
      /**
       * <pre>
       * Probable key events
       * Even if you can fill this field,
       * don't omit Input.key_code and so on
       * because preedit string is composed based on them.
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
       */
      public Builder setProbableKeyEvent(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent value) {
        copyOnWrite();
        instance.setProbableKeyEvent(index, value);
        return this;
      }
      /**
       * <pre>
       * Probable key events
       * Even if you can fill this field,
       * don't omit Input.key_code and so on
       * because preedit string is composed based on them.
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
       */
      public Builder setProbableKeyEvent(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent.Builder builderForValue) {
        copyOnWrite();
        instance.setProbableKeyEvent(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Probable key events
       * Even if you can fill this field,
       * don't omit Input.key_code and so on
       * because preedit string is composed based on them.
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
       */
      public Builder addProbableKeyEvent(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent value) {
        copyOnWrite();
        instance.addProbableKeyEvent(value);
        return this;
      }
      /**
       * <pre>
       * Probable key events
       * Even if you can fill this field,
       * don't omit Input.key_code and so on
       * because preedit string is composed based on them.
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
       */
      public Builder addProbableKeyEvent(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent value) {
        copyOnWrite();
        instance.addProbableKeyEvent(index, value);
        return this;
      }
      /**
       * <pre>
       * Probable key events
       * Even if you can fill this field,
       * don't omit Input.key_code and so on
       * because preedit string is composed based on them.
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
       */
      public Builder addProbableKeyEvent(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent.Builder builderForValue) {
        copyOnWrite();
        instance.addProbableKeyEvent(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Probable key events
       * Even if you can fill this field,
       * don't omit Input.key_code and so on
       * because preedit string is composed based on them.
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
       */
      public Builder addProbableKeyEvent(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent.Builder builderForValue) {
        copyOnWrite();
        instance.addProbableKeyEvent(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Probable key events
       * Even if you can fill this field,
       * don't omit Input.key_code and so on
       * because preedit string is composed based on them.
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
       */
      public Builder addAllProbableKeyEvent(
          java.lang.Iterable<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent> values) {
        copyOnWrite();
        instance.addAllProbableKeyEvent(values);
        return this;
      }
      /**
       * <pre>
       * Probable key events
       * Even if you can fill this field,
       * don't omit Input.key_code and so on
       * because preedit string is composed based on them.
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
       */
      public Builder clearProbableKeyEvent() {
        copyOnWrite();
        instance.clearProbableKeyEvent();
        return this;
      }
      /**
       * <pre>
       * Probable key events
       * Even if you can fill this field,
       * don't omit Input.key_code and so on
       * because preedit string is composed based on them.
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
       */
      public Builder removeProbableKeyEvent(int index) {
        copyOnWrite();
        instance.removeProbableKeyEvent(index);
        return this;
      }

      /**
       * <pre>
       * IME on/off mode
       * You can use this field to change the IME on/off mode indirectly without
       * sending SpecialKey:ON or SpecialKey:OFF events.
       * If the internal ImeContext::State is DIRECT and this field is true, the
       * converter will change the state to PRECONPOSITION and then handles this key
       * event.
       * If the internal ImeContext::State is not DIRECT and this field is false,
       * the converter will change the state to DIRECT and then handles this key
       * event.
       * Implementation note: We need both |mode| and |activated| to support
       * indirect IME off, where |mode| should contain the next mode. If this field
       * is not set, the server will act as if indirect on/off was not supported.
       * </pre>
       *
       * <code>optional bool activated = 9;</code>
       * @return Whether the activated field is set.
       */
      @java.lang.Override
      public boolean hasActivated() {
        return instance.hasActivated();
      }
      /**
       * <pre>
       * IME on/off mode
       * You can use this field to change the IME on/off mode indirectly without
       * sending SpecialKey:ON or SpecialKey:OFF events.
       * If the internal ImeContext::State is DIRECT and this field is true, the
       * converter will change the state to PRECONPOSITION and then handles this key
       * event.
       * If the internal ImeContext::State is not DIRECT and this field is false,
       * the converter will change the state to DIRECT and then handles this key
       * event.
       * Implementation note: We need both |mode| and |activated| to support
       * indirect IME off, where |mode| should contain the next mode. If this field
       * is not set, the server will act as if indirect on/off was not supported.
       * </pre>
       *
       * <code>optional bool activated = 9;</code>
       * @return The activated.
       */
      @java.lang.Override
      public boolean getActivated() {
        return instance.getActivated();
      }
      /**
       * <pre>
       * IME on/off mode
       * You can use this field to change the IME on/off mode indirectly without
       * sending SpecialKey:ON or SpecialKey:OFF events.
       * If the internal ImeContext::State is DIRECT and this field is true, the
       * converter will change the state to PRECONPOSITION and then handles this key
       * event.
       * If the internal ImeContext::State is not DIRECT and this field is false,
       * the converter will change the state to DIRECT and then handles this key
       * event.
       * Implementation note: We need both |mode| and |activated| to support
       * indirect IME off, where |mode| should contain the next mode. If this field
       * is not set, the server will act as if indirect on/off was not supported.
       * </pre>
       *
       * <code>optional bool activated = 9;</code>
       * @param value The activated to set.
       * @return This builder for chaining.
       */
      public Builder setActivated(boolean value) {
        copyOnWrite();
        instance.setActivated(value);
        return this;
      }
      /**
       * <pre>
       * IME on/off mode
       * You can use this field to change the IME on/off mode indirectly without
       * sending SpecialKey:ON or SpecialKey:OFF events.
       * If the internal ImeContext::State is DIRECT and this field is true, the
       * converter will change the state to PRECONPOSITION and then handles this key
       * event.
       * If the internal ImeContext::State is not DIRECT and this field is false,
       * the converter will change the state to DIRECT and then handles this key
       * event.
       * Implementation note: We need both |mode| and |activated| to support
       * indirect IME off, where |mode| should contain the next mode. If this field
       * is not set, the server will act as if indirect on/off was not supported.
       * </pre>
       *
       * <code>optional bool activated = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearActivated() {
        copyOnWrite();
        instance.clearActivated();
        return this;
      }

      /**
       * <pre>
       * Timestamp of this key event in millisecond.
       * </pre>
       *
       * <code>optional int64 timestamp_msec = 10;</code>
       * @return Whether the timestampMsec field is set.
       */
      @java.lang.Override
      public boolean hasTimestampMsec() {
        return instance.hasTimestampMsec();
      }
      /**
       * <pre>
       * Timestamp of this key event in millisecond.
       * </pre>
       *
       * <code>optional int64 timestamp_msec = 10;</code>
       * @return The timestampMsec.
       */
      @java.lang.Override
      public long getTimestampMsec() {
        return instance.getTimestampMsec();
      }
      /**
       * <pre>
       * Timestamp of this key event in millisecond.
       * </pre>
       *
       * <code>optional int64 timestamp_msec = 10;</code>
       * @param value The timestampMsec to set.
       * @return This builder for chaining.
       */
      public Builder setTimestampMsec(long value) {
        copyOnWrite();
        instance.setTimestampMsec(value);
        return this;
      }
      /**
       * <pre>
       * Timestamp of this key event in millisecond.
       * </pre>
       *
       * <code>optional int64 timestamp_msec = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearTimestampMsec() {
        copyOnWrite();
        instance.clearTimestampMsec();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:mozc.commands.KeyEvent)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "keyCode_",
              "modifiers_",
              "specialKey_",
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.SpecialKey.internalGetVerifier(),
              "modifierKeys_",
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey.internalGetVerifier(),
              "keyString_",
              "inputStyle_",
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.InputStyle.internalGetVerifier(),
              "mode_",
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode.internalGetVerifier(),
              "probableKeyEvent_",
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent.class,
              "activated_",
              "timestampMsec_",
            };
            java.lang.String info =
                "\u0001\n\u0000\u0001\u0001\n\n\u0000\u0002\u0000\u0001\u100b\u0000\u0002\u100b\u0001" +
                "\u0003\u100c\u0002\u0004\u001e\u0005\u1008\u0003\u0006\u100c\u0004\u0007\u100c\u0005" +
                "\b\u001b\t\u1007\u0006\n\u1002\u0007";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent> parser = PARSER;
          if (parser == null) {
            synchronized (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:mozc.commands.KeyEvent)
    private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent DEFAULT_INSTANCE;
    static {
      KeyEvent defaultInstance = new KeyEvent();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        KeyEvent.class, defaultInstance);
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<KeyEvent> PARSER;

    public static com.google.protobuf.Parser<KeyEvent> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface SessionCommandOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mozc.commands.SessionCommand)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>required .mozc.commands.SessionCommand.CommandType type = 1;</code>
     * @return Whether the type field is set.
     */
    boolean hasType();
    /**
     * <code>required .mozc.commands.SessionCommand.CommandType type = 1;</code>
     * @return The type.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CommandType getType();

    /**
     * <pre>
     * Unique number specifying a candidate word.
     * Note: This value is NOT an index of the candidate window or the candidate
     * list. This value is a return value of CandidateWord::id().
     * </pre>
     *
     * <code>optional int32 id = 2;</code>
     * @return Whether the id field is set.
     */
    boolean hasId();
    /**
     * <pre>
     * Unique number specifying a candidate word.
     * Note: This value is NOT an index of the candidate window or the candidate
     * list. This value is a return value of CandidateWord::id().
     * </pre>
     *
     * <code>optional int32 id = 2;</code>
     * @return The id.
     */
    int getId();

    /**
     * <pre>
     * This is used with SWITCH_COMPOSITION_MODE, TURN_ON_IME and TURN_OFF_IME.
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode composition_mode = 3;</code>
     * @return Whether the compositionMode field is set.
     */
    boolean hasCompositionMode();
    /**
     * <pre>
     * This is used with SWITCH_COMPOSITION_MODE, TURN_ON_IME and TURN_OFF_IME.
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode composition_mode = 3;</code>
     * @return The compositionMode.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode getCompositionMode();

    /**
     * <pre>
     * Text argument.  This is used by CONVERT_REVERSE at this moment.
     * </pre>
     *
     * <code>optional string text = 4;</code>
     * @return Whether the text field is set.
     */
    boolean hasText();
    /**
     * <pre>
     * Text argument.  This is used by CONVERT_REVERSE at this moment.
     * </pre>
     *
     * <code>optional string text = 4;</code>
     * @return The text.
     */
    java.lang.String getText();
    /**
     * <pre>
     * Text argument.  This is used by CONVERT_REVERSE at this moment.
     * </pre>
     *
     * <code>optional string text = 4;</code>
     * @return The bytes for text.
     */
    com.google.protobuf.ByteString
        getTextBytes();

    /**
     * <pre>
     * New cursor position in preedit. Used with MOVE_CURSOR.
     * </pre>
     *
     * <code>optional uint32 cursor_position = 5;</code>
     * @return Whether the cursorPosition field is set.
     */
    boolean hasCursorPosition();
    /**
     * <pre>
     * New cursor position in preedit. Used with MOVE_CURSOR.
     * </pre>
     *
     * <code>optional uint32 cursor_position = 5;</code>
     * @return The cursorPosition.
     */
    int getCursorPosition();

    /**
     * <pre>
     * Assumes that the entries are sorted by the probability.
     * The most probable event should be at the top.
     * </pre>
     *
     * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
     */
    java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent> 
        getCompositionEventsList();
    /**
     * <pre>
     * Assumes that the entries are sorted by the probability.
     * The most probable event should be at the top.
     * </pre>
     *
     * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent getCompositionEvents(int index);
    /**
     * <pre>
     * Assumes that the entries are sorted by the probability.
     * The most probable event should be at the top.
     * </pre>
     *
     * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
     */
    int getCompositionEventsCount();
  }
  /**
   * Protobuf type {@code mozc.commands.SessionCommand}
   */
  public  static final class SessionCommand extends
      com.google.protobuf.GeneratedMessageLite<
          SessionCommand, SessionCommand.Builder> implements
      // @@protoc_insertion_point(message_implements:mozc.commands.SessionCommand)
      SessionCommandOrBuilder {
    private SessionCommand() {
      text_ = "";
      compositionEvents_ = emptyProtobufList();
    }
    /**
     * Protobuf enum {@code mozc.commands.SessionCommand.CommandType}
     */
    public enum CommandType
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <pre>
       * Do nothing.
       * </pre>
       *
       * <code>NONE = 0;</code>
       */
      NONE(0),
      /**
       * <pre>
       * Revert the session, this is usually similar to type ESC several times.
       * </pre>
       *
       * <code>REVERT = 1;</code>
       */
      REVERT(1),
      /**
       * <pre>
       * Commit the session, this is usually similar to type Enter.
       * SUBMIT session command is accepted in any status.
       * Pre-condition:
       * - Any states of IME are acceptable.
       * Post-condition:
       * - Preedit text becomes empty.
       * </pre>
       *
       * <code>SUBMIT = 2;</code>
       */
      SUBMIT(2),
      /**
       * <pre>
       * Select the specified candidate word by id. This command is
       * usually used with mouse clicking.
       * </pre>
       *
       * <code>SELECT_CANDIDATE = 3;</code>
       */
      SELECT_CANDIDATE(3),
      /**
       * <pre>
       * Set the focus to the candidate by id. This is usually used
       * with mouse dragging or selection of word usage dictionary.
       * The difference from SELECT_CANDIDATE is that
       * HIGHLIGHT_CANDIDATE does not close the candidate window
       * while SELECT_CANDIDATE closes the candidate window.
       * </pre>
       *
       * <code>HIGHLIGHT_CANDIDATE = 4;</code>
       */
      HIGHLIGHT_CANDIDATE(4),
      /**
       * <pre>
       * Specify the composition mode.  This command should be used with
       * composition_mode.
       * </pre>
       *
       * <code>SWITCH_COMPOSITION_MODE = 5;</code>
       */
      SWITCH_COMPOSITION_MODE(5),
      /**
       * <pre>
       * Return the current status such as composition mode, preedit method, etc.
       * </pre>
       *
       * <code>GET_STATUS = 6;</code>
       */
      GET_STATUS(6),
      /**
       * <pre>
       * This command is typically used for mobile IME's partial conversion,
       * but currently it is on the way. This description is for current spec.
       * This command requires that candidates exist.
       * If there is a focused candidate (Conversion or Prediction state),
       * the candidate matched with the given id in the first segment is
       * submitted, even though the selected segment is not the first segment
       * (Important thing is whether focused candidate exists
       * or not. Focused index itself is ignored).
       * This behavior should be updated because current cursor position and
       * position of focused segment affects nothing.
       * We should fix this non-intuitive behavior. Intuitive behavior might be
       * submitting segments from first one to focused one (inclusive).
       * If no focused candidate (Suggestion, including ZeroQuery suggestion),
       * first (and only) segment's candidate of which id is equal to id field of
       * Input message is submitted.
       * This behavior should be fixed because current cursor position affects
       * nothing. In future, the characters after the cursor should be kept
       * as preedit.
       * This command's pre- and post- conditions are differenct from
       * SUBMIT command's. Following conditions will be kept after updating
       * the behavior.
       * Pre-condition:
       * - There should be candidate.
       * Post-condition:
       * - No guarantee on preedit text.
       * TODO(yamaguchi): Update corresponding implementation please.
       * </pre>
       *
       * <code>SUBMIT_CANDIDATE = 7;</code>
       */
      SUBMIT_CANDIDATE(7),
      /**
       * <pre>
       * Perform reverse conversion.
       * </pre>
       *
       * <code>CONVERT_REVERSE = 8;</code>
       */
      CONVERT_REVERSE(8),
      /**
       * <pre>
       * Perform Undo.
       * </pre>
       *
       * <code>UNDO = 9;</code>
       */
      UNDO(9),
      /**
       * <pre>
       * Reset convert history and revert current composition.
       * This is usually used by moving cursor with mouse clicking.
       * </pre>
       *
       * <code>RESET_CONTEXT = 10;</code>
       */
      RESET_CONTEXT(10),
      /**
       * <pre>
       * Change cursor position in preedit.
       * </pre>
       *
       * <code>MOVE_CURSOR = 11;</code>
       */
      MOVE_CURSOR(11),
      /**
       * <pre>
       * Specify the input field type.
       * </pre>
       *
       * <code>SWITCH_INPUT_FIELD_TYPE = 12;</code>
       */
      SWITCH_INPUT_FIELD_TYPE(12),
      /**
       * <pre>
       * This command is used in only Android.
       * Works UNDO or rewind HIRAGANA characters based on the state.
       * </pre>
       *
       * <code>UNDO_OR_REWIND = 14;</code>
       */
      UNDO_OR_REWIND(14),
      /**
       * <pre>
       * Commit the raw text of the composed string.
       * </pre>
       *
       * <code>COMMIT_RAW_TEXT = 19;</code>
       */
      COMMIT_RAW_TEXT(19),
      /**
       * <pre>
       * Call ConvertPrevPage session command to show the previous page of
       * candidates.
       * </pre>
       *
       * <code>CONVERT_PREV_PAGE = 20;</code>
       */
      CONVERT_PREV_PAGE(20),
      /**
       * <pre>
       * Call ConvertNextPage session command to show the next page of
       * candidates.
       * </pre>
       *
       * <code>CONVERT_NEXT_PAGE = 21;</code>
       */
      CONVERT_NEXT_PAGE(21),
      /**
       * <pre>
       * Make sure IME is turned on. Optionally you can also provide new input
       * mode in |composition_mode| (but you must not set DIRECT to it).
       * |composition_mode| is honored even when IME is already turned on.
       * </pre>
       *
       * <code>TURN_ON_IME = 22;</code>
       */
      TURN_ON_IME(22),
      /**
       * <pre>
       * Make sure IME is turned off. Optionally you can also provide new input
       * mode in |composition_mode| (but you must not set DIRECT to it). If IME
       * |composition_mode| is honored even when IME is already turned off.
       * </pre>
       *
       * <code>TURN_OFF_IME = 23;</code>
       */
      TURN_OFF_IME(23),
      /**
       * <pre>
       * Delete the candidate specified with |id = 2| from the user history.
       * </pre>
       *
       * <code>DELETE_CANDIDATE_FROM_HISTORY = 24;</code>
       */
      DELETE_CANDIDATE_FROM_HISTORY(24),
      /**
       * <pre>
       * Stops key toggling of the composer if its table is a toggle-supported
       * layout (e.g., 12-key toggle flick.)
       * </pre>
       *
       * <code>STOP_KEY_TOGGLING = 25;</code>
       */
      STOP_KEY_TOGGLING(25),
      /**
       * <pre>
       * Update composition with |compoisition_events|.
       * Unlike SEND_KEY command, this command completely replaces the composition
       * rather than appending to the existing composition.
       * The command will be used for supporting handwriting.
       * </pre>
       *
       * <code>UPDATE_COMPOSITION = 26;</code>
       */
      UPDATE_COMPOSITION(26),
      /**
       * <pre>
       * Explicitly request Next Word Prediction (NWP, zero query suggestion) from
       * the surrounding text.
       * Note: This command resets the internal states (history segments) of the
       * converter.
       * </pre>
       *
       * <code>REQUEST_NWP = 27;</code>
       */
      REQUEST_NWP(27),
      ;

      /**
       * <pre>
       * Do nothing.
       * </pre>
       *
       * <code>NONE = 0;</code>
       */
      public static final int NONE_VALUE = 0;
      /**
       * <pre>
       * Revert the session, this is usually similar to type ESC several times.
       * </pre>
       *
       * <code>REVERT = 1;</code>
       */
      public static final int REVERT_VALUE = 1;
      /**
       * <pre>
       * Commit the session, this is usually similar to type Enter.
       * SUBMIT session command is accepted in any status.
       * Pre-condition:
       * - Any states of IME are acceptable.
       * Post-condition:
       * - Preedit text becomes empty.
       * </pre>
       *
       * <code>SUBMIT = 2;</code>
       */
      public static final int SUBMIT_VALUE = 2;
      /**
       * <pre>
       * Select the specified candidate word by id. This command is
       * usually used with mouse clicking.
       * </pre>
       *
       * <code>SELECT_CANDIDATE = 3;</code>
       */
      public static final int SELECT_CANDIDATE_VALUE = 3;
      /**
       * <pre>
       * Set the focus to the candidate by id. This is usually used
       * with mouse dragging or selection of word usage dictionary.
       * The difference from SELECT_CANDIDATE is that
       * HIGHLIGHT_CANDIDATE does not close the candidate window
       * while SELECT_CANDIDATE closes the candidate window.
       * </pre>
       *
       * <code>HIGHLIGHT_CANDIDATE = 4;</code>
       */
      public static final int HIGHLIGHT_CANDIDATE_VALUE = 4;
      /**
       * <pre>
       * Specify the composition mode.  This command should be used with
       * composition_mode.
       * </pre>
       *
       * <code>SWITCH_COMPOSITION_MODE = 5;</code>
       */
      public static final int SWITCH_COMPOSITION_MODE_VALUE = 5;
      /**
       * <pre>
       * Return the current status such as composition mode, preedit method, etc.
       * </pre>
       *
       * <code>GET_STATUS = 6;</code>
       */
      public static final int GET_STATUS_VALUE = 6;
      /**
       * <pre>
       * This command is typically used for mobile IME's partial conversion,
       * but currently it is on the way. This description is for current spec.
       * This command requires that candidates exist.
       * If there is a focused candidate (Conversion or Prediction state),
       * the candidate matched with the given id in the first segment is
       * submitted, even though the selected segment is not the first segment
       * (Important thing is whether focused candidate exists
       * or not. Focused index itself is ignored).
       * This behavior should be updated because current cursor position and
       * position of focused segment affects nothing.
       * We should fix this non-intuitive behavior. Intuitive behavior might be
       * submitting segments from first one to focused one (inclusive).
       * If no focused candidate (Suggestion, including ZeroQuery suggestion),
       * first (and only) segment's candidate of which id is equal to id field of
       * Input message is submitted.
       * This behavior should be fixed because current cursor position affects
       * nothing. In future, the characters after the cursor should be kept
       * as preedit.
       * This command's pre- and post- conditions are differenct from
       * SUBMIT command's. Following conditions will be kept after updating
       * the behavior.
       * Pre-condition:
       * - There should be candidate.
       * Post-condition:
       * - No guarantee on preedit text.
       * TODO(yamaguchi): Update corresponding implementation please.
       * </pre>
       *
       * <code>SUBMIT_CANDIDATE = 7;</code>
       */
      public static final int SUBMIT_CANDIDATE_VALUE = 7;
      /**
       * <pre>
       * Perform reverse conversion.
       * </pre>
       *
       * <code>CONVERT_REVERSE = 8;</code>
       */
      public static final int CONVERT_REVERSE_VALUE = 8;
      /**
       * <pre>
       * Perform Undo.
       * </pre>
       *
       * <code>UNDO = 9;</code>
       */
      public static final int UNDO_VALUE = 9;
      /**
       * <pre>
       * Reset convert history and revert current composition.
       * This is usually used by moving cursor with mouse clicking.
       * </pre>
       *
       * <code>RESET_CONTEXT = 10;</code>
       */
      public static final int RESET_CONTEXT_VALUE = 10;
      /**
       * <pre>
       * Change cursor position in preedit.
       * </pre>
       *
       * <code>MOVE_CURSOR = 11;</code>
       */
      public static final int MOVE_CURSOR_VALUE = 11;
      /**
       * <pre>
       * Specify the input field type.
       * </pre>
       *
       * <code>SWITCH_INPUT_FIELD_TYPE = 12;</code>
       */
      public static final int SWITCH_INPUT_FIELD_TYPE_VALUE = 12;
      /**
       * <pre>
       * This command is used in only Android.
       * Works UNDO or rewind HIRAGANA characters based on the state.
       * </pre>
       *
       * <code>UNDO_OR_REWIND = 14;</code>
       */
      public static final int UNDO_OR_REWIND_VALUE = 14;
      /**
       * <pre>
       * Commit the raw text of the composed string.
       * </pre>
       *
       * <code>COMMIT_RAW_TEXT = 19;</code>
       */
      public static final int COMMIT_RAW_TEXT_VALUE = 19;
      /**
       * <pre>
       * Call ConvertPrevPage session command to show the previous page of
       * candidates.
       * </pre>
       *
       * <code>CONVERT_PREV_PAGE = 20;</code>
       */
      public static final int CONVERT_PREV_PAGE_VALUE = 20;
      /**
       * <pre>
       * Call ConvertNextPage session command to show the next page of
       * candidates.
       * </pre>
       *
       * <code>CONVERT_NEXT_PAGE = 21;</code>
       */
      public static final int CONVERT_NEXT_PAGE_VALUE = 21;
      /**
       * <pre>
       * Make sure IME is turned on. Optionally you can also provide new input
       * mode in |composition_mode| (but you must not set DIRECT to it).
       * |composition_mode| is honored even when IME is already turned on.
       * </pre>
       *
       * <code>TURN_ON_IME = 22;</code>
       */
      public static final int TURN_ON_IME_VALUE = 22;
      /**
       * <pre>
       * Make sure IME is turned off. Optionally you can also provide new input
       * mode in |composition_mode| (but you must not set DIRECT to it). If IME
       * |composition_mode| is honored even when IME is already turned off.
       * </pre>
       *
       * <code>TURN_OFF_IME = 23;</code>
       */
      public static final int TURN_OFF_IME_VALUE = 23;
      /**
       * <pre>
       * Delete the candidate specified with |id = 2| from the user history.
       * </pre>
       *
       * <code>DELETE_CANDIDATE_FROM_HISTORY = 24;</code>
       */
      public static final int DELETE_CANDIDATE_FROM_HISTORY_VALUE = 24;
      /**
       * <pre>
       * Stops key toggling of the composer if its table is a toggle-supported
       * layout (e.g., 12-key toggle flick.)
       * </pre>
       *
       * <code>STOP_KEY_TOGGLING = 25;</code>
       */
      public static final int STOP_KEY_TOGGLING_VALUE = 25;
      /**
       * <pre>
       * Update composition with |compoisition_events|.
       * Unlike SEND_KEY command, this command completely replaces the composition
       * rather than appending to the existing composition.
       * The command will be used for supporting handwriting.
       * </pre>
       *
       * <code>UPDATE_COMPOSITION = 26;</code>
       */
      public static final int UPDATE_COMPOSITION_VALUE = 26;
      /**
       * <pre>
       * Explicitly request Next Word Prediction (NWP, zero query suggestion) from
       * the surrounding text.
       * Note: This command resets the internal states (history segments) of the
       * converter.
       * </pre>
       *
       * <code>REQUEST_NWP = 27;</code>
       */
      public static final int REQUEST_NWP_VALUE = 27;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static CommandType valueOf(int value) {
        return forNumber(value);
      }

      public static CommandType forNumber(int value) {
        switch (value) {
          case 0: return NONE;
          case 1: return REVERT;
          case 2: return SUBMIT;
          case 3: return SELECT_CANDIDATE;
          case 4: return HIGHLIGHT_CANDIDATE;
          case 5: return SWITCH_COMPOSITION_MODE;
          case 6: return GET_STATUS;
          case 7: return SUBMIT_CANDIDATE;
          case 8: return CONVERT_REVERSE;
          case 9: return UNDO;
          case 10: return RESET_CONTEXT;
          case 11: return MOVE_CURSOR;
          case 12: return SWITCH_INPUT_FIELD_TYPE;
          case 14: return UNDO_OR_REWIND;
          case 19: return COMMIT_RAW_TEXT;
          case 20: return CONVERT_PREV_PAGE;
          case 21: return CONVERT_NEXT_PAGE;
          case 22: return TURN_ON_IME;
          case 23: return TURN_OFF_IME;
          case 24: return DELETE_CANDIDATE_FROM_HISTORY;
          case 25: return STOP_KEY_TOGGLING;
          case 26: return UPDATE_COMPOSITION;
          case 27: return REQUEST_NWP;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<CommandType>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          CommandType> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<CommandType>() {
              @java.lang.Override
              public CommandType findValueByNumber(int number) {
                return CommandType.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return CommandTypeVerifier.INSTANCE;
      }

      private static final class CommandTypeVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new CommandTypeVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return CommandType.forNumber(number) != null;
              }
            };

      private final int value;

      private CommandType(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.commands.SessionCommand.CommandType)
    }

    public interface CompositionEventOrBuilder extends
        // @@protoc_insertion_point(interface_extends:mozc.commands.SessionCommand.CompositionEvent)
        com.google.protobuf.MessageLiteOrBuilder {

      /**
       * <code>optional string composition_string = 1;</code>
       * @return Whether the compositionString field is set.
       */
      boolean hasCompositionString();
      /**
       * <code>optional string composition_string = 1;</code>
       * @return The compositionString.
       */
      java.lang.String getCompositionString();
      /**
       * <code>optional string composition_string = 1;</code>
       * @return The bytes for compositionString.
       */
      com.google.protobuf.ByteString
          getCompositionStringBytes();

      /**
       * <pre>
       * Sum of probabilities must be lesser or equal than 1.
       * 0&lt;= probability &lt;= 1
       * </pre>
       *
       * <code>optional double probability = 2;</code>
       * @return Whether the probability field is set.
       */
      boolean hasProbability();
      /**
       * <pre>
       * Sum of probabilities must be lesser or equal than 1.
       * 0&lt;= probability &lt;= 1
       * </pre>
       *
       * <code>optional double probability = 2;</code>
       * @return The probability.
       */
      double getProbability();
    }
    /**
     * <pre>
     * Used by UPDATE_COMPOSITION event
     * </pre>
     *
     * Protobuf type {@code mozc.commands.SessionCommand.CompositionEvent}
     */
    public  static final class CompositionEvent extends
        com.google.protobuf.GeneratedMessageLite<
            CompositionEvent, CompositionEvent.Builder> implements
        // @@protoc_insertion_point(message_implements:mozc.commands.SessionCommand.CompositionEvent)
        CompositionEventOrBuilder {
      private CompositionEvent() {
        compositionString_ = "";
      }
      private int bitField0_;
      public static final int COMPOSITION_STRING_FIELD_NUMBER = 1;
      private java.lang.String compositionString_;
      /**
       * <code>optional string composition_string = 1;</code>
       * @return Whether the compositionString field is set.
       */
      @java.lang.Override
      public boolean hasCompositionString() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional string composition_string = 1;</code>
       * @return The compositionString.
       */
      @java.lang.Override
      public java.lang.String getCompositionString() {
        return compositionString_;
      }
      /**
       * <code>optional string composition_string = 1;</code>
       * @return The bytes for compositionString.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getCompositionStringBytes() {
        return com.google.protobuf.ByteString.copyFromUtf8(compositionString_);
      }
      /**
       * <code>optional string composition_string = 1;</code>
       * @param value The compositionString to set.
       */
      private void setCompositionString(
          java.lang.String value) {
        java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000001;
        compositionString_ = value;
      }
      /**
       * <code>optional string composition_string = 1;</code>
       */
      private void clearCompositionString() {
        bitField0_ = (bitField0_ & ~0x00000001);
        compositionString_ = getDefaultInstance().getCompositionString();
      }
      /**
       * <code>optional string composition_string = 1;</code>
       * @param value The bytes for compositionString to set.
       */
      private void setCompositionStringBytes(
          com.google.protobuf.ByteString value) {
        compositionString_ = value.toStringUtf8();
        bitField0_ |= 0x00000001;
      }

      public static final int PROBABILITY_FIELD_NUMBER = 2;
      private double probability_;
      /**
       * <pre>
       * Sum of probabilities must be lesser or equal than 1.
       * 0&lt;= probability &lt;= 1
       * </pre>
       *
       * <code>optional double probability = 2;</code>
       * @return Whether the probability field is set.
       */
      @java.lang.Override
      public boolean hasProbability() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Sum of probabilities must be lesser or equal than 1.
       * 0&lt;= probability &lt;= 1
       * </pre>
       *
       * <code>optional double probability = 2;</code>
       * @return The probability.
       */
      @java.lang.Override
      public double getProbability() {
        return probability_;
      }
      /**
       * <pre>
       * Sum of probabilities must be lesser or equal than 1.
       * 0&lt;= probability &lt;= 1
       * </pre>
       *
       * <code>optional double probability = 2;</code>
       * @param value The probability to set.
       */
      private void setProbability(double value) {
        bitField0_ |= 0x00000002;
        probability_ = value;
      }
      /**
       * <pre>
       * Sum of probabilities must be lesser or equal than 1.
       * 0&lt;= probability &lt;= 1
       * </pre>
       *
       * <code>optional double probability = 2;</code>
       */
      private void clearProbability() {
        bitField0_ = (bitField0_ & ~0x00000002);
        probability_ = 0D;
      }

      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }

      public static Builder newBuilder() {
        return (Builder) DEFAULT_INSTANCE.createBuilder();
      }
      public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent prototype) {
        return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
      }

      /**
       * <pre>
       * Used by UPDATE_COMPOSITION event
       * </pre>
       *
       * Protobuf type {@code mozc.commands.SessionCommand.CompositionEvent}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageLite.Builder<
            org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent, Builder> implements
          // @@protoc_insertion_point(builder_implements:mozc.commands.SessionCommand.CompositionEvent)
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEventOrBuilder {
        // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent.newBuilder()
        private Builder() {
          super(DEFAULT_INSTANCE);
        }


        /**
         * <code>optional string composition_string = 1;</code>
         * @return Whether the compositionString field is set.
         */
        @java.lang.Override
        public boolean hasCompositionString() {
          return instance.hasCompositionString();
        }
        /**
         * <code>optional string composition_string = 1;</code>
         * @return The compositionString.
         */
        @java.lang.Override
        public java.lang.String getCompositionString() {
          return instance.getCompositionString();
        }
        /**
         * <code>optional string composition_string = 1;</code>
         * @return The bytes for compositionString.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
            getCompositionStringBytes() {
          return instance.getCompositionStringBytes();
        }
        /**
         * <code>optional string composition_string = 1;</code>
         * @param value The compositionString to set.
         * @return This builder for chaining.
         */
        public Builder setCompositionString(
            java.lang.String value) {
          copyOnWrite();
          instance.setCompositionString(value);
          return this;
        }
        /**
         * <code>optional string composition_string = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearCompositionString() {
          copyOnWrite();
          instance.clearCompositionString();
          return this;
        }
        /**
         * <code>optional string composition_string = 1;</code>
         * @param value The bytes for compositionString to set.
         * @return This builder for chaining.
         */
        public Builder setCompositionStringBytes(
            com.google.protobuf.ByteString value) {
          copyOnWrite();
          instance.setCompositionStringBytes(value);
          return this;
        }

        /**
         * <pre>
         * Sum of probabilities must be lesser or equal than 1.
         * 0&lt;= probability &lt;= 1
         * </pre>
         *
         * <code>optional double probability = 2;</code>
         * @return Whether the probability field is set.
         */
        @java.lang.Override
        public boolean hasProbability() {
          return instance.hasProbability();
        }
        /**
         * <pre>
         * Sum of probabilities must be lesser or equal than 1.
         * 0&lt;= probability &lt;= 1
         * </pre>
         *
         * <code>optional double probability = 2;</code>
         * @return The probability.
         */
        @java.lang.Override
        public double getProbability() {
          return instance.getProbability();
        }
        /**
         * <pre>
         * Sum of probabilities must be lesser or equal than 1.
         * 0&lt;= probability &lt;= 1
         * </pre>
         *
         * <code>optional double probability = 2;</code>
         * @param value The probability to set.
         * @return This builder for chaining.
         */
        public Builder setProbability(double value) {
          copyOnWrite();
          instance.setProbability(value);
          return this;
        }
        /**
         * <pre>
         * Sum of probabilities must be lesser or equal than 1.
         * 0&lt;= probability &lt;= 1
         * </pre>
         *
         * <code>optional double probability = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearProbability() {
          copyOnWrite();
          instance.clearProbability();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:mozc.commands.SessionCommand.CompositionEvent)
      }
      @java.lang.Override
      @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
      protected final java.lang.Object dynamicMethod(
          com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
          java.lang.Object arg0, java.lang.Object arg1) {
        switch (method) {
          case NEW_MUTABLE_INSTANCE: {
            return new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent();
          }
          case NEW_BUILDER: {
            return new Builder();
          }
          case BUILD_MESSAGE_INFO: {
              java.lang.Object[] objects = new java.lang.Object[] {
                "bitField0_",
                "compositionString_",
                "probability_",
              };
              java.lang.String info =
                  "\u0001\u0002\u0000\u0001\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u1008\u0000\u0002" +
                  "\u1000\u0001";
              return newMessageInfo(DEFAULT_INSTANCE, info, objects);
          }
          // fall through
          case GET_DEFAULT_INSTANCE: {
            return DEFAULT_INSTANCE;
          }
          case GET_PARSER: {
            com.google.protobuf.Parser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent> parser = PARSER;
            if (parser == null) {
              synchronized (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent.class) {
                parser = PARSER;
                if (parser == null) {
                  parser =
                      new DefaultInstanceBasedParser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent>(
                          DEFAULT_INSTANCE);
                  PARSER = parser;
                }
              }
            }
            return parser;
        }
        case GET_MEMOIZED_IS_INITIALIZED: {
          return (byte) 1;
        }
        case SET_MEMOIZED_IS_INITIALIZED: {
          return null;
        }
        }
        throw new UnsupportedOperationException();
      }


      // @@protoc_insertion_point(class_scope:mozc.commands.SessionCommand.CompositionEvent)
      private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent DEFAULT_INSTANCE;
      static {
        CompositionEvent defaultInstance = new CompositionEvent();
        // New instances are implicitly immutable so no need to make
        // immutable.
        DEFAULT_INSTANCE = defaultInstance;
        com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
          CompositionEvent.class, defaultInstance);
      }

      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static volatile com.google.protobuf.Parser<CompositionEvent> PARSER;

      public static com.google.protobuf.Parser<CompositionEvent> parser() {
        return DEFAULT_INSTANCE.getParserForType();
      }
    }

    private int bitField0_;
    public static final int TYPE_FIELD_NUMBER = 1;
    private int type_;
    /**
     * <code>required .mozc.commands.SessionCommand.CommandType type = 1;</code>
     * @return Whether the type field is set.
     */
    @java.lang.Override
    public boolean hasType() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>required .mozc.commands.SessionCommand.CommandType type = 1;</code>
     * @return The type.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CommandType getType() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CommandType result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CommandType.forNumber(type_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CommandType.NONE : result;
    }
    /**
     * <code>required .mozc.commands.SessionCommand.CommandType type = 1;</code>
     * @param value The type to set.
     */
    private void setType(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CommandType value) {
      type_ = value.getNumber();
      bitField0_ |= 0x00000001;
    }
    /**
     * <code>required .mozc.commands.SessionCommand.CommandType type = 1;</code>
     */
    private void clearType() {
      bitField0_ = (bitField0_ & ~0x00000001);
      type_ = 0;
    }

    public static final int ID_FIELD_NUMBER = 2;
    private int id_;
    /**
     * <pre>
     * Unique number specifying a candidate word.
     * Note: This value is NOT an index of the candidate window or the candidate
     * list. This value is a return value of CandidateWord::id().
     * </pre>
     *
     * <code>optional int32 id = 2;</code>
     * @return Whether the id field is set.
     */
    @java.lang.Override
    public boolean hasId() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Unique number specifying a candidate word.
     * Note: This value is NOT an index of the candidate window or the candidate
     * list. This value is a return value of CandidateWord::id().
     * </pre>
     *
     * <code>optional int32 id = 2;</code>
     * @return The id.
     */
    @java.lang.Override
    public int getId() {
      return id_;
    }
    /**
     * <pre>
     * Unique number specifying a candidate word.
     * Note: This value is NOT an index of the candidate window or the candidate
     * list. This value is a return value of CandidateWord::id().
     * </pre>
     *
     * <code>optional int32 id = 2;</code>
     * @param value The id to set.
     */
    private void setId(int value) {
      bitField0_ |= 0x00000002;
      id_ = value;
    }
    /**
     * <pre>
     * Unique number specifying a candidate word.
     * Note: This value is NOT an index of the candidate window or the candidate
     * list. This value is a return value of CandidateWord::id().
     * </pre>
     *
     * <code>optional int32 id = 2;</code>
     */
    private void clearId() {
      bitField0_ = (bitField0_ & ~0x00000002);
      id_ = 0;
    }

    public static final int COMPOSITION_MODE_FIELD_NUMBER = 3;
    private int compositionMode_;
    /**
     * <pre>
     * This is used with SWITCH_COMPOSITION_MODE, TURN_ON_IME and TURN_OFF_IME.
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode composition_mode = 3;</code>
     * @return Whether the compositionMode field is set.
     */
    @java.lang.Override
    public boolean hasCompositionMode() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * This is used with SWITCH_COMPOSITION_MODE, TURN_ON_IME and TURN_OFF_IME.
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode composition_mode = 3;</code>
     * @return The compositionMode.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode getCompositionMode() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode.forNumber(compositionMode_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode.DIRECT : result;
    }
    /**
     * <pre>
     * This is used with SWITCH_COMPOSITION_MODE, TURN_ON_IME and TURN_OFF_IME.
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode composition_mode = 3;</code>
     * @param value The compositionMode to set.
     */
    private void setCompositionMode(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode value) {
      compositionMode_ = value.getNumber();
      bitField0_ |= 0x00000004;
    }
    /**
     * <pre>
     * This is used with SWITCH_COMPOSITION_MODE, TURN_ON_IME and TURN_OFF_IME.
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode composition_mode = 3;</code>
     */
    private void clearCompositionMode() {
      bitField0_ = (bitField0_ & ~0x00000004);
      compositionMode_ = 0;
    }

    public static final int TEXT_FIELD_NUMBER = 4;
    private java.lang.String text_;
    /**
     * <pre>
     * Text argument.  This is used by CONVERT_REVERSE at this moment.
     * </pre>
     *
     * <code>optional string text = 4;</code>
     * @return Whether the text field is set.
     */
    @java.lang.Override
    public boolean hasText() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Text argument.  This is used by CONVERT_REVERSE at this moment.
     * </pre>
     *
     * <code>optional string text = 4;</code>
     * @return The text.
     */
    @java.lang.Override
    public java.lang.String getText() {
      return text_;
    }
    /**
     * <pre>
     * Text argument.  This is used by CONVERT_REVERSE at this moment.
     * </pre>
     *
     * <code>optional string text = 4;</code>
     * @return The bytes for text.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getTextBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(text_);
    }
    /**
     * <pre>
     * Text argument.  This is used by CONVERT_REVERSE at this moment.
     * </pre>
     *
     * <code>optional string text = 4;</code>
     * @param value The text to set.
     */
    private void setText(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000008;
      text_ = value;
    }
    /**
     * <pre>
     * Text argument.  This is used by CONVERT_REVERSE at this moment.
     * </pre>
     *
     * <code>optional string text = 4;</code>
     */
    private void clearText() {
      bitField0_ = (bitField0_ & ~0x00000008);
      text_ = getDefaultInstance().getText();
    }
    /**
     * <pre>
     * Text argument.  This is used by CONVERT_REVERSE at this moment.
     * </pre>
     *
     * <code>optional string text = 4;</code>
     * @param value The bytes for text to set.
     */
    private void setTextBytes(
        com.google.protobuf.ByteString value) {
      text_ = value.toStringUtf8();
      bitField0_ |= 0x00000008;
    }

    public static final int CURSOR_POSITION_FIELD_NUMBER = 5;
    private int cursorPosition_;
    /**
     * <pre>
     * New cursor position in preedit. Used with MOVE_CURSOR.
     * </pre>
     *
     * <code>optional uint32 cursor_position = 5;</code>
     * @return Whether the cursorPosition field is set.
     */
    @java.lang.Override
    public boolean hasCursorPosition() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * New cursor position in preedit. Used with MOVE_CURSOR.
     * </pre>
     *
     * <code>optional uint32 cursor_position = 5;</code>
     * @return The cursorPosition.
     */
    @java.lang.Override
    public int getCursorPosition() {
      return cursorPosition_;
    }
    /**
     * <pre>
     * New cursor position in preedit. Used with MOVE_CURSOR.
     * </pre>
     *
     * <code>optional uint32 cursor_position = 5;</code>
     * @param value The cursorPosition to set.
     */
    private void setCursorPosition(int value) {
      bitField0_ |= 0x00000010;
      cursorPosition_ = value;
    }
    /**
     * <pre>
     * New cursor position in preedit. Used with MOVE_CURSOR.
     * </pre>
     *
     * <code>optional uint32 cursor_position = 5;</code>
     */
    private void clearCursorPosition() {
      bitField0_ = (bitField0_ & ~0x00000010);
      cursorPosition_ = 0;
    }

    public static final int COMPOSITION_EVENTS_FIELD_NUMBER = 11;
    private com.google.protobuf.Internal.ProtobufList<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent> compositionEvents_;
    /**
     * <pre>
     * Assumes that the entries are sorted by the probability.
     * The most probable event should be at the top.
     * </pre>
     *
     * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
     */
    @java.lang.Override
    public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent> getCompositionEventsList() {
      return compositionEvents_;
    }
    /**
     * <pre>
     * Assumes that the entries are sorted by the probability.
     * The most probable event should be at the top.
     * </pre>
     *
     * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
     */
    public java.util.List<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEventOrBuilder> 
        getCompositionEventsOrBuilderList() {
      return compositionEvents_;
    }
    /**
     * <pre>
     * Assumes that the entries are sorted by the probability.
     * The most probable event should be at the top.
     * </pre>
     *
     * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
     */
    @java.lang.Override
    public int getCompositionEventsCount() {
      return compositionEvents_.size();
    }
    /**
     * <pre>
     * Assumes that the entries are sorted by the probability.
     * The most probable event should be at the top.
     * </pre>
     *
     * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent getCompositionEvents(int index) {
      return compositionEvents_.get(index);
    }
    /**
     * <pre>
     * Assumes that the entries are sorted by the probability.
     * The most probable event should be at the top.
     * </pre>
     *
     * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
     */
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEventOrBuilder getCompositionEventsOrBuilder(
        int index) {
      return compositionEvents_.get(index);
    }
    private void ensureCompositionEventsIsMutable() {
      com.google.protobuf.Internal.ProtobufList<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent> tmp = compositionEvents_;
      if (!tmp.isModifiable()) {
        compositionEvents_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * Assumes that the entries are sorted by the probability.
     * The most probable event should be at the top.
     * </pre>
     *
     * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
     */
    private void setCompositionEvents(
        int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent value) {
      value.getClass();
  ensureCompositionEventsIsMutable();
      compositionEvents_.set(index, value);
    }
    /**
     * <pre>
     * Assumes that the entries are sorted by the probability.
     * The most probable event should be at the top.
     * </pre>
     *
     * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
     */
    private void addCompositionEvents(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent value) {
      value.getClass();
  ensureCompositionEventsIsMutable();
      compositionEvents_.add(value);
    }
    /**
     * <pre>
     * Assumes that the entries are sorted by the probability.
     * The most probable event should be at the top.
     * </pre>
     *
     * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
     */
    private void addCompositionEvents(
        int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent value) {
      value.getClass();
  ensureCompositionEventsIsMutable();
      compositionEvents_.add(index, value);
    }
    /**
     * <pre>
     * Assumes that the entries are sorted by the probability.
     * The most probable event should be at the top.
     * </pre>
     *
     * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
     */
    private void addAllCompositionEvents(
        java.lang.Iterable<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent> values) {
      ensureCompositionEventsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, compositionEvents_);
    }
    /**
     * <pre>
     * Assumes that the entries are sorted by the probability.
     * The most probable event should be at the top.
     * </pre>
     *
     * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
     */
    private void clearCompositionEvents() {
      compositionEvents_ = emptyProtobufList();
    }
    /**
     * <pre>
     * Assumes that the entries are sorted by the probability.
     * The most probable event should be at the top.
     * </pre>
     *
     * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
     */
    private void removeCompositionEvents(int index) {
      ensureCompositionEventsIsMutable();
      compositionEvents_.remove(index);
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code mozc.commands.SessionCommand}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand, Builder> implements
        // @@protoc_insertion_point(builder_implements:mozc.commands.SessionCommand)
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommandOrBuilder {
      // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>required .mozc.commands.SessionCommand.CommandType type = 1;</code>
       * @return Whether the type field is set.
       */
      @java.lang.Override
      public boolean hasType() {
        return instance.hasType();
      }
      /**
       * <code>required .mozc.commands.SessionCommand.CommandType type = 1;</code>
       * @return The type.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CommandType getType() {
        return instance.getType();
      }
      /**
       * <code>required .mozc.commands.SessionCommand.CommandType type = 1;</code>
       * @param value The enum numeric value on the wire for type to set.
       * @return This builder for chaining.
       */
      public Builder setType(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CommandType value) {
        copyOnWrite();
        instance.setType(value);
        return this;
      }
      /**
       * <code>required .mozc.commands.SessionCommand.CommandType type = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearType() {
        copyOnWrite();
        instance.clearType();
        return this;
      }

      /**
       * <pre>
       * Unique number specifying a candidate word.
       * Note: This value is NOT an index of the candidate window or the candidate
       * list. This value is a return value of CandidateWord::id().
       * </pre>
       *
       * <code>optional int32 id = 2;</code>
       * @return Whether the id field is set.
       */
      @java.lang.Override
      public boolean hasId() {
        return instance.hasId();
      }
      /**
       * <pre>
       * Unique number specifying a candidate word.
       * Note: This value is NOT an index of the candidate window or the candidate
       * list. This value is a return value of CandidateWord::id().
       * </pre>
       *
       * <code>optional int32 id = 2;</code>
       * @return The id.
       */
      @java.lang.Override
      public int getId() {
        return instance.getId();
      }
      /**
       * <pre>
       * Unique number specifying a candidate word.
       * Note: This value is NOT an index of the candidate window or the candidate
       * list. This value is a return value of CandidateWord::id().
       * </pre>
       *
       * <code>optional int32 id = 2;</code>
       * @param value The id to set.
       * @return This builder for chaining.
       */
      public Builder setId(int value) {
        copyOnWrite();
        instance.setId(value);
        return this;
      }
      /**
       * <pre>
       * Unique number specifying a candidate word.
       * Note: This value is NOT an index of the candidate window or the candidate
       * list. This value is a return value of CandidateWord::id().
       * </pre>
       *
       * <code>optional int32 id = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearId() {
        copyOnWrite();
        instance.clearId();
        return this;
      }

      /**
       * <pre>
       * This is used with SWITCH_COMPOSITION_MODE, TURN_ON_IME and TURN_OFF_IME.
       * </pre>
       *
       * <code>optional .mozc.commands.CompositionMode composition_mode = 3;</code>
       * @return Whether the compositionMode field is set.
       */
      @java.lang.Override
      public boolean hasCompositionMode() {
        return instance.hasCompositionMode();
      }
      /**
       * <pre>
       * This is used with SWITCH_COMPOSITION_MODE, TURN_ON_IME and TURN_OFF_IME.
       * </pre>
       *
       * <code>optional .mozc.commands.CompositionMode composition_mode = 3;</code>
       * @return The compositionMode.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode getCompositionMode() {
        return instance.getCompositionMode();
      }
      /**
       * <pre>
       * This is used with SWITCH_COMPOSITION_MODE, TURN_ON_IME and TURN_OFF_IME.
       * </pre>
       *
       * <code>optional .mozc.commands.CompositionMode composition_mode = 3;</code>
       * @param value The enum numeric value on the wire for compositionMode to set.
       * @return This builder for chaining.
       */
      public Builder setCompositionMode(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode value) {
        copyOnWrite();
        instance.setCompositionMode(value);
        return this;
      }
      /**
       * <pre>
       * This is used with SWITCH_COMPOSITION_MODE, TURN_ON_IME and TURN_OFF_IME.
       * </pre>
       *
       * <code>optional .mozc.commands.CompositionMode composition_mode = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearCompositionMode() {
        copyOnWrite();
        instance.clearCompositionMode();
        return this;
      }

      /**
       * <pre>
       * Text argument.  This is used by CONVERT_REVERSE at this moment.
       * </pre>
       *
       * <code>optional string text = 4;</code>
       * @return Whether the text field is set.
       */
      @java.lang.Override
      public boolean hasText() {
        return instance.hasText();
      }
      /**
       * <pre>
       * Text argument.  This is used by CONVERT_REVERSE at this moment.
       * </pre>
       *
       * <code>optional string text = 4;</code>
       * @return The text.
       */
      @java.lang.Override
      public java.lang.String getText() {
        return instance.getText();
      }
      /**
       * <pre>
       * Text argument.  This is used by CONVERT_REVERSE at this moment.
       * </pre>
       *
       * <code>optional string text = 4;</code>
       * @return The bytes for text.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getTextBytes() {
        return instance.getTextBytes();
      }
      /**
       * <pre>
       * Text argument.  This is used by CONVERT_REVERSE at this moment.
       * </pre>
       *
       * <code>optional string text = 4;</code>
       * @param value The text to set.
       * @return This builder for chaining.
       */
      public Builder setText(
          java.lang.String value) {
        copyOnWrite();
        instance.setText(value);
        return this;
      }
      /**
       * <pre>
       * Text argument.  This is used by CONVERT_REVERSE at this moment.
       * </pre>
       *
       * <code>optional string text = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearText() {
        copyOnWrite();
        instance.clearText();
        return this;
      }
      /**
       * <pre>
       * Text argument.  This is used by CONVERT_REVERSE at this moment.
       * </pre>
       *
       * <code>optional string text = 4;</code>
       * @param value The bytes for text to set.
       * @return This builder for chaining.
       */
      public Builder setTextBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setTextBytes(value);
        return this;
      }

      /**
       * <pre>
       * New cursor position in preedit. Used with MOVE_CURSOR.
       * </pre>
       *
       * <code>optional uint32 cursor_position = 5;</code>
       * @return Whether the cursorPosition field is set.
       */
      @java.lang.Override
      public boolean hasCursorPosition() {
        return instance.hasCursorPosition();
      }
      /**
       * <pre>
       * New cursor position in preedit. Used with MOVE_CURSOR.
       * </pre>
       *
       * <code>optional uint32 cursor_position = 5;</code>
       * @return The cursorPosition.
       */
      @java.lang.Override
      public int getCursorPosition() {
        return instance.getCursorPosition();
      }
      /**
       * <pre>
       * New cursor position in preedit. Used with MOVE_CURSOR.
       * </pre>
       *
       * <code>optional uint32 cursor_position = 5;</code>
       * @param value The cursorPosition to set.
       * @return This builder for chaining.
       */
      public Builder setCursorPosition(int value) {
        copyOnWrite();
        instance.setCursorPosition(value);
        return this;
      }
      /**
       * <pre>
       * New cursor position in preedit. Used with MOVE_CURSOR.
       * </pre>
       *
       * <code>optional uint32 cursor_position = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearCursorPosition() {
        copyOnWrite();
        instance.clearCursorPosition();
        return this;
      }

      /**
       * <pre>
       * Assumes that the entries are sorted by the probability.
       * The most probable event should be at the top.
       * </pre>
       *
       * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
       */
      @java.lang.Override
      public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent> getCompositionEventsList() {
        return java.util.Collections.unmodifiableList(
            instance.getCompositionEventsList());
      }
      /**
       * <pre>
       * Assumes that the entries are sorted by the probability.
       * The most probable event should be at the top.
       * </pre>
       *
       * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
       */
      @java.lang.Override
      public int getCompositionEventsCount() {
        return instance.getCompositionEventsCount();
      }/**
       * <pre>
       * Assumes that the entries are sorted by the probability.
       * The most probable event should be at the top.
       * </pre>
       *
       * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent getCompositionEvents(int index) {
        return instance.getCompositionEvents(index);
      }
      /**
       * <pre>
       * Assumes that the entries are sorted by the probability.
       * The most probable event should be at the top.
       * </pre>
       *
       * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
       */
      public Builder setCompositionEvents(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent value) {
        copyOnWrite();
        instance.setCompositionEvents(index, value);
        return this;
      }
      /**
       * <pre>
       * Assumes that the entries are sorted by the probability.
       * The most probable event should be at the top.
       * </pre>
       *
       * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
       */
      public Builder setCompositionEvents(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent.Builder builderForValue) {
        copyOnWrite();
        instance.setCompositionEvents(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Assumes that the entries are sorted by the probability.
       * The most probable event should be at the top.
       * </pre>
       *
       * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
       */
      public Builder addCompositionEvents(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent value) {
        copyOnWrite();
        instance.addCompositionEvents(value);
        return this;
      }
      /**
       * <pre>
       * Assumes that the entries are sorted by the probability.
       * The most probable event should be at the top.
       * </pre>
       *
       * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
       */
      public Builder addCompositionEvents(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent value) {
        copyOnWrite();
        instance.addCompositionEvents(index, value);
        return this;
      }
      /**
       * <pre>
       * Assumes that the entries are sorted by the probability.
       * The most probable event should be at the top.
       * </pre>
       *
       * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
       */
      public Builder addCompositionEvents(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent.Builder builderForValue) {
        copyOnWrite();
        instance.addCompositionEvents(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Assumes that the entries are sorted by the probability.
       * The most probable event should be at the top.
       * </pre>
       *
       * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
       */
      public Builder addCompositionEvents(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent.Builder builderForValue) {
        copyOnWrite();
        instance.addCompositionEvents(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Assumes that the entries are sorted by the probability.
       * The most probable event should be at the top.
       * </pre>
       *
       * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
       */
      public Builder addAllCompositionEvents(
          java.lang.Iterable<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent> values) {
        copyOnWrite();
        instance.addAllCompositionEvents(values);
        return this;
      }
      /**
       * <pre>
       * Assumes that the entries are sorted by the probability.
       * The most probable event should be at the top.
       * </pre>
       *
       * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
       */
      public Builder clearCompositionEvents() {
        copyOnWrite();
        instance.clearCompositionEvents();
        return this;
      }
      /**
       * <pre>
       * Assumes that the entries are sorted by the probability.
       * The most probable event should be at the top.
       * </pre>
       *
       * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
       */
      public Builder removeCompositionEvents(int index) {
        copyOnWrite();
        instance.removeCompositionEvents(index);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:mozc.commands.SessionCommand)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "type_",
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CommandType.internalGetVerifier(),
              "id_",
              "compositionMode_",
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode.internalGetVerifier(),
              "text_",
              "cursorPosition_",
              "compositionEvents_",
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent.class,
            };
            java.lang.String info =
                "\u0001\u0006\u0000\u0001\u0001\u000b\u0006\u0000\u0001\u0001\u0001\u150c\u0000\u0002" +
                "\u1004\u0001\u0003\u100c\u0002\u0004\u1008\u0003\u0005\u100b\u0004\u000b\u001b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand> parser = PARSER;
          if (parser == null) {
            synchronized (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:mozc.commands.SessionCommand)
    private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand DEFAULT_INSTANCE;
    static {
      SessionCommand defaultInstance = new SessionCommand();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        SessionCommand.class, defaultInstance);
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<SessionCommand> PARSER;

    public static com.google.protobuf.Parser<SessionCommand> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ContextOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mozc.commands.Context)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Former part of surrounding text.
     * </pre>
     *
     * <code>optional string preceding_text = 1;</code>
     * @return Whether the precedingText field is set.
     */
    boolean hasPrecedingText();
    /**
     * <pre>
     * Former part of surrounding text.
     * </pre>
     *
     * <code>optional string preceding_text = 1;</code>
     * @return The precedingText.
     */
    java.lang.String getPrecedingText();
    /**
     * <pre>
     * Former part of surrounding text.
     * </pre>
     *
     * <code>optional string preceding_text = 1;</code>
     * @return The bytes for precedingText.
     */
    com.google.protobuf.ByteString
        getPrecedingTextBytes();

    /**
     * <pre>
     * Latter part of surrounding text.
     * </pre>
     *
     * <code>optional string following_text = 2;</code>
     * @return Whether the followingText field is set.
     */
    boolean hasFollowingText();
    /**
     * <pre>
     * Latter part of surrounding text.
     * </pre>
     *
     * <code>optional string following_text = 2;</code>
     * @return The followingText.
     */
    java.lang.String getFollowingText();
    /**
     * <pre>
     * Latter part of surrounding text.
     * </pre>
     *
     * <code>optional string following_text = 2;</code>
     * @return The bytes for followingText.
     */
    com.google.protobuf.ByteString
        getFollowingTextBytes();

    /**
     * <pre>
     * If this is true, suggestion feature is disabled regardless the
     * configuration.  If this is false, suggestion feature is followed
     * by the user's configuration.  If you want to omit interim
     * suggestions during the key typing, you might want to use
     * request_suggestion.
     * </pre>
     *
     * <code>optional bool suppress_suggestion = 3 [default = false];</code>
     * @return Whether the suppressSuggestion field is set.
     */
    boolean hasSuppressSuggestion();
    /**
     * <pre>
     * If this is true, suggestion feature is disabled regardless the
     * configuration.  If this is false, suggestion feature is followed
     * by the user's configuration.  If you want to omit interim
     * suggestions during the key typing, you might want to use
     * request_suggestion.
     * </pre>
     *
     * <code>optional bool suppress_suggestion = 3 [default = false];</code>
     * @return The suppressSuggestion.
     */
    boolean getSuppressSuggestion();

    /**
     * <pre>
     * Type of the input field being focused.
     * </pre>
     *
     * <code>optional .mozc.commands.Context.InputFieldType input_field_type = 4;</code>
     * @return Whether the inputFieldType field is set.
     */
    boolean hasInputFieldType();
    /**
     * <pre>
     * Type of the input field being focused.
     * </pre>
     *
     * <code>optional .mozc.commands.Context.InputFieldType input_field_type = 4;</code>
     * @return The inputFieldType.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.InputFieldType getInputFieldType();

    /**
     * <pre>
     * An unique revision ID to specify one specific typing session. A client can
     * use arbitrary value for this field. The converter is expected to clear its
     * internal history segments whenever this value is changed. A client should
     * use the same revision ID whenever the converter should keep it internal
     * history segments. In order to avoid unexpected history learnings, a client
     * should update the revision whenever the input focus is changed.
     * </pre>
     *
     * <code>optional int32 revision = 5 [default = 0];</code>
     * @return Whether the revision field is set.
     */
    boolean hasRevision();
    /**
     * <pre>
     * An unique revision ID to specify one specific typing session. A client can
     * use arbitrary value for this field. The converter is expected to clear its
     * internal history segments whenever this value is changed. A client should
     * use the same revision ID whenever the converter should keep it internal
     * history segments. In order to avoid unexpected history learnings, a client
     * should update the revision whenever the input focus is changed.
     * </pre>
     *
     * <code>optional int32 revision = 5 [default = 0];</code>
     * @return The revision.
     */
    int getRevision();

    /**
     * <pre>
     * Repeated fields to be used for experimental features.
     * </pre>
     *
     * <code>repeated string experimental_features = 100;</code>
     * @return A list containing the experimentalFeatures.
     */
    java.util.List<java.lang.String>
        getExperimentalFeaturesList();
    /**
     * <pre>
     * Repeated fields to be used for experimental features.
     * </pre>
     *
     * <code>repeated string experimental_features = 100;</code>
     * @return The count of experimentalFeatures.
     */
    int getExperimentalFeaturesCount();
    /**
     * <pre>
     * Repeated fields to be used for experimental features.
     * </pre>
     *
     * <code>repeated string experimental_features = 100;</code>
     * @param index The index of the element to return.
     * @return The experimentalFeatures at the given index.
     */
    java.lang.String getExperimentalFeatures(int index);
    /**
     * <pre>
     * Repeated fields to be used for experimental features.
     * </pre>
     *
     * <code>repeated string experimental_features = 100;</code>
     * @param index The index of the element to return.
     * @return The experimentalFeatures at the given index.
     */
    com.google.protobuf.ByteString
        getExperimentalFeaturesBytes(int index);
  }
  /**
   * Protobuf type {@code mozc.commands.Context}
   */
  public  static final class Context extends
      com.google.protobuf.GeneratedMessageLite<
          Context, Context.Builder> implements
      // @@protoc_insertion_point(message_implements:mozc.commands.Context)
      ContextOrBuilder {
    private Context() {
      precedingText_ = "";
      followingText_ = "";
      inputFieldType_ = 1;
      experimentalFeatures_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
    }
    /**
     * <pre>
     * Input field type.
     * The types are based on the input types defined in HTML5.
     * http://dev.w3.org/html5/spec/Overview.html#attr-input-type
     * Other types are to be added later.
     * </pre>
     *
     * Protobuf enum {@code mozc.commands.Context.InputFieldType}
     */
    public enum InputFieldType
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <pre>
       * No restrictions nor special functions. The IME operates as usual.
       * </pre>
       *
       * <code>NORMAL = 1;</code>
       */
      NORMAL(1),
      /**
       * <pre>
       * Password field. Text is hidden after input.
       * For Android,
       * In order to make the last character visible to the user,
       * the IME must not hold more than 2 characters in preedit.
       * </pre>
       *
       * <code>PASSWORD = 2;</code>
       */
      PASSWORD(2),
      /**
       * <pre>
       * Telephone number
       * </pre>
       *
       * <code>TEL = 3;</code>
       */
      TEL(3),
      /**
       * <pre>
       * Number
       * </pre>
       *
       * <code>NUMBER = 4;</code>
       */
      NUMBER(4),
      ;

      /**
       * <pre>
       * No restrictions nor special functions. The IME operates as usual.
       * </pre>
       *
       * <code>NORMAL = 1;</code>
       */
      public static final int NORMAL_VALUE = 1;
      /**
       * <pre>
       * Password field. Text is hidden after input.
       * For Android,
       * In order to make the last character visible to the user,
       * the IME must not hold more than 2 characters in preedit.
       * </pre>
       *
       * <code>PASSWORD = 2;</code>
       */
      public static final int PASSWORD_VALUE = 2;
      /**
       * <pre>
       * Telephone number
       * </pre>
       *
       * <code>TEL = 3;</code>
       */
      public static final int TEL_VALUE = 3;
      /**
       * <pre>
       * Number
       * </pre>
       *
       * <code>NUMBER = 4;</code>
       */
      public static final int NUMBER_VALUE = 4;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static InputFieldType valueOf(int value) {
        return forNumber(value);
      }

      public static InputFieldType forNumber(int value) {
        switch (value) {
          case 1: return NORMAL;
          case 2: return PASSWORD;
          case 3: return TEL;
          case 4: return NUMBER;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<InputFieldType>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          InputFieldType> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<InputFieldType>() {
              @java.lang.Override
              public InputFieldType findValueByNumber(int number) {
                return InputFieldType.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return InputFieldTypeVerifier.INSTANCE;
      }

      private static final class InputFieldTypeVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new InputFieldTypeVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return InputFieldType.forNumber(number) != null;
              }
            };

      private final int value;

      private InputFieldType(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.commands.Context.InputFieldType)
    }

    private int bitField0_;
    public static final int PRECEDING_TEXT_FIELD_NUMBER = 1;
    private java.lang.String precedingText_;
    /**
     * <pre>
     * Former part of surrounding text.
     * </pre>
     *
     * <code>optional string preceding_text = 1;</code>
     * @return Whether the precedingText field is set.
     */
    @java.lang.Override
    public boolean hasPrecedingText() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Former part of surrounding text.
     * </pre>
     *
     * <code>optional string preceding_text = 1;</code>
     * @return The precedingText.
     */
    @java.lang.Override
    public java.lang.String getPrecedingText() {
      return precedingText_;
    }
    /**
     * <pre>
     * Former part of surrounding text.
     * </pre>
     *
     * <code>optional string preceding_text = 1;</code>
     * @return The bytes for precedingText.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPrecedingTextBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(precedingText_);
    }
    /**
     * <pre>
     * Former part of surrounding text.
     * </pre>
     *
     * <code>optional string preceding_text = 1;</code>
     * @param value The precedingText to set.
     */
    private void setPrecedingText(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000001;
      precedingText_ = value;
    }
    /**
     * <pre>
     * Former part of surrounding text.
     * </pre>
     *
     * <code>optional string preceding_text = 1;</code>
     */
    private void clearPrecedingText() {
      bitField0_ = (bitField0_ & ~0x00000001);
      precedingText_ = getDefaultInstance().getPrecedingText();
    }
    /**
     * <pre>
     * Former part of surrounding text.
     * </pre>
     *
     * <code>optional string preceding_text = 1;</code>
     * @param value The bytes for precedingText to set.
     */
    private void setPrecedingTextBytes(
        com.google.protobuf.ByteString value) {
      precedingText_ = value.toStringUtf8();
      bitField0_ |= 0x00000001;
    }

    public static final int FOLLOWING_TEXT_FIELD_NUMBER = 2;
    private java.lang.String followingText_;
    /**
     * <pre>
     * Latter part of surrounding text.
     * </pre>
     *
     * <code>optional string following_text = 2;</code>
     * @return Whether the followingText field is set.
     */
    @java.lang.Override
    public boolean hasFollowingText() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Latter part of surrounding text.
     * </pre>
     *
     * <code>optional string following_text = 2;</code>
     * @return The followingText.
     */
    @java.lang.Override
    public java.lang.String getFollowingText() {
      return followingText_;
    }
    /**
     * <pre>
     * Latter part of surrounding text.
     * </pre>
     *
     * <code>optional string following_text = 2;</code>
     * @return The bytes for followingText.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getFollowingTextBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(followingText_);
    }
    /**
     * <pre>
     * Latter part of surrounding text.
     * </pre>
     *
     * <code>optional string following_text = 2;</code>
     * @param value The followingText to set.
     */
    private void setFollowingText(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000002;
      followingText_ = value;
    }
    /**
     * <pre>
     * Latter part of surrounding text.
     * </pre>
     *
     * <code>optional string following_text = 2;</code>
     */
    private void clearFollowingText() {
      bitField0_ = (bitField0_ & ~0x00000002);
      followingText_ = getDefaultInstance().getFollowingText();
    }
    /**
     * <pre>
     * Latter part of surrounding text.
     * </pre>
     *
     * <code>optional string following_text = 2;</code>
     * @param value The bytes for followingText to set.
     */
    private void setFollowingTextBytes(
        com.google.protobuf.ByteString value) {
      followingText_ = value.toStringUtf8();
      bitField0_ |= 0x00000002;
    }

    public static final int SUPPRESS_SUGGESTION_FIELD_NUMBER = 3;
    private boolean suppressSuggestion_;
    /**
     * <pre>
     * If this is true, suggestion feature is disabled regardless the
     * configuration.  If this is false, suggestion feature is followed
     * by the user's configuration.  If you want to omit interim
     * suggestions during the key typing, you might want to use
     * request_suggestion.
     * </pre>
     *
     * <code>optional bool suppress_suggestion = 3 [default = false];</code>
     * @return Whether the suppressSuggestion field is set.
     */
    @java.lang.Override
    public boolean hasSuppressSuggestion() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * If this is true, suggestion feature is disabled regardless the
     * configuration.  If this is false, suggestion feature is followed
     * by the user's configuration.  If you want to omit interim
     * suggestions during the key typing, you might want to use
     * request_suggestion.
     * </pre>
     *
     * <code>optional bool suppress_suggestion = 3 [default = false];</code>
     * @return The suppressSuggestion.
     */
    @java.lang.Override
    public boolean getSuppressSuggestion() {
      return suppressSuggestion_;
    }
    /**
     * <pre>
     * If this is true, suggestion feature is disabled regardless the
     * configuration.  If this is false, suggestion feature is followed
     * by the user's configuration.  If you want to omit interim
     * suggestions during the key typing, you might want to use
     * request_suggestion.
     * </pre>
     *
     * <code>optional bool suppress_suggestion = 3 [default = false];</code>
     * @param value The suppressSuggestion to set.
     */
    private void setSuppressSuggestion(boolean value) {
      bitField0_ |= 0x00000004;
      suppressSuggestion_ = value;
    }
    /**
     * <pre>
     * If this is true, suggestion feature is disabled regardless the
     * configuration.  If this is false, suggestion feature is followed
     * by the user's configuration.  If you want to omit interim
     * suggestions during the key typing, you might want to use
     * request_suggestion.
     * </pre>
     *
     * <code>optional bool suppress_suggestion = 3 [default = false];</code>
     */
    private void clearSuppressSuggestion() {
      bitField0_ = (bitField0_ & ~0x00000004);
      suppressSuggestion_ = false;
    }

    public static final int INPUT_FIELD_TYPE_FIELD_NUMBER = 4;
    private int inputFieldType_;
    /**
     * <pre>
     * Type of the input field being focused.
     * </pre>
     *
     * <code>optional .mozc.commands.Context.InputFieldType input_field_type = 4;</code>
     * @return Whether the inputFieldType field is set.
     */
    @java.lang.Override
    public boolean hasInputFieldType() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Type of the input field being focused.
     * </pre>
     *
     * <code>optional .mozc.commands.Context.InputFieldType input_field_type = 4;</code>
     * @return The inputFieldType.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.InputFieldType getInputFieldType() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.InputFieldType result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.InputFieldType.forNumber(inputFieldType_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.InputFieldType.NORMAL : result;
    }
    /**
     * <pre>
     * Type of the input field being focused.
     * </pre>
     *
     * <code>optional .mozc.commands.Context.InputFieldType input_field_type = 4;</code>
     * @param value The inputFieldType to set.
     */
    private void setInputFieldType(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.InputFieldType value) {
      inputFieldType_ = value.getNumber();
      bitField0_ |= 0x00000008;
    }
    /**
     * <pre>
     * Type of the input field being focused.
     * </pre>
     *
     * <code>optional .mozc.commands.Context.InputFieldType input_field_type = 4;</code>
     */
    private void clearInputFieldType() {
      bitField0_ = (bitField0_ & ~0x00000008);
      inputFieldType_ = 1;
    }

    public static final int REVISION_FIELD_NUMBER = 5;
    private int revision_;
    /**
     * <pre>
     * An unique revision ID to specify one specific typing session. A client can
     * use arbitrary value for this field. The converter is expected to clear its
     * internal history segments whenever this value is changed. A client should
     * use the same revision ID whenever the converter should keep it internal
     * history segments. In order to avoid unexpected history learnings, a client
     * should update the revision whenever the input focus is changed.
     * </pre>
     *
     * <code>optional int32 revision = 5 [default = 0];</code>
     * @return Whether the revision field is set.
     */
    @java.lang.Override
    public boolean hasRevision() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * An unique revision ID to specify one specific typing session. A client can
     * use arbitrary value for this field. The converter is expected to clear its
     * internal history segments whenever this value is changed. A client should
     * use the same revision ID whenever the converter should keep it internal
     * history segments. In order to avoid unexpected history learnings, a client
     * should update the revision whenever the input focus is changed.
     * </pre>
     *
     * <code>optional int32 revision = 5 [default = 0];</code>
     * @return The revision.
     */
    @java.lang.Override
    public int getRevision() {
      return revision_;
    }
    /**
     * <pre>
     * An unique revision ID to specify one specific typing session. A client can
     * use arbitrary value for this field. The converter is expected to clear its
     * internal history segments whenever this value is changed. A client should
     * use the same revision ID whenever the converter should keep it internal
     * history segments. In order to avoid unexpected history learnings, a client
     * should update the revision whenever the input focus is changed.
     * </pre>
     *
     * <code>optional int32 revision = 5 [default = 0];</code>
     * @param value The revision to set.
     */
    private void setRevision(int value) {
      bitField0_ |= 0x00000010;
      revision_ = value;
    }
    /**
     * <pre>
     * An unique revision ID to specify one specific typing session. A client can
     * use arbitrary value for this field. The converter is expected to clear its
     * internal history segments whenever this value is changed. A client should
     * use the same revision ID whenever the converter should keep it internal
     * history segments. In order to avoid unexpected history learnings, a client
     * should update the revision whenever the input focus is changed.
     * </pre>
     *
     * <code>optional int32 revision = 5 [default = 0];</code>
     */
    private void clearRevision() {
      bitField0_ = (bitField0_ & ~0x00000010);
      revision_ = 0;
    }

    public static final int EXPERIMENTAL_FEATURES_FIELD_NUMBER = 100;
    private com.google.protobuf.Internal.ProtobufList<java.lang.String> experimentalFeatures_;
    /**
     * <pre>
     * Repeated fields to be used for experimental features.
     * </pre>
     *
     * <code>repeated string experimental_features = 100;</code>
     * @return A list containing the experimentalFeatures.
     */
    @java.lang.Override
    public java.util.List<java.lang.String> getExperimentalFeaturesList() {
      return experimentalFeatures_;
    }
    /**
     * <pre>
     * Repeated fields to be used for experimental features.
     * </pre>
     *
     * <code>repeated string experimental_features = 100;</code>
     * @return The count of experimentalFeatures.
     */
    @java.lang.Override
    public int getExperimentalFeaturesCount() {
      return experimentalFeatures_.size();
    }
    /**
     * <pre>
     * Repeated fields to be used for experimental features.
     * </pre>
     *
     * <code>repeated string experimental_features = 100;</code>
     * @param index The index of the element to return.
     * @return The experimentalFeatures at the given index.
     */
    @java.lang.Override
    public java.lang.String getExperimentalFeatures(int index) {
      return experimentalFeatures_.get(index);
    }
    /**
     * <pre>
     * Repeated fields to be used for experimental features.
     * </pre>
     *
     * <code>repeated string experimental_features = 100;</code>
     * @param index The index of the value to return.
     * @return The bytes of the experimentalFeatures at the given index.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getExperimentalFeaturesBytes(int index) {
      return com.google.protobuf.ByteString.copyFromUtf8(
          experimentalFeatures_.get(index));
    }
    private void ensureExperimentalFeaturesIsMutable() {
      com.google.protobuf.Internal.ProtobufList<java.lang.String> tmp =
          experimentalFeatures_;  if (!tmp.isModifiable()) {
        experimentalFeatures_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }
    /**
     * <pre>
     * Repeated fields to be used for experimental features.
     * </pre>
     *
     * <code>repeated string experimental_features = 100;</code>
     * @param index The index to set the value at.
     * @param value The experimentalFeatures to set.
     */
    private void setExperimentalFeatures(
        int index, java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  ensureExperimentalFeaturesIsMutable();
      experimentalFeatures_.set(index, value);
    }
    /**
     * <pre>
     * Repeated fields to be used for experimental features.
     * </pre>
     *
     * <code>repeated string experimental_features = 100;</code>
     * @param value The experimentalFeatures to add.
     */
    private void addExperimentalFeatures(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  ensureExperimentalFeaturesIsMutable();
      experimentalFeatures_.add(value);
    }
    /**
     * <pre>
     * Repeated fields to be used for experimental features.
     * </pre>
     *
     * <code>repeated string experimental_features = 100;</code>
     * @param values The experimentalFeatures to add.
     */
    private void addAllExperimentalFeatures(
        java.lang.Iterable<java.lang.String> values) {
      ensureExperimentalFeaturesIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, experimentalFeatures_);
    }
    /**
     * <pre>
     * Repeated fields to be used for experimental features.
     * </pre>
     *
     * <code>repeated string experimental_features = 100;</code>
     */
    private void clearExperimentalFeatures() {
      experimentalFeatures_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
    }
    /**
     * <pre>
     * Repeated fields to be used for experimental features.
     * </pre>
     *
     * <code>repeated string experimental_features = 100;</code>
     * @param value The bytes of the experimentalFeatures to add.
     */
    private void addExperimentalFeaturesBytes(
        com.google.protobuf.ByteString value) {
      ensureExperimentalFeaturesIsMutable();
      experimentalFeatures_.add(value.toStringUtf8());
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code mozc.commands.Context}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context, Builder> implements
        // @@protoc_insertion_point(builder_implements:mozc.commands.Context)
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ContextOrBuilder {
      // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Former part of surrounding text.
       * </pre>
       *
       * <code>optional string preceding_text = 1;</code>
       * @return Whether the precedingText field is set.
       */
      @java.lang.Override
      public boolean hasPrecedingText() {
        return instance.hasPrecedingText();
      }
      /**
       * <pre>
       * Former part of surrounding text.
       * </pre>
       *
       * <code>optional string preceding_text = 1;</code>
       * @return The precedingText.
       */
      @java.lang.Override
      public java.lang.String getPrecedingText() {
        return instance.getPrecedingText();
      }
      /**
       * <pre>
       * Former part of surrounding text.
       * </pre>
       *
       * <code>optional string preceding_text = 1;</code>
       * @return The bytes for precedingText.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getPrecedingTextBytes() {
        return instance.getPrecedingTextBytes();
      }
      /**
       * <pre>
       * Former part of surrounding text.
       * </pre>
       *
       * <code>optional string preceding_text = 1;</code>
       * @param value The precedingText to set.
       * @return This builder for chaining.
       */
      public Builder setPrecedingText(
          java.lang.String value) {
        copyOnWrite();
        instance.setPrecedingText(value);
        return this;
      }
      /**
       * <pre>
       * Former part of surrounding text.
       * </pre>
       *
       * <code>optional string preceding_text = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearPrecedingText() {
        copyOnWrite();
        instance.clearPrecedingText();
        return this;
      }
      /**
       * <pre>
       * Former part of surrounding text.
       * </pre>
       *
       * <code>optional string preceding_text = 1;</code>
       * @param value The bytes for precedingText to set.
       * @return This builder for chaining.
       */
      public Builder setPrecedingTextBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPrecedingTextBytes(value);
        return this;
      }

      /**
       * <pre>
       * Latter part of surrounding text.
       * </pre>
       *
       * <code>optional string following_text = 2;</code>
       * @return Whether the followingText field is set.
       */
      @java.lang.Override
      public boolean hasFollowingText() {
        return instance.hasFollowingText();
      }
      /**
       * <pre>
       * Latter part of surrounding text.
       * </pre>
       *
       * <code>optional string following_text = 2;</code>
       * @return The followingText.
       */
      @java.lang.Override
      public java.lang.String getFollowingText() {
        return instance.getFollowingText();
      }
      /**
       * <pre>
       * Latter part of surrounding text.
       * </pre>
       *
       * <code>optional string following_text = 2;</code>
       * @return The bytes for followingText.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getFollowingTextBytes() {
        return instance.getFollowingTextBytes();
      }
      /**
       * <pre>
       * Latter part of surrounding text.
       * </pre>
       *
       * <code>optional string following_text = 2;</code>
       * @param value The followingText to set.
       * @return This builder for chaining.
       */
      public Builder setFollowingText(
          java.lang.String value) {
        copyOnWrite();
        instance.setFollowingText(value);
        return this;
      }
      /**
       * <pre>
       * Latter part of surrounding text.
       * </pre>
       *
       * <code>optional string following_text = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearFollowingText() {
        copyOnWrite();
        instance.clearFollowingText();
        return this;
      }
      /**
       * <pre>
       * Latter part of surrounding text.
       * </pre>
       *
       * <code>optional string following_text = 2;</code>
       * @param value The bytes for followingText to set.
       * @return This builder for chaining.
       */
      public Builder setFollowingTextBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setFollowingTextBytes(value);
        return this;
      }

      /**
       * <pre>
       * If this is true, suggestion feature is disabled regardless the
       * configuration.  If this is false, suggestion feature is followed
       * by the user's configuration.  If you want to omit interim
       * suggestions during the key typing, you might want to use
       * request_suggestion.
       * </pre>
       *
       * <code>optional bool suppress_suggestion = 3 [default = false];</code>
       * @return Whether the suppressSuggestion field is set.
       */
      @java.lang.Override
      public boolean hasSuppressSuggestion() {
        return instance.hasSuppressSuggestion();
      }
      /**
       * <pre>
       * If this is true, suggestion feature is disabled regardless the
       * configuration.  If this is false, suggestion feature is followed
       * by the user's configuration.  If you want to omit interim
       * suggestions during the key typing, you might want to use
       * request_suggestion.
       * </pre>
       *
       * <code>optional bool suppress_suggestion = 3 [default = false];</code>
       * @return The suppressSuggestion.
       */
      @java.lang.Override
      public boolean getSuppressSuggestion() {
        return instance.getSuppressSuggestion();
      }
      /**
       * <pre>
       * If this is true, suggestion feature is disabled regardless the
       * configuration.  If this is false, suggestion feature is followed
       * by the user's configuration.  If you want to omit interim
       * suggestions during the key typing, you might want to use
       * request_suggestion.
       * </pre>
       *
       * <code>optional bool suppress_suggestion = 3 [default = false];</code>
       * @param value The suppressSuggestion to set.
       * @return This builder for chaining.
       */
      public Builder setSuppressSuggestion(boolean value) {
        copyOnWrite();
        instance.setSuppressSuggestion(value);
        return this;
      }
      /**
       * <pre>
       * If this is true, suggestion feature is disabled regardless the
       * configuration.  If this is false, suggestion feature is followed
       * by the user's configuration.  If you want to omit interim
       * suggestions during the key typing, you might want to use
       * request_suggestion.
       * </pre>
       *
       * <code>optional bool suppress_suggestion = 3 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearSuppressSuggestion() {
        copyOnWrite();
        instance.clearSuppressSuggestion();
        return this;
      }

      /**
       * <pre>
       * Type of the input field being focused.
       * </pre>
       *
       * <code>optional .mozc.commands.Context.InputFieldType input_field_type = 4;</code>
       * @return Whether the inputFieldType field is set.
       */
      @java.lang.Override
      public boolean hasInputFieldType() {
        return instance.hasInputFieldType();
      }
      /**
       * <pre>
       * Type of the input field being focused.
       * </pre>
       *
       * <code>optional .mozc.commands.Context.InputFieldType input_field_type = 4;</code>
       * @return The inputFieldType.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.InputFieldType getInputFieldType() {
        return instance.getInputFieldType();
      }
      /**
       * <pre>
       * Type of the input field being focused.
       * </pre>
       *
       * <code>optional .mozc.commands.Context.InputFieldType input_field_type = 4;</code>
       * @param value The enum numeric value on the wire for inputFieldType to set.
       * @return This builder for chaining.
       */
      public Builder setInputFieldType(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.InputFieldType value) {
        copyOnWrite();
        instance.setInputFieldType(value);
        return this;
      }
      /**
       * <pre>
       * Type of the input field being focused.
       * </pre>
       *
       * <code>optional .mozc.commands.Context.InputFieldType input_field_type = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearInputFieldType() {
        copyOnWrite();
        instance.clearInputFieldType();
        return this;
      }

      /**
       * <pre>
       * An unique revision ID to specify one specific typing session. A client can
       * use arbitrary value for this field. The converter is expected to clear its
       * internal history segments whenever this value is changed. A client should
       * use the same revision ID whenever the converter should keep it internal
       * history segments. In order to avoid unexpected history learnings, a client
       * should update the revision whenever the input focus is changed.
       * </pre>
       *
       * <code>optional int32 revision = 5 [default = 0];</code>
       * @return Whether the revision field is set.
       */
      @java.lang.Override
      public boolean hasRevision() {
        return instance.hasRevision();
      }
      /**
       * <pre>
       * An unique revision ID to specify one specific typing session. A client can
       * use arbitrary value for this field. The converter is expected to clear its
       * internal history segments whenever this value is changed. A client should
       * use the same revision ID whenever the converter should keep it internal
       * history segments. In order to avoid unexpected history learnings, a client
       * should update the revision whenever the input focus is changed.
       * </pre>
       *
       * <code>optional int32 revision = 5 [default = 0];</code>
       * @return The revision.
       */
      @java.lang.Override
      public int getRevision() {
        return instance.getRevision();
      }
      /**
       * <pre>
       * An unique revision ID to specify one specific typing session. A client can
       * use arbitrary value for this field. The converter is expected to clear its
       * internal history segments whenever this value is changed. A client should
       * use the same revision ID whenever the converter should keep it internal
       * history segments. In order to avoid unexpected history learnings, a client
       * should update the revision whenever the input focus is changed.
       * </pre>
       *
       * <code>optional int32 revision = 5 [default = 0];</code>
       * @param value The revision to set.
       * @return This builder for chaining.
       */
      public Builder setRevision(int value) {
        copyOnWrite();
        instance.setRevision(value);
        return this;
      }
      /**
       * <pre>
       * An unique revision ID to specify one specific typing session. A client can
       * use arbitrary value for this field. The converter is expected to clear its
       * internal history segments whenever this value is changed. A client should
       * use the same revision ID whenever the converter should keep it internal
       * history segments. In order to avoid unexpected history learnings, a client
       * should update the revision whenever the input focus is changed.
       * </pre>
       *
       * <code>optional int32 revision = 5 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearRevision() {
        copyOnWrite();
        instance.clearRevision();
        return this;
      }

      /**
       * <pre>
       * Repeated fields to be used for experimental features.
       * </pre>
       *
       * <code>repeated string experimental_features = 100;</code>
       * @return A list containing the experimentalFeatures.
       */
      @java.lang.Override
      public java.util.List<java.lang.String>
          getExperimentalFeaturesList() {
        return java.util.Collections.unmodifiableList(
            instance.getExperimentalFeaturesList());
      }
      /**
       * <pre>
       * Repeated fields to be used for experimental features.
       * </pre>
       *
       * <code>repeated string experimental_features = 100;</code>
       * @return The count of experimentalFeatures.
       */
      @java.lang.Override
      public int getExperimentalFeaturesCount() {
        return instance.getExperimentalFeaturesCount();
      }
      /**
       * <pre>
       * Repeated fields to be used for experimental features.
       * </pre>
       *
       * <code>repeated string experimental_features = 100;</code>
       * @param index The index of the element to return.
       * @return The experimentalFeatures at the given index.
       */
      @java.lang.Override
      public java.lang.String getExperimentalFeatures(int index) {
        return instance.getExperimentalFeatures(index);
      }
      /**
       * <pre>
       * Repeated fields to be used for experimental features.
       * </pre>
       *
       * <code>repeated string experimental_features = 100;</code>
       * @param index The index of the value to return.
       * @return The bytes of the experimentalFeatures at the given index.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getExperimentalFeaturesBytes(int index) {
        return instance.getExperimentalFeaturesBytes(index);
      }
      /**
       * <pre>
       * Repeated fields to be used for experimental features.
       * </pre>
       *
       * <code>repeated string experimental_features = 100;</code>
       * @param index The index to set the value at.
       * @param value The experimentalFeatures to set.
       * @return This builder for chaining.
       */
      public Builder setExperimentalFeatures(
          int index, java.lang.String value) {
        copyOnWrite();
        instance.setExperimentalFeatures(index, value);
        return this;
      }
      /**
       * <pre>
       * Repeated fields to be used for experimental features.
       * </pre>
       *
       * <code>repeated string experimental_features = 100;</code>
       * @param value The experimentalFeatures to add.
       * @return This builder for chaining.
       */
      public Builder addExperimentalFeatures(
          java.lang.String value) {
        copyOnWrite();
        instance.addExperimentalFeatures(value);
        return this;
      }
      /**
       * <pre>
       * Repeated fields to be used for experimental features.
       * </pre>
       *
       * <code>repeated string experimental_features = 100;</code>
       * @param values The experimentalFeatures to add.
       * @return This builder for chaining.
       */
      public Builder addAllExperimentalFeatures(
          java.lang.Iterable<java.lang.String> values) {
        copyOnWrite();
        instance.addAllExperimentalFeatures(values);
        return this;
      }
      /**
       * <pre>
       * Repeated fields to be used for experimental features.
       * </pre>
       *
       * <code>repeated string experimental_features = 100;</code>
       * @return This builder for chaining.
       */
      public Builder clearExperimentalFeatures() {
        copyOnWrite();
        instance.clearExperimentalFeatures();
        return this;
      }
      /**
       * <pre>
       * Repeated fields to be used for experimental features.
       * </pre>
       *
       * <code>repeated string experimental_features = 100;</code>
       * @param value The bytes of the experimentalFeatures to add.
       * @return This builder for chaining.
       */
      public Builder addExperimentalFeaturesBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.addExperimentalFeaturesBytes(value);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:mozc.commands.Context)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "precedingText_",
              "followingText_",
              "suppressSuggestion_",
              "inputFieldType_",
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.InputFieldType.internalGetVerifier(),
              "revision_",
              "experimentalFeatures_",
            };
            java.lang.String info =
                "\u0001\u0006\u0000\u0001\u0001d\u0006\u0000\u0001\u0000\u0001\u1008\u0000\u0002\u1008" +
                "\u0001\u0003\u1007\u0002\u0004\u100c\u0003\u0005\u1004\u0004d\u001a";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context> parser = PARSER;
          if (parser == null) {
            synchronized (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:mozc.commands.Context)
    private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context DEFAULT_INSTANCE;
    static {
      Context defaultInstance = new Context();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Context.class, defaultInstance);
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Context> PARSER;

    public static com.google.protobuf.Parser<Context> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface CapabilityOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mozc.commands.Capability)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>optional .mozc.commands.Capability.TextDeletionCapabilityType text_deletion = 1 [default = NO_TEXT_DELETION_CAPABILITY];</code>
     * @return Whether the textDeletion field is set.
     */
    boolean hasTextDeletion();
    /**
     * <code>optional .mozc.commands.Capability.TextDeletionCapabilityType text_deletion = 1 [default = NO_TEXT_DELETION_CAPABILITY];</code>
     * @return The textDeletion.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.TextDeletionCapabilityType getTextDeletion();
  }
  /**
   * <pre>
   * Clients' capability.
   * Users cannot modify this.
   * The server has to obey this capability.
   * </pre>
   *
   * Protobuf type {@code mozc.commands.Capability}
   */
  public  static final class Capability extends
      com.google.protobuf.GeneratedMessageLite<
          Capability, Capability.Builder> implements
      // @@protoc_insertion_point(message_implements:mozc.commands.Capability)
      CapabilityOrBuilder {
    private Capability() {
    }
    /**
     * <pre>
     * Bit fields to notify what the client can do.
     * </pre>
     *
     * Protobuf enum {@code mozc.commands.Capability.TextDeletionCapabilityType}
     */
    public enum TextDeletionCapabilityType
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>NO_TEXT_DELETION_CAPABILITY = 0;</code>
       */
      NO_TEXT_DELETION_CAPABILITY(0),
      /**
       * <pre>
       * Can delete preceding text which is adjacent to preedit.
       * </pre>
       *
       * <code>DELETE_PRECEDING_TEXT = 1;</code>
       */
      DELETE_PRECEDING_TEXT(1),
      ;

      /**
       * <code>NO_TEXT_DELETION_CAPABILITY = 0;</code>
       */
      public static final int NO_TEXT_DELETION_CAPABILITY_VALUE = 0;
      /**
       * <pre>
       * Can delete preceding text which is adjacent to preedit.
       * </pre>
       *
       * <code>DELETE_PRECEDING_TEXT = 1;</code>
       */
      public static final int DELETE_PRECEDING_TEXT_VALUE = 1;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static TextDeletionCapabilityType valueOf(int value) {
        return forNumber(value);
      }

      public static TextDeletionCapabilityType forNumber(int value) {
        switch (value) {
          case 0: return NO_TEXT_DELETION_CAPABILITY;
          case 1: return DELETE_PRECEDING_TEXT;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<TextDeletionCapabilityType>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          TextDeletionCapabilityType> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<TextDeletionCapabilityType>() {
              @java.lang.Override
              public TextDeletionCapabilityType findValueByNumber(int number) {
                return TextDeletionCapabilityType.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return TextDeletionCapabilityTypeVerifier.INSTANCE;
      }

      private static final class TextDeletionCapabilityTypeVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new TextDeletionCapabilityTypeVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return TextDeletionCapabilityType.forNumber(number) != null;
              }
            };

      private final int value;

      private TextDeletionCapabilityType(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.commands.Capability.TextDeletionCapabilityType)
    }

    private int bitField0_;
    public static final int TEXT_DELETION_FIELD_NUMBER = 1;
    private int textDeletion_;
    /**
     * <code>optional .mozc.commands.Capability.TextDeletionCapabilityType text_deletion = 1 [default = NO_TEXT_DELETION_CAPABILITY];</code>
     * @return Whether the textDeletion field is set.
     */
    @java.lang.Override
    public boolean hasTextDeletion() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional .mozc.commands.Capability.TextDeletionCapabilityType text_deletion = 1 [default = NO_TEXT_DELETION_CAPABILITY];</code>
     * @return The textDeletion.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.TextDeletionCapabilityType getTextDeletion() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.TextDeletionCapabilityType result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.TextDeletionCapabilityType.forNumber(textDeletion_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.TextDeletionCapabilityType.NO_TEXT_DELETION_CAPABILITY : result;
    }
    /**
     * <code>optional .mozc.commands.Capability.TextDeletionCapabilityType text_deletion = 1 [default = NO_TEXT_DELETION_CAPABILITY];</code>
     * @param value The textDeletion to set.
     */
    private void setTextDeletion(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.TextDeletionCapabilityType value) {
      textDeletion_ = value.getNumber();
      bitField0_ |= 0x00000001;
    }
    /**
     * <code>optional .mozc.commands.Capability.TextDeletionCapabilityType text_deletion = 1 [default = NO_TEXT_DELETION_CAPABILITY];</code>
     */
    private void clearTextDeletion() {
      bitField0_ = (bitField0_ & ~0x00000001);
      textDeletion_ = 0;
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Clients' capability.
     * Users cannot modify this.
     * The server has to obey this capability.
     * </pre>
     *
     * Protobuf type {@code mozc.commands.Capability}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability, Builder> implements
        // @@protoc_insertion_point(builder_implements:mozc.commands.Capability)
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CapabilityOrBuilder {
      // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>optional .mozc.commands.Capability.TextDeletionCapabilityType text_deletion = 1 [default = NO_TEXT_DELETION_CAPABILITY];</code>
       * @return Whether the textDeletion field is set.
       */
      @java.lang.Override
      public boolean hasTextDeletion() {
        return instance.hasTextDeletion();
      }
      /**
       * <code>optional .mozc.commands.Capability.TextDeletionCapabilityType text_deletion = 1 [default = NO_TEXT_DELETION_CAPABILITY];</code>
       * @return The textDeletion.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.TextDeletionCapabilityType getTextDeletion() {
        return instance.getTextDeletion();
      }
      /**
       * <code>optional .mozc.commands.Capability.TextDeletionCapabilityType text_deletion = 1 [default = NO_TEXT_DELETION_CAPABILITY];</code>
       * @param value The enum numeric value on the wire for textDeletion to set.
       * @return This builder for chaining.
       */
      public Builder setTextDeletion(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.TextDeletionCapabilityType value) {
        copyOnWrite();
        instance.setTextDeletion(value);
        return this;
      }
      /**
       * <code>optional .mozc.commands.Capability.TextDeletionCapabilityType text_deletion = 1 [default = NO_TEXT_DELETION_CAPABILITY];</code>
       * @return This builder for chaining.
       */
      public Builder clearTextDeletion() {
        copyOnWrite();
        instance.clearTextDeletion();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:mozc.commands.Capability)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "textDeletion_",
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.TextDeletionCapabilityType.internalGetVerifier(),
            };
            java.lang.String info =
                "\u0001\u0001\u0000\u0001\u0001\u0001\u0001\u0000\u0000\u0000\u0001\u100c\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability> parser = PARSER;
          if (parser == null) {
            synchronized (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:mozc.commands.Capability)
    private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability DEFAULT_INSTANCE;
    static {
      Capability defaultInstance = new Capability();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Capability.class, defaultInstance);
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Capability> PARSER;

    public static com.google.protobuf.Parser<Capability> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface DecoderExperimentParamsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mozc.commands.DecoderExperimentParams)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Bitmap of enabled variation character types.
     * </pre>
     *
     * <code>optional uint32 variation_character_types = 8 [default = 0];</code>
     * @return Whether the variationCharacterTypes field is set.
     */
    boolean hasVariationCharacterTypes();
    /**
     * <pre>
     * Bitmap of enabled variation character types.
     * </pre>
     *
     * <code>optional uint32 variation_character_types = 8 [default = 0];</code>
     * @return The variationCharacterTypes.
     */
    int getVariationCharacterTypes();

    /**
     * <pre>
     * Enables final results reranking against literal results.
     * If zero, the previous implementation is used.
     * </pre>
     *
     * <code>optional int32 typing_correction_result_reranker_mode = 95 [default = 0];</code>
     * @return Whether the typingCorrectionResultRerankerMode field is set.
     */
    boolean hasTypingCorrectionResultRerankerMode();
    /**
     * <pre>
     * Enables final results reranking against literal results.
     * If zero, the previous implementation is used.
     * </pre>
     *
     * <code>optional int32 typing_correction_result_reranker_mode = 95 [default = 0];</code>
     * @return The typingCorrectionResultRerankerMode.
     */
    int getTypingCorrectionResultRerankerMode();

    /**
     * <pre>
     * Promote TC/Literal if w * tc_reranker_score + (1.0 - w) lm_diff &gt; 0.0.
     * </pre>
     *
     * <code>optional float typing_correction_result_reranker_interpolation_weight = 100 [default = 0];</code>
     * @return Whether the typingCorrectionResultRerankerInterpolationWeight field is set.
     */
    boolean hasTypingCorrectionResultRerankerInterpolationWeight();
    /**
     * <pre>
     * Promote TC/Literal if w * tc_reranker_score + (1.0 - w) lm_diff &gt; 0.0.
     * </pre>
     *
     * <code>optional float typing_correction_result_reranker_interpolation_weight = 100 [default = 0];</code>
     * @return The typingCorrectionResultRerankerInterpolationWeight.
     */
    float getTypingCorrectionResultRerankerInterpolationWeight();

    /**
     * <pre>
     * Runs Literal-at-least second when original_tc_score + w * tc_reranker_score
     * &gt; 0.0. otherwise, runs literal-on-top.
     * </pre>
     *
     * <code>optional float typing_correction_result_reranker_literal_on_top_weight = 101 [default = 0];</code>
     * @return Whether the typingCorrectionResultRerankerLiteralOnTopWeight field is set.
     */
    boolean hasTypingCorrectionResultRerankerLiteralOnTopWeight();
    /**
     * <pre>
     * Runs Literal-at-least second when original_tc_score + w * tc_reranker_score
     * &gt; 0.0. otherwise, runs literal-on-top.
     * </pre>
     *
     * <code>optional float typing_correction_result_reranker_literal_on_top_weight = 101 [default = 0];</code>
     * @return The typingCorrectionResultRerankerLiteralOnTopWeight.
     */
    float getTypingCorrectionResultRerankerLiteralOnTopWeight();

    /**
     * <pre>
     * Uses the typing correction in user history predictor. The size specifies
     * the maximum number of typing corrections used for query lookup.
     * When zero, typing_correction is not used.
     * </pre>
     *
     * <code>optional int32 typing_correction_apply_user_history_size = 85 [default = 0];</code>
     * @return Whether the typingCorrectionApplyUserHistorySize field is set.
     */
    boolean hasTypingCorrectionApplyUserHistorySize();
    /**
     * <pre>
     * Uses the typing correction in user history predictor. The size specifies
     * the maximum number of typing corrections used for query lookup.
     * When zero, typing_correction is not used.
     * </pre>
     *
     * <code>optional int32 typing_correction_apply_user_history_size = 85 [default = 0];</code>
     * @return The typingCorrectionApplyUserHistorySize.
     */
    int getTypingCorrectionApplyUserHistorySize();

    /**
     * <code>optional bool disable_zero_query_suffix_prediction = 36 [default = false];</code>
     * @return Whether the disableZeroQuerySuffixPrediction field is set.
     */
    boolean hasDisableZeroQuerySuffixPrediction();
    /**
     * <code>optional bool disable_zero_query_suffix_prediction = 36 [default = false];</code>
     * @return The disableZeroQuerySuffixPrediction.
     */
    boolean getDisableZeroQuerySuffixPrediction();

    /**
     * <pre>
     * Changes the size of history with character coverage.
     * </pre>
     *
     * <code>optional int32 user_history_prediction_max_char_coverage = 82 [default = 0];</code>
     * @return Whether the userHistoryPredictionMaxCharCoverage field is set.
     */
    boolean hasUserHistoryPredictionMaxCharCoverage();
    /**
     * <pre>
     * Changes the size of history with character coverage.
     * </pre>
     *
     * <code>optional int32 user_history_prediction_max_char_coverage = 82 [default = 0];</code>
     * @return The userHistoryPredictionMaxCharCoverage.
     */
    int getUserHistoryPredictionMaxCharCoverage();

    /**
     * <pre>
     * Parameter for space-insertion for English compounds
     * value 0: no insertion. Candidates will be like this.
     * - "Google"
     * - "GOOGLE"
     * - "google"
     * value 1: expand for all English candidates
     * This mode adds space-prefixed candidates for three style, like this.
     * - "Google"
     * - " Google"
     * - "GOOGLE"
     * - " GOOGLE"
     * - "google"
     * - " google"
     * </pre>
     *
     * <code>optional int32 english_variation_space_insertion_mode = 55 [default = 0];</code>
     * @return Whether the englishVariationSpaceInsertionMode field is set.
     */
    boolean hasEnglishVariationSpaceInsertionMode();
    /**
     * <pre>
     * Parameter for space-insertion for English compounds
     * value 0: no insertion. Candidates will be like this.
     * - "Google"
     * - "GOOGLE"
     * - "google"
     * value 1: expand for all English candidates
     * This mode adds space-prefixed candidates for three style, like this.
     * - "Google"
     * - " Google"
     * - "GOOGLE"
     * - " GOOGLE"
     * - "google"
     * - " google"
     * </pre>
     *
     * <code>optional int32 english_variation_space_insertion_mode = 55 [default = 0];</code>
     * @return The englishVariationSpaceInsertionMode.
     */
    int getEnglishVariationSpaceInsertionMode();

    /**
     * <code>optional int32 candidate_consistency_cost_max_diff = 63 [default = 0];</code>
     * @return Whether the candidateConsistencyCostMaxDiff field is set.
     */
    boolean hasCandidateConsistencyCostMaxDiff();
    /**
     * <code>optional int32 candidate_consistency_cost_max_diff = 63 [default = 0];</code>
     * @return The candidateConsistencyCostMaxDiff.
     */
    int getCandidateConsistencyCostMaxDiff();

    /**
     * <code>optional int32 max_composition_event_to_process = 64 [default = 2];</code>
     * @return Whether the maxCompositionEventToProcess field is set.
     */
    boolean hasMaxCompositionEventToProcess();
    /**
     * <code>optional int32 max_composition_event_to_process = 64 [default = 2];</code>
     * @return The maxCompositionEventToProcess.
     */
    int getMaxCompositionEventToProcess();

    /**
     * <pre>
     * Offset to promote Katakana candidates in rewriter.
     * The promotion will be disabled if the value is negative.
     * </pre>
     *
     * <code>optional int32 katakana_promotion_offset = 83 [default = 5];</code>
     * @return Whether the katakanaPromotionOffset field is set.
     */
    boolean hasKatakanaPromotionOffset();
    /**
     * <pre>
     * Offset to promote Katakana candidates in rewriter.
     * The promotion will be disabled if the value is negative.
     * </pre>
     *
     * <code>optional int32 katakana_promotion_offset = 83 [default = 5];</code>
     * @return The katakanaPromotionOffset.
     */
    int getKatakanaPromotionOffset();

    /**
     * <pre>
     * Cost offset for handwriting conversion candidate.
     * default_value: 10*log(500)
     * </pre>
     *
     * <code>optional int32 handwriting_conversion_candidate_cost_offset = 102 [default = 1151];</code>
     * @return Whether the handwritingConversionCandidateCostOffset field is set.
     */
    boolean hasHandwritingConversionCandidateCostOffset();
    /**
     * <pre>
     * Cost offset for handwriting conversion candidate.
     * default_value: 10*log(500)
     * </pre>
     *
     * <code>optional int32 handwriting_conversion_candidate_cost_offset = 102 [default = 1151];</code>
     * @return The handwritingConversionCandidateCostOffset.
     */
    int getHandwritingConversionCandidateCostOffset();

    /**
     * <pre>
     * Threshold for suffix NWP transition cost.
     * If the transition cost is greater than this value, the candidate will be
     * filtered.
     * The candidate will not be filtered if this value is zero.
     * </pre>
     *
     * <code>optional int32 suffix_nwp_transition_cost_threshold = 107 [default = 0];</code>
     * @return Whether the suffixNwpTransitionCostThreshold field is set.
     */
    boolean hasSuffixNwpTransitionCostThreshold();
    /**
     * <pre>
     * Threshold for suffix NWP transition cost.
     * If the transition cost is greater than this value, the candidate will be
     * filtered.
     * The candidate will not be filtered if this value is zero.
     * </pre>
     *
     * <code>optional int32 suffix_nwp_transition_cost_threshold = 107 [default = 0];</code>
     * @return The suffixNwpTransitionCostThreshold.
     */
    int getSuffixNwpTransitionCostThreshold();

    /**
     * <pre>
     * Stores inner segment boundary in user history cache.
     * This information is going to be shared with user_segment_rewriter.
     * </pre>
     *
     * <code>optional bool user_history_cache_inner_segment_boundary = 135 [default = false];</code>
     * @return Whether the userHistoryCacheInnerSegmentBoundary field is set.
     */
    boolean hasUserHistoryCacheInnerSegmentBoundary();
    /**
     * <pre>
     * Stores inner segment boundary in user history cache.
     * This information is going to be shared with user_segment_rewriter.
     * </pre>
     *
     * <code>optional bool user_history_cache_inner_segment_boundary = 135 [default = false];</code>
     * @return The userHistoryCacheInnerSegmentBoundary.
     */
    boolean getUserHistoryCacheInnerSegmentBoundary();

    /**
     * <pre>
     * Position of the first symbol rewriter candidate (0-origin).
     * </pre>
     *
     * <code>optional int32 symbol_rewriter_candidate_position = 132 [default = 3];</code>
     * @return Whether the symbolRewriterCandidatePosition field is set.
     */
    boolean hasSymbolRewriterCandidatePosition();
    /**
     * <pre>
     * Position of the first symbol rewriter candidate (0-origin).
     * </pre>
     *
     * <code>optional int32 symbol_rewriter_candidate_position = 132 [default = 3];</code>
     * @return The symbolRewriterCandidatePosition.
     */
    int getSymbolRewriterCandidatePosition();

    /**
     * <pre>
     * Number of candidates to be promoted.
     * For example, if symbol_rewriter_candidate_position == 0, and
     * symbol_rewriter_promotion_size == 5, the first 5 candidates are symbols.
     * </pre>
     *
     * <code>optional int32 symbol_rewriter_promotion_size = 133 [default = 15];</code>
     * @return Whether the symbolRewriterPromotionSize field is set.
     */
    boolean hasSymbolRewriterPromotionSize();
    /**
     * <pre>
     * Number of candidates to be promoted.
     * For example, if symbol_rewriter_candidate_position == 0, and
     * symbol_rewriter_promotion_size == 5, the first 5 candidates are symbols.
     * </pre>
     *
     * <code>optional int32 symbol_rewriter_promotion_size = 133 [default = 15];</code>
     * @return The symbolRewriterPromotionSize.
     */
    int getSymbolRewriterPromotionSize();
  }
  /**
   * <pre>
   * Next ID: 140
   * Bundles together some Android experiment flags so that they can be easily
   * retrieved throughout the native code.  These flags are generally specific to
   * the decoder, and are made available when the decoder is initialized.
   * </pre>
   *
   * Protobuf type {@code mozc.commands.DecoderExperimentParams}
   */
  public  static final class DecoderExperimentParams extends
      com.google.protobuf.GeneratedMessageLite<
          DecoderExperimentParams, DecoderExperimentParams.Builder> implements
      // @@protoc_insertion_point(message_implements:mozc.commands.DecoderExperimentParams)
      DecoderExperimentParamsOrBuilder {
    private DecoderExperimentParams() {
      maxCompositionEventToProcess_ = 2;
      katakanaPromotionOffset_ = 5;
      handwritingConversionCandidateCostOffset_ = 1151;
      symbolRewriterCandidatePosition_ = 3;
      symbolRewriterPromotionSize_ = 15;
    }
    /**
     * Protobuf enum {@code mozc.commands.DecoderExperimentParams.VariationCharacterType}
     */
    public enum VariationCharacterType
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>NO_VARIATION = 0;</code>
       */
      NO_VARIATION(0),
      /**
       * <pre>
       * Standardized variation sequences for Japanese.
       * https://unicode.org/Public/UNIDATA/StandardizedVariants.txt
       * It specifies to use SVS characters instead of CJK compatibility
       * ideographs for Japanese.
       * </pre>
       *
       * <code>SVS_JAPANESE = 1;</code>
       */
      SVS_JAPANESE(1),
      ;

      /**
       * <code>NO_VARIATION = 0;</code>
       */
      public static final int NO_VARIATION_VALUE = 0;
      /**
       * <pre>
       * Standardized variation sequences for Japanese.
       * https://unicode.org/Public/UNIDATA/StandardizedVariants.txt
       * It specifies to use SVS characters instead of CJK compatibility
       * ideographs for Japanese.
       * </pre>
       *
       * <code>SVS_JAPANESE = 1;</code>
       */
      public static final int SVS_JAPANESE_VALUE = 1;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static VariationCharacterType valueOf(int value) {
        return forNumber(value);
      }

      public static VariationCharacterType forNumber(int value) {
        switch (value) {
          case 0: return NO_VARIATION;
          case 1: return SVS_JAPANESE;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<VariationCharacterType>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          VariationCharacterType> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<VariationCharacterType>() {
              @java.lang.Override
              public VariationCharacterType findValueByNumber(int number) {
                return VariationCharacterType.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return VariationCharacterTypeVerifier.INSTANCE;
      }

      private static final class VariationCharacterTypeVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new VariationCharacterTypeVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return VariationCharacterType.forNumber(number) != null;
              }
            };

      private final int value;

      private VariationCharacterType(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.commands.DecoderExperimentParams.VariationCharacterType)
    }

    /**
     * Protobuf enum {@code mozc.commands.DecoderExperimentParams.BigramNwpFilteringMode}
     */
    public enum BigramNwpFilteringMode
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <pre>
       * Control implementation is used. For example,
       * - Kanji + Katakana will not be filtered.
       * - If cost(prefix) &gt; cost(original_entry), the candidate will be filtered.
       * - The reading of the target candidate should be in the dictionary.
       * - ,etc
       * </pre>
       *
       * <code>DEFAULT = 0;</code>
       */
      DEFAULT(0),
      /**
       * <pre>
       * In addition to the default filtering, filter entry if the character
       * script type does not change from the prefix.
       * </pre>
       *
       * <code>FILTER_SAME_CTYPE = 1;</code>
       */
      FILTER_SAME_CTYPE(1),
      /**
       * <pre>
       * Filter all bigram candidates.
       * </pre>
       *
       * <code>FILTER_ALL = 2;</code>
       */
      FILTER_ALL(2),
      ;

      /**
       * <pre>
       * Control implementation is used. For example,
       * - Kanji + Katakana will not be filtered.
       * - If cost(prefix) &gt; cost(original_entry), the candidate will be filtered.
       * - The reading of the target candidate should be in the dictionary.
       * - ,etc
       * </pre>
       *
       * <code>DEFAULT = 0;</code>
       */
      public static final int DEFAULT_VALUE = 0;
      /**
       * <pre>
       * In addition to the default filtering, filter entry if the character
       * script type does not change from the prefix.
       * </pre>
       *
       * <code>FILTER_SAME_CTYPE = 1;</code>
       */
      public static final int FILTER_SAME_CTYPE_VALUE = 1;
      /**
       * <pre>
       * Filter all bigram candidates.
       * </pre>
       *
       * <code>FILTER_ALL = 2;</code>
       */
      public static final int FILTER_ALL_VALUE = 2;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static BigramNwpFilteringMode valueOf(int value) {
        return forNumber(value);
      }

      public static BigramNwpFilteringMode forNumber(int value) {
        switch (value) {
          case 0: return DEFAULT;
          case 1: return FILTER_SAME_CTYPE;
          case 2: return FILTER_ALL;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<BigramNwpFilteringMode>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          BigramNwpFilteringMode> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<BigramNwpFilteringMode>() {
              @java.lang.Override
              public BigramNwpFilteringMode findValueByNumber(int number) {
                return BigramNwpFilteringMode.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return BigramNwpFilteringModeVerifier.INSTANCE;
      }

      private static final class BigramNwpFilteringModeVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new BigramNwpFilteringModeVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return BigramNwpFilteringMode.forNumber(number) != null;
              }
            };

      private final int value;

      private BigramNwpFilteringMode(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.commands.DecoderExperimentParams.BigramNwpFilteringMode)
    }

    private int bitField0_;
    public static final int VARIATION_CHARACTER_TYPES_FIELD_NUMBER = 8;
    private int variationCharacterTypes_;
    /**
     * <pre>
     * Bitmap of enabled variation character types.
     * </pre>
     *
     * <code>optional uint32 variation_character_types = 8 [default = 0];</code>
     * @return Whether the variationCharacterTypes field is set.
     */
    @java.lang.Override
    public boolean hasVariationCharacterTypes() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Bitmap of enabled variation character types.
     * </pre>
     *
     * <code>optional uint32 variation_character_types = 8 [default = 0];</code>
     * @return The variationCharacterTypes.
     */
    @java.lang.Override
    public int getVariationCharacterTypes() {
      return variationCharacterTypes_;
    }
    /**
     * <pre>
     * Bitmap of enabled variation character types.
     * </pre>
     *
     * <code>optional uint32 variation_character_types = 8 [default = 0];</code>
     * @param value The variationCharacterTypes to set.
     */
    private void setVariationCharacterTypes(int value) {
      bitField0_ |= 0x00000001;
      variationCharacterTypes_ = value;
    }
    /**
     * <pre>
     * Bitmap of enabled variation character types.
     * </pre>
     *
     * <code>optional uint32 variation_character_types = 8 [default = 0];</code>
     */
    private void clearVariationCharacterTypes() {
      bitField0_ = (bitField0_ & ~0x00000001);
      variationCharacterTypes_ = 0;
    }

    public static final int TYPING_CORRECTION_RESULT_RERANKER_MODE_FIELD_NUMBER = 95;
    private int typingCorrectionResultRerankerMode_;
    /**
     * <pre>
     * Enables final results reranking against literal results.
     * If zero, the previous implementation is used.
     * </pre>
     *
     * <code>optional int32 typing_correction_result_reranker_mode = 95 [default = 0];</code>
     * @return Whether the typingCorrectionResultRerankerMode field is set.
     */
    @java.lang.Override
    public boolean hasTypingCorrectionResultRerankerMode() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Enables final results reranking against literal results.
     * If zero, the previous implementation is used.
     * </pre>
     *
     * <code>optional int32 typing_correction_result_reranker_mode = 95 [default = 0];</code>
     * @return The typingCorrectionResultRerankerMode.
     */
    @java.lang.Override
    public int getTypingCorrectionResultRerankerMode() {
      return typingCorrectionResultRerankerMode_;
    }
    /**
     * <pre>
     * Enables final results reranking against literal results.
     * If zero, the previous implementation is used.
     * </pre>
     *
     * <code>optional int32 typing_correction_result_reranker_mode = 95 [default = 0];</code>
     * @param value The typingCorrectionResultRerankerMode to set.
     */
    private void setTypingCorrectionResultRerankerMode(int value) {
      bitField0_ |= 0x00000002;
      typingCorrectionResultRerankerMode_ = value;
    }
    /**
     * <pre>
     * Enables final results reranking against literal results.
     * If zero, the previous implementation is used.
     * </pre>
     *
     * <code>optional int32 typing_correction_result_reranker_mode = 95 [default = 0];</code>
     */
    private void clearTypingCorrectionResultRerankerMode() {
      bitField0_ = (bitField0_ & ~0x00000002);
      typingCorrectionResultRerankerMode_ = 0;
    }

    public static final int TYPING_CORRECTION_RESULT_RERANKER_INTERPOLATION_WEIGHT_FIELD_NUMBER = 100;
    private float typingCorrectionResultRerankerInterpolationWeight_;
    /**
     * <pre>
     * Promote TC/Literal if w * tc_reranker_score + (1.0 - w) lm_diff &gt; 0.0.
     * </pre>
     *
     * <code>optional float typing_correction_result_reranker_interpolation_weight = 100 [default = 0];</code>
     * @return Whether the typingCorrectionResultRerankerInterpolationWeight field is set.
     */
    @java.lang.Override
    public boolean hasTypingCorrectionResultRerankerInterpolationWeight() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Promote TC/Literal if w * tc_reranker_score + (1.0 - w) lm_diff &gt; 0.0.
     * </pre>
     *
     * <code>optional float typing_correction_result_reranker_interpolation_weight = 100 [default = 0];</code>
     * @return The typingCorrectionResultRerankerInterpolationWeight.
     */
    @java.lang.Override
    public float getTypingCorrectionResultRerankerInterpolationWeight() {
      return typingCorrectionResultRerankerInterpolationWeight_;
    }
    /**
     * <pre>
     * Promote TC/Literal if w * tc_reranker_score + (1.0 - w) lm_diff &gt; 0.0.
     * </pre>
     *
     * <code>optional float typing_correction_result_reranker_interpolation_weight = 100 [default = 0];</code>
     * @param value The typingCorrectionResultRerankerInterpolationWeight to set.
     */
    private void setTypingCorrectionResultRerankerInterpolationWeight(float value) {
      bitField0_ |= 0x00000004;
      typingCorrectionResultRerankerInterpolationWeight_ = value;
    }
    /**
     * <pre>
     * Promote TC/Literal if w * tc_reranker_score + (1.0 - w) lm_diff &gt; 0.0.
     * </pre>
     *
     * <code>optional float typing_correction_result_reranker_interpolation_weight = 100 [default = 0];</code>
     */
    private void clearTypingCorrectionResultRerankerInterpolationWeight() {
      bitField0_ = (bitField0_ & ~0x00000004);
      typingCorrectionResultRerankerInterpolationWeight_ = 0F;
    }

    public static final int TYPING_CORRECTION_RESULT_RERANKER_LITERAL_ON_TOP_WEIGHT_FIELD_NUMBER = 101;
    private float typingCorrectionResultRerankerLiteralOnTopWeight_;
    /**
     * <pre>
     * Runs Literal-at-least second when original_tc_score + w * tc_reranker_score
     * &gt; 0.0. otherwise, runs literal-on-top.
     * </pre>
     *
     * <code>optional float typing_correction_result_reranker_literal_on_top_weight = 101 [default = 0];</code>
     * @return Whether the typingCorrectionResultRerankerLiteralOnTopWeight field is set.
     */
    @java.lang.Override
    public boolean hasTypingCorrectionResultRerankerLiteralOnTopWeight() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Runs Literal-at-least second when original_tc_score + w * tc_reranker_score
     * &gt; 0.0. otherwise, runs literal-on-top.
     * </pre>
     *
     * <code>optional float typing_correction_result_reranker_literal_on_top_weight = 101 [default = 0];</code>
     * @return The typingCorrectionResultRerankerLiteralOnTopWeight.
     */
    @java.lang.Override
    public float getTypingCorrectionResultRerankerLiteralOnTopWeight() {
      return typingCorrectionResultRerankerLiteralOnTopWeight_;
    }
    /**
     * <pre>
     * Runs Literal-at-least second when original_tc_score + w * tc_reranker_score
     * &gt; 0.0. otherwise, runs literal-on-top.
     * </pre>
     *
     * <code>optional float typing_correction_result_reranker_literal_on_top_weight = 101 [default = 0];</code>
     * @param value The typingCorrectionResultRerankerLiteralOnTopWeight to set.
     */
    private void setTypingCorrectionResultRerankerLiteralOnTopWeight(float value) {
      bitField0_ |= 0x00000008;
      typingCorrectionResultRerankerLiteralOnTopWeight_ = value;
    }
    /**
     * <pre>
     * Runs Literal-at-least second when original_tc_score + w * tc_reranker_score
     * &gt; 0.0. otherwise, runs literal-on-top.
     * </pre>
     *
     * <code>optional float typing_correction_result_reranker_literal_on_top_weight = 101 [default = 0];</code>
     */
    private void clearTypingCorrectionResultRerankerLiteralOnTopWeight() {
      bitField0_ = (bitField0_ & ~0x00000008);
      typingCorrectionResultRerankerLiteralOnTopWeight_ = 0F;
    }

    public static final int TYPING_CORRECTION_APPLY_USER_HISTORY_SIZE_FIELD_NUMBER = 85;
    private int typingCorrectionApplyUserHistorySize_;
    /**
     * <pre>
     * Uses the typing correction in user history predictor. The size specifies
     * the maximum number of typing corrections used for query lookup.
     * When zero, typing_correction is not used.
     * </pre>
     *
     * <code>optional int32 typing_correction_apply_user_history_size = 85 [default = 0];</code>
     * @return Whether the typingCorrectionApplyUserHistorySize field is set.
     */
    @java.lang.Override
    public boolean hasTypingCorrectionApplyUserHistorySize() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Uses the typing correction in user history predictor. The size specifies
     * the maximum number of typing corrections used for query lookup.
     * When zero, typing_correction is not used.
     * </pre>
     *
     * <code>optional int32 typing_correction_apply_user_history_size = 85 [default = 0];</code>
     * @return The typingCorrectionApplyUserHistorySize.
     */
    @java.lang.Override
    public int getTypingCorrectionApplyUserHistorySize() {
      return typingCorrectionApplyUserHistorySize_;
    }
    /**
     * <pre>
     * Uses the typing correction in user history predictor. The size specifies
     * the maximum number of typing corrections used for query lookup.
     * When zero, typing_correction is not used.
     * </pre>
     *
     * <code>optional int32 typing_correction_apply_user_history_size = 85 [default = 0];</code>
     * @param value The typingCorrectionApplyUserHistorySize to set.
     */
    private void setTypingCorrectionApplyUserHistorySize(int value) {
      bitField0_ |= 0x00000010;
      typingCorrectionApplyUserHistorySize_ = value;
    }
    /**
     * <pre>
     * Uses the typing correction in user history predictor. The size specifies
     * the maximum number of typing corrections used for query lookup.
     * When zero, typing_correction is not used.
     * </pre>
     *
     * <code>optional int32 typing_correction_apply_user_history_size = 85 [default = 0];</code>
     */
    private void clearTypingCorrectionApplyUserHistorySize() {
      bitField0_ = (bitField0_ & ~0x00000010);
      typingCorrectionApplyUserHistorySize_ = 0;
    }

    public static final int DISABLE_ZERO_QUERY_SUFFIX_PREDICTION_FIELD_NUMBER = 36;
    private boolean disableZeroQuerySuffixPrediction_;
    /**
     * <code>optional bool disable_zero_query_suffix_prediction = 36 [default = false];</code>
     * @return Whether the disableZeroQuerySuffixPrediction field is set.
     */
    @java.lang.Override
    public boolean hasDisableZeroQuerySuffixPrediction() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <code>optional bool disable_zero_query_suffix_prediction = 36 [default = false];</code>
     * @return The disableZeroQuerySuffixPrediction.
     */
    @java.lang.Override
    public boolean getDisableZeroQuerySuffixPrediction() {
      return disableZeroQuerySuffixPrediction_;
    }
    /**
     * <code>optional bool disable_zero_query_suffix_prediction = 36 [default = false];</code>
     * @param value The disableZeroQuerySuffixPrediction to set.
     */
    private void setDisableZeroQuerySuffixPrediction(boolean value) {
      bitField0_ |= 0x00000020;
      disableZeroQuerySuffixPrediction_ = value;
    }
    /**
     * <code>optional bool disable_zero_query_suffix_prediction = 36 [default = false];</code>
     */
    private void clearDisableZeroQuerySuffixPrediction() {
      bitField0_ = (bitField0_ & ~0x00000020);
      disableZeroQuerySuffixPrediction_ = false;
    }

    public static final int USER_HISTORY_PREDICTION_MAX_CHAR_COVERAGE_FIELD_NUMBER = 82;
    private int userHistoryPredictionMaxCharCoverage_;
    /**
     * <pre>
     * Changes the size of history with character coverage.
     * </pre>
     *
     * <code>optional int32 user_history_prediction_max_char_coverage = 82 [default = 0];</code>
     * @return Whether the userHistoryPredictionMaxCharCoverage field is set.
     */
    @java.lang.Override
    public boolean hasUserHistoryPredictionMaxCharCoverage() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * Changes the size of history with character coverage.
     * </pre>
     *
     * <code>optional int32 user_history_prediction_max_char_coverage = 82 [default = 0];</code>
     * @return The userHistoryPredictionMaxCharCoverage.
     */
    @java.lang.Override
    public int getUserHistoryPredictionMaxCharCoverage() {
      return userHistoryPredictionMaxCharCoverage_;
    }
    /**
     * <pre>
     * Changes the size of history with character coverage.
     * </pre>
     *
     * <code>optional int32 user_history_prediction_max_char_coverage = 82 [default = 0];</code>
     * @param value The userHistoryPredictionMaxCharCoverage to set.
     */
    private void setUserHistoryPredictionMaxCharCoverage(int value) {
      bitField0_ |= 0x00000040;
      userHistoryPredictionMaxCharCoverage_ = value;
    }
    /**
     * <pre>
     * Changes the size of history with character coverage.
     * </pre>
     *
     * <code>optional int32 user_history_prediction_max_char_coverage = 82 [default = 0];</code>
     */
    private void clearUserHistoryPredictionMaxCharCoverage() {
      bitField0_ = (bitField0_ & ~0x00000040);
      userHistoryPredictionMaxCharCoverage_ = 0;
    }

    public static final int ENGLISH_VARIATION_SPACE_INSERTION_MODE_FIELD_NUMBER = 55;
    private int englishVariationSpaceInsertionMode_;
    /**
     * <pre>
     * Parameter for space-insertion for English compounds
     * value 0: no insertion. Candidates will be like this.
     * - "Google"
     * - "GOOGLE"
     * - "google"
     * value 1: expand for all English candidates
     * This mode adds space-prefixed candidates for three style, like this.
     * - "Google"
     * - " Google"
     * - "GOOGLE"
     * - " GOOGLE"
     * - "google"
     * - " google"
     * </pre>
     *
     * <code>optional int32 english_variation_space_insertion_mode = 55 [default = 0];</code>
     * @return Whether the englishVariationSpaceInsertionMode field is set.
     */
    @java.lang.Override
    public boolean hasEnglishVariationSpaceInsertionMode() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * Parameter for space-insertion for English compounds
     * value 0: no insertion. Candidates will be like this.
     * - "Google"
     * - "GOOGLE"
     * - "google"
     * value 1: expand for all English candidates
     * This mode adds space-prefixed candidates for three style, like this.
     * - "Google"
     * - " Google"
     * - "GOOGLE"
     * - " GOOGLE"
     * - "google"
     * - " google"
     * </pre>
     *
     * <code>optional int32 english_variation_space_insertion_mode = 55 [default = 0];</code>
     * @return The englishVariationSpaceInsertionMode.
     */
    @java.lang.Override
    public int getEnglishVariationSpaceInsertionMode() {
      return englishVariationSpaceInsertionMode_;
    }
    /**
     * <pre>
     * Parameter for space-insertion for English compounds
     * value 0: no insertion. Candidates will be like this.
     * - "Google"
     * - "GOOGLE"
     * - "google"
     * value 1: expand for all English candidates
     * This mode adds space-prefixed candidates for three style, like this.
     * - "Google"
     * - " Google"
     * - "GOOGLE"
     * - " GOOGLE"
     * - "google"
     * - " google"
     * </pre>
     *
     * <code>optional int32 english_variation_space_insertion_mode = 55 [default = 0];</code>
     * @param value The englishVariationSpaceInsertionMode to set.
     */
    private void setEnglishVariationSpaceInsertionMode(int value) {
      bitField0_ |= 0x00000080;
      englishVariationSpaceInsertionMode_ = value;
    }
    /**
     * <pre>
     * Parameter for space-insertion for English compounds
     * value 0: no insertion. Candidates will be like this.
     * - "Google"
     * - "GOOGLE"
     * - "google"
     * value 1: expand for all English candidates
     * This mode adds space-prefixed candidates for three style, like this.
     * - "Google"
     * - " Google"
     * - "GOOGLE"
     * - " GOOGLE"
     * - "google"
     * - " google"
     * </pre>
     *
     * <code>optional int32 english_variation_space_insertion_mode = 55 [default = 0];</code>
     */
    private void clearEnglishVariationSpaceInsertionMode() {
      bitField0_ = (bitField0_ & ~0x00000080);
      englishVariationSpaceInsertionMode_ = 0;
    }

    public static final int CANDIDATE_CONSISTENCY_COST_MAX_DIFF_FIELD_NUMBER = 63;
    private int candidateConsistencyCostMaxDiff_;
    /**
     * <code>optional int32 candidate_consistency_cost_max_diff = 63 [default = 0];</code>
     * @return Whether the candidateConsistencyCostMaxDiff field is set.
     */
    @java.lang.Override
    public boolean hasCandidateConsistencyCostMaxDiff() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <code>optional int32 candidate_consistency_cost_max_diff = 63 [default = 0];</code>
     * @return The candidateConsistencyCostMaxDiff.
     */
    @java.lang.Override
    public int getCandidateConsistencyCostMaxDiff() {
      return candidateConsistencyCostMaxDiff_;
    }
    /**
     * <code>optional int32 candidate_consistency_cost_max_diff = 63 [default = 0];</code>
     * @param value The candidateConsistencyCostMaxDiff to set.
     */
    private void setCandidateConsistencyCostMaxDiff(int value) {
      bitField0_ |= 0x00000100;
      candidateConsistencyCostMaxDiff_ = value;
    }
    /**
     * <code>optional int32 candidate_consistency_cost_max_diff = 63 [default = 0];</code>
     */
    private void clearCandidateConsistencyCostMaxDiff() {
      bitField0_ = (bitField0_ & ~0x00000100);
      candidateConsistencyCostMaxDiff_ = 0;
    }

    public static final int MAX_COMPOSITION_EVENT_TO_PROCESS_FIELD_NUMBER = 64;
    private int maxCompositionEventToProcess_;
    /**
     * <code>optional int32 max_composition_event_to_process = 64 [default = 2];</code>
     * @return Whether the maxCompositionEventToProcess field is set.
     */
    @java.lang.Override
    public boolean hasMaxCompositionEventToProcess() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <code>optional int32 max_composition_event_to_process = 64 [default = 2];</code>
     * @return The maxCompositionEventToProcess.
     */
    @java.lang.Override
    public int getMaxCompositionEventToProcess() {
      return maxCompositionEventToProcess_;
    }
    /**
     * <code>optional int32 max_composition_event_to_process = 64 [default = 2];</code>
     * @param value The maxCompositionEventToProcess to set.
     */
    private void setMaxCompositionEventToProcess(int value) {
      bitField0_ |= 0x00000200;
      maxCompositionEventToProcess_ = value;
    }
    /**
     * <code>optional int32 max_composition_event_to_process = 64 [default = 2];</code>
     */
    private void clearMaxCompositionEventToProcess() {
      bitField0_ = (bitField0_ & ~0x00000200);
      maxCompositionEventToProcess_ = 2;
    }

    public static final int KATAKANA_PROMOTION_OFFSET_FIELD_NUMBER = 83;
    private int katakanaPromotionOffset_;
    /**
     * <pre>
     * Offset to promote Katakana candidates in rewriter.
     * The promotion will be disabled if the value is negative.
     * </pre>
     *
     * <code>optional int32 katakana_promotion_offset = 83 [default = 5];</code>
     * @return Whether the katakanaPromotionOffset field is set.
     */
    @java.lang.Override
    public boolean hasKatakanaPromotionOffset() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     * <pre>
     * Offset to promote Katakana candidates in rewriter.
     * The promotion will be disabled if the value is negative.
     * </pre>
     *
     * <code>optional int32 katakana_promotion_offset = 83 [default = 5];</code>
     * @return The katakanaPromotionOffset.
     */
    @java.lang.Override
    public int getKatakanaPromotionOffset() {
      return katakanaPromotionOffset_;
    }
    /**
     * <pre>
     * Offset to promote Katakana candidates in rewriter.
     * The promotion will be disabled if the value is negative.
     * </pre>
     *
     * <code>optional int32 katakana_promotion_offset = 83 [default = 5];</code>
     * @param value The katakanaPromotionOffset to set.
     */
    private void setKatakanaPromotionOffset(int value) {
      bitField0_ |= 0x00000400;
      katakanaPromotionOffset_ = value;
    }
    /**
     * <pre>
     * Offset to promote Katakana candidates in rewriter.
     * The promotion will be disabled if the value is negative.
     * </pre>
     *
     * <code>optional int32 katakana_promotion_offset = 83 [default = 5];</code>
     */
    private void clearKatakanaPromotionOffset() {
      bitField0_ = (bitField0_ & ~0x00000400);
      katakanaPromotionOffset_ = 5;
    }

    public static final int HANDWRITING_CONVERSION_CANDIDATE_COST_OFFSET_FIELD_NUMBER = 102;
    private int handwritingConversionCandidateCostOffset_;
    /**
     * <pre>
     * Cost offset for handwriting conversion candidate.
     * default_value: 10*log(500)
     * </pre>
     *
     * <code>optional int32 handwriting_conversion_candidate_cost_offset = 102 [default = 1151];</code>
     * @return Whether the handwritingConversionCandidateCostOffset field is set.
     */
    @java.lang.Override
    public boolean hasHandwritingConversionCandidateCostOffset() {
      return ((bitField0_ & 0x00000800) != 0);
    }
    /**
     * <pre>
     * Cost offset for handwriting conversion candidate.
     * default_value: 10*log(500)
     * </pre>
     *
     * <code>optional int32 handwriting_conversion_candidate_cost_offset = 102 [default = 1151];</code>
     * @return The handwritingConversionCandidateCostOffset.
     */
    @java.lang.Override
    public int getHandwritingConversionCandidateCostOffset() {
      return handwritingConversionCandidateCostOffset_;
    }
    /**
     * <pre>
     * Cost offset for handwriting conversion candidate.
     * default_value: 10*log(500)
     * </pre>
     *
     * <code>optional int32 handwriting_conversion_candidate_cost_offset = 102 [default = 1151];</code>
     * @param value The handwritingConversionCandidateCostOffset to set.
     */
    private void setHandwritingConversionCandidateCostOffset(int value) {
      bitField0_ |= 0x00000800;
      handwritingConversionCandidateCostOffset_ = value;
    }
    /**
     * <pre>
     * Cost offset for handwriting conversion candidate.
     * default_value: 10*log(500)
     * </pre>
     *
     * <code>optional int32 handwriting_conversion_candidate_cost_offset = 102 [default = 1151];</code>
     */
    private void clearHandwritingConversionCandidateCostOffset() {
      bitField0_ = (bitField0_ & ~0x00000800);
      handwritingConversionCandidateCostOffset_ = 1151;
    }

    public static final int SUFFIX_NWP_TRANSITION_COST_THRESHOLD_FIELD_NUMBER = 107;
    private int suffixNwpTransitionCostThreshold_;
    /**
     * <pre>
     * Threshold for suffix NWP transition cost.
     * If the transition cost is greater than this value, the candidate will be
     * filtered.
     * The candidate will not be filtered if this value is zero.
     * </pre>
     *
     * <code>optional int32 suffix_nwp_transition_cost_threshold = 107 [default = 0];</code>
     * @return Whether the suffixNwpTransitionCostThreshold field is set.
     */
    @java.lang.Override
    public boolean hasSuffixNwpTransitionCostThreshold() {
      return ((bitField0_ & 0x00001000) != 0);
    }
    /**
     * <pre>
     * Threshold for suffix NWP transition cost.
     * If the transition cost is greater than this value, the candidate will be
     * filtered.
     * The candidate will not be filtered if this value is zero.
     * </pre>
     *
     * <code>optional int32 suffix_nwp_transition_cost_threshold = 107 [default = 0];</code>
     * @return The suffixNwpTransitionCostThreshold.
     */
    @java.lang.Override
    public int getSuffixNwpTransitionCostThreshold() {
      return suffixNwpTransitionCostThreshold_;
    }
    /**
     * <pre>
     * Threshold for suffix NWP transition cost.
     * If the transition cost is greater than this value, the candidate will be
     * filtered.
     * The candidate will not be filtered if this value is zero.
     * </pre>
     *
     * <code>optional int32 suffix_nwp_transition_cost_threshold = 107 [default = 0];</code>
     * @param value The suffixNwpTransitionCostThreshold to set.
     */
    private void setSuffixNwpTransitionCostThreshold(int value) {
      bitField0_ |= 0x00001000;
      suffixNwpTransitionCostThreshold_ = value;
    }
    /**
     * <pre>
     * Threshold for suffix NWP transition cost.
     * If the transition cost is greater than this value, the candidate will be
     * filtered.
     * The candidate will not be filtered if this value is zero.
     * </pre>
     *
     * <code>optional int32 suffix_nwp_transition_cost_threshold = 107 [default = 0];</code>
     */
    private void clearSuffixNwpTransitionCostThreshold() {
      bitField0_ = (bitField0_ & ~0x00001000);
      suffixNwpTransitionCostThreshold_ = 0;
    }

    public static final int USER_HISTORY_CACHE_INNER_SEGMENT_BOUNDARY_FIELD_NUMBER = 135;
    private boolean userHistoryCacheInnerSegmentBoundary_;
    /**
     * <pre>
     * Stores inner segment boundary in user history cache.
     * This information is going to be shared with user_segment_rewriter.
     * </pre>
     *
     * <code>optional bool user_history_cache_inner_segment_boundary = 135 [default = false];</code>
     * @return Whether the userHistoryCacheInnerSegmentBoundary field is set.
     */
    @java.lang.Override
    public boolean hasUserHistoryCacheInnerSegmentBoundary() {
      return ((bitField0_ & 0x00002000) != 0);
    }
    /**
     * <pre>
     * Stores inner segment boundary in user history cache.
     * This information is going to be shared with user_segment_rewriter.
     * </pre>
     *
     * <code>optional bool user_history_cache_inner_segment_boundary = 135 [default = false];</code>
     * @return The userHistoryCacheInnerSegmentBoundary.
     */
    @java.lang.Override
    public boolean getUserHistoryCacheInnerSegmentBoundary() {
      return userHistoryCacheInnerSegmentBoundary_;
    }
    /**
     * <pre>
     * Stores inner segment boundary in user history cache.
     * This information is going to be shared with user_segment_rewriter.
     * </pre>
     *
     * <code>optional bool user_history_cache_inner_segment_boundary = 135 [default = false];</code>
     * @param value The userHistoryCacheInnerSegmentBoundary to set.
     */
    private void setUserHistoryCacheInnerSegmentBoundary(boolean value) {
      bitField0_ |= 0x00002000;
      userHistoryCacheInnerSegmentBoundary_ = value;
    }
    /**
     * <pre>
     * Stores inner segment boundary in user history cache.
     * This information is going to be shared with user_segment_rewriter.
     * </pre>
     *
     * <code>optional bool user_history_cache_inner_segment_boundary = 135 [default = false];</code>
     */
    private void clearUserHistoryCacheInnerSegmentBoundary() {
      bitField0_ = (bitField0_ & ~0x00002000);
      userHistoryCacheInnerSegmentBoundary_ = false;
    }

    public static final int SYMBOL_REWRITER_CANDIDATE_POSITION_FIELD_NUMBER = 132;
    private int symbolRewriterCandidatePosition_;
    /**
     * <pre>
     * Position of the first symbol rewriter candidate (0-origin).
     * </pre>
     *
     * <code>optional int32 symbol_rewriter_candidate_position = 132 [default = 3];</code>
     * @return Whether the symbolRewriterCandidatePosition field is set.
     */
    @java.lang.Override
    public boolean hasSymbolRewriterCandidatePosition() {
      return ((bitField0_ & 0x00004000) != 0);
    }
    /**
     * <pre>
     * Position of the first symbol rewriter candidate (0-origin).
     * </pre>
     *
     * <code>optional int32 symbol_rewriter_candidate_position = 132 [default = 3];</code>
     * @return The symbolRewriterCandidatePosition.
     */
    @java.lang.Override
    public int getSymbolRewriterCandidatePosition() {
      return symbolRewriterCandidatePosition_;
    }
    /**
     * <pre>
     * Position of the first symbol rewriter candidate (0-origin).
     * </pre>
     *
     * <code>optional int32 symbol_rewriter_candidate_position = 132 [default = 3];</code>
     * @param value The symbolRewriterCandidatePosition to set.
     */
    private void setSymbolRewriterCandidatePosition(int value) {
      bitField0_ |= 0x00004000;
      symbolRewriterCandidatePosition_ = value;
    }
    /**
     * <pre>
     * Position of the first symbol rewriter candidate (0-origin).
     * </pre>
     *
     * <code>optional int32 symbol_rewriter_candidate_position = 132 [default = 3];</code>
     */
    private void clearSymbolRewriterCandidatePosition() {
      bitField0_ = (bitField0_ & ~0x00004000);
      symbolRewriterCandidatePosition_ = 3;
    }

    public static final int SYMBOL_REWRITER_PROMOTION_SIZE_FIELD_NUMBER = 133;
    private int symbolRewriterPromotionSize_;
    /**
     * <pre>
     * Number of candidates to be promoted.
     * For example, if symbol_rewriter_candidate_position == 0, and
     * symbol_rewriter_promotion_size == 5, the first 5 candidates are symbols.
     * </pre>
     *
     * <code>optional int32 symbol_rewriter_promotion_size = 133 [default = 15];</code>
     * @return Whether the symbolRewriterPromotionSize field is set.
     */
    @java.lang.Override
    public boolean hasSymbolRewriterPromotionSize() {
      return ((bitField0_ & 0x00008000) != 0);
    }
    /**
     * <pre>
     * Number of candidates to be promoted.
     * For example, if symbol_rewriter_candidate_position == 0, and
     * symbol_rewriter_promotion_size == 5, the first 5 candidates are symbols.
     * </pre>
     *
     * <code>optional int32 symbol_rewriter_promotion_size = 133 [default = 15];</code>
     * @return The symbolRewriterPromotionSize.
     */
    @java.lang.Override
    public int getSymbolRewriterPromotionSize() {
      return symbolRewriterPromotionSize_;
    }
    /**
     * <pre>
     * Number of candidates to be promoted.
     * For example, if symbol_rewriter_candidate_position == 0, and
     * symbol_rewriter_promotion_size == 5, the first 5 candidates are symbols.
     * </pre>
     *
     * <code>optional int32 symbol_rewriter_promotion_size = 133 [default = 15];</code>
     * @param value The symbolRewriterPromotionSize to set.
     */
    private void setSymbolRewriterPromotionSize(int value) {
      bitField0_ |= 0x00008000;
      symbolRewriterPromotionSize_ = value;
    }
    /**
     * <pre>
     * Number of candidates to be promoted.
     * For example, if symbol_rewriter_candidate_position == 0, and
     * symbol_rewriter_promotion_size == 5, the first 5 candidates are symbols.
     * </pre>
     *
     * <code>optional int32 symbol_rewriter_promotion_size = 133 [default = 15];</code>
     */
    private void clearSymbolRewriterPromotionSize() {
      bitField0_ = (bitField0_ & ~0x00008000);
      symbolRewriterPromotionSize_ = 15;
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Next ID: 140
     * Bundles together some Android experiment flags so that they can be easily
     * retrieved throughout the native code.  These flags are generally specific to
     * the decoder, and are made available when the decoder is initialized.
     * </pre>
     *
     * Protobuf type {@code mozc.commands.DecoderExperimentParams}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams, Builder> implements
        // @@protoc_insertion_point(builder_implements:mozc.commands.DecoderExperimentParams)
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParamsOrBuilder {
      // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Bitmap of enabled variation character types.
       * </pre>
       *
       * <code>optional uint32 variation_character_types = 8 [default = 0];</code>
       * @return Whether the variationCharacterTypes field is set.
       */
      @java.lang.Override
      public boolean hasVariationCharacterTypes() {
        return instance.hasVariationCharacterTypes();
      }
      /**
       * <pre>
       * Bitmap of enabled variation character types.
       * </pre>
       *
       * <code>optional uint32 variation_character_types = 8 [default = 0];</code>
       * @return The variationCharacterTypes.
       */
      @java.lang.Override
      public int getVariationCharacterTypes() {
        return instance.getVariationCharacterTypes();
      }
      /**
       * <pre>
       * Bitmap of enabled variation character types.
       * </pre>
       *
       * <code>optional uint32 variation_character_types = 8 [default = 0];</code>
       * @param value The variationCharacterTypes to set.
       * @return This builder for chaining.
       */
      public Builder setVariationCharacterTypes(int value) {
        copyOnWrite();
        instance.setVariationCharacterTypes(value);
        return this;
      }
      /**
       * <pre>
       * Bitmap of enabled variation character types.
       * </pre>
       *
       * <code>optional uint32 variation_character_types = 8 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearVariationCharacterTypes() {
        copyOnWrite();
        instance.clearVariationCharacterTypes();
        return this;
      }

      /**
       * <pre>
       * Enables final results reranking against literal results.
       * If zero, the previous implementation is used.
       * </pre>
       *
       * <code>optional int32 typing_correction_result_reranker_mode = 95 [default = 0];</code>
       * @return Whether the typingCorrectionResultRerankerMode field is set.
       */
      @java.lang.Override
      public boolean hasTypingCorrectionResultRerankerMode() {
        return instance.hasTypingCorrectionResultRerankerMode();
      }
      /**
       * <pre>
       * Enables final results reranking against literal results.
       * If zero, the previous implementation is used.
       * </pre>
       *
       * <code>optional int32 typing_correction_result_reranker_mode = 95 [default = 0];</code>
       * @return The typingCorrectionResultRerankerMode.
       */
      @java.lang.Override
      public int getTypingCorrectionResultRerankerMode() {
        return instance.getTypingCorrectionResultRerankerMode();
      }
      /**
       * <pre>
       * Enables final results reranking against literal results.
       * If zero, the previous implementation is used.
       * </pre>
       *
       * <code>optional int32 typing_correction_result_reranker_mode = 95 [default = 0];</code>
       * @param value The typingCorrectionResultRerankerMode to set.
       * @return This builder for chaining.
       */
      public Builder setTypingCorrectionResultRerankerMode(int value) {
        copyOnWrite();
        instance.setTypingCorrectionResultRerankerMode(value);
        return this;
      }
      /**
       * <pre>
       * Enables final results reranking against literal results.
       * If zero, the previous implementation is used.
       * </pre>
       *
       * <code>optional int32 typing_correction_result_reranker_mode = 95 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearTypingCorrectionResultRerankerMode() {
        copyOnWrite();
        instance.clearTypingCorrectionResultRerankerMode();
        return this;
      }

      /**
       * <pre>
       * Promote TC/Literal if w * tc_reranker_score + (1.0 - w) lm_diff &gt; 0.0.
       * </pre>
       *
       * <code>optional float typing_correction_result_reranker_interpolation_weight = 100 [default = 0];</code>
       * @return Whether the typingCorrectionResultRerankerInterpolationWeight field is set.
       */
      @java.lang.Override
      public boolean hasTypingCorrectionResultRerankerInterpolationWeight() {
        return instance.hasTypingCorrectionResultRerankerInterpolationWeight();
      }
      /**
       * <pre>
       * Promote TC/Literal if w * tc_reranker_score + (1.0 - w) lm_diff &gt; 0.0.
       * </pre>
       *
       * <code>optional float typing_correction_result_reranker_interpolation_weight = 100 [default = 0];</code>
       * @return The typingCorrectionResultRerankerInterpolationWeight.
       */
      @java.lang.Override
      public float getTypingCorrectionResultRerankerInterpolationWeight() {
        return instance.getTypingCorrectionResultRerankerInterpolationWeight();
      }
      /**
       * <pre>
       * Promote TC/Literal if w * tc_reranker_score + (1.0 - w) lm_diff &gt; 0.0.
       * </pre>
       *
       * <code>optional float typing_correction_result_reranker_interpolation_weight = 100 [default = 0];</code>
       * @param value The typingCorrectionResultRerankerInterpolationWeight to set.
       * @return This builder for chaining.
       */
      public Builder setTypingCorrectionResultRerankerInterpolationWeight(float value) {
        copyOnWrite();
        instance.setTypingCorrectionResultRerankerInterpolationWeight(value);
        return this;
      }
      /**
       * <pre>
       * Promote TC/Literal if w * tc_reranker_score + (1.0 - w) lm_diff &gt; 0.0.
       * </pre>
       *
       * <code>optional float typing_correction_result_reranker_interpolation_weight = 100 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearTypingCorrectionResultRerankerInterpolationWeight() {
        copyOnWrite();
        instance.clearTypingCorrectionResultRerankerInterpolationWeight();
        return this;
      }

      /**
       * <pre>
       * Runs Literal-at-least second when original_tc_score + w * tc_reranker_score
       * &gt; 0.0. otherwise, runs literal-on-top.
       * </pre>
       *
       * <code>optional float typing_correction_result_reranker_literal_on_top_weight = 101 [default = 0];</code>
       * @return Whether the typingCorrectionResultRerankerLiteralOnTopWeight field is set.
       */
      @java.lang.Override
      public boolean hasTypingCorrectionResultRerankerLiteralOnTopWeight() {
        return instance.hasTypingCorrectionResultRerankerLiteralOnTopWeight();
      }
      /**
       * <pre>
       * Runs Literal-at-least second when original_tc_score + w * tc_reranker_score
       * &gt; 0.0. otherwise, runs literal-on-top.
       * </pre>
       *
       * <code>optional float typing_correction_result_reranker_literal_on_top_weight = 101 [default = 0];</code>
       * @return The typingCorrectionResultRerankerLiteralOnTopWeight.
       */
      @java.lang.Override
      public float getTypingCorrectionResultRerankerLiteralOnTopWeight() {
        return instance.getTypingCorrectionResultRerankerLiteralOnTopWeight();
      }
      /**
       * <pre>
       * Runs Literal-at-least second when original_tc_score + w * tc_reranker_score
       * &gt; 0.0. otherwise, runs literal-on-top.
       * </pre>
       *
       * <code>optional float typing_correction_result_reranker_literal_on_top_weight = 101 [default = 0];</code>
       * @param value The typingCorrectionResultRerankerLiteralOnTopWeight to set.
       * @return This builder for chaining.
       */
      public Builder setTypingCorrectionResultRerankerLiteralOnTopWeight(float value) {
        copyOnWrite();
        instance.setTypingCorrectionResultRerankerLiteralOnTopWeight(value);
        return this;
      }
      /**
       * <pre>
       * Runs Literal-at-least second when original_tc_score + w * tc_reranker_score
       * &gt; 0.0. otherwise, runs literal-on-top.
       * </pre>
       *
       * <code>optional float typing_correction_result_reranker_literal_on_top_weight = 101 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearTypingCorrectionResultRerankerLiteralOnTopWeight() {
        copyOnWrite();
        instance.clearTypingCorrectionResultRerankerLiteralOnTopWeight();
        return this;
      }

      /**
       * <pre>
       * Uses the typing correction in user history predictor. The size specifies
       * the maximum number of typing corrections used for query lookup.
       * When zero, typing_correction is not used.
       * </pre>
       *
       * <code>optional int32 typing_correction_apply_user_history_size = 85 [default = 0];</code>
       * @return Whether the typingCorrectionApplyUserHistorySize field is set.
       */
      @java.lang.Override
      public boolean hasTypingCorrectionApplyUserHistorySize() {
        return instance.hasTypingCorrectionApplyUserHistorySize();
      }
      /**
       * <pre>
       * Uses the typing correction in user history predictor. The size specifies
       * the maximum number of typing corrections used for query lookup.
       * When zero, typing_correction is not used.
       * </pre>
       *
       * <code>optional int32 typing_correction_apply_user_history_size = 85 [default = 0];</code>
       * @return The typingCorrectionApplyUserHistorySize.
       */
      @java.lang.Override
      public int getTypingCorrectionApplyUserHistorySize() {
        return instance.getTypingCorrectionApplyUserHistorySize();
      }
      /**
       * <pre>
       * Uses the typing correction in user history predictor. The size specifies
       * the maximum number of typing corrections used for query lookup.
       * When zero, typing_correction is not used.
       * </pre>
       *
       * <code>optional int32 typing_correction_apply_user_history_size = 85 [default = 0];</code>
       * @param value The typingCorrectionApplyUserHistorySize to set.
       * @return This builder for chaining.
       */
      public Builder setTypingCorrectionApplyUserHistorySize(int value) {
        copyOnWrite();
        instance.setTypingCorrectionApplyUserHistorySize(value);
        return this;
      }
      /**
       * <pre>
       * Uses the typing correction in user history predictor. The size specifies
       * the maximum number of typing corrections used for query lookup.
       * When zero, typing_correction is not used.
       * </pre>
       *
       * <code>optional int32 typing_correction_apply_user_history_size = 85 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearTypingCorrectionApplyUserHistorySize() {
        copyOnWrite();
        instance.clearTypingCorrectionApplyUserHistorySize();
        return this;
      }

      /**
       * <code>optional bool disable_zero_query_suffix_prediction = 36 [default = false];</code>
       * @return Whether the disableZeroQuerySuffixPrediction field is set.
       */
      @java.lang.Override
      public boolean hasDisableZeroQuerySuffixPrediction() {
        return instance.hasDisableZeroQuerySuffixPrediction();
      }
      /**
       * <code>optional bool disable_zero_query_suffix_prediction = 36 [default = false];</code>
       * @return The disableZeroQuerySuffixPrediction.
       */
      @java.lang.Override
      public boolean getDisableZeroQuerySuffixPrediction() {
        return instance.getDisableZeroQuerySuffixPrediction();
      }
      /**
       * <code>optional bool disable_zero_query_suffix_prediction = 36 [default = false];</code>
       * @param value The disableZeroQuerySuffixPrediction to set.
       * @return This builder for chaining.
       */
      public Builder setDisableZeroQuerySuffixPrediction(boolean value) {
        copyOnWrite();
        instance.setDisableZeroQuerySuffixPrediction(value);
        return this;
      }
      /**
       * <code>optional bool disable_zero_query_suffix_prediction = 36 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearDisableZeroQuerySuffixPrediction() {
        copyOnWrite();
        instance.clearDisableZeroQuerySuffixPrediction();
        return this;
      }

      /**
       * <pre>
       * Changes the size of history with character coverage.
       * </pre>
       *
       * <code>optional int32 user_history_prediction_max_char_coverage = 82 [default = 0];</code>
       * @return Whether the userHistoryPredictionMaxCharCoverage field is set.
       */
      @java.lang.Override
      public boolean hasUserHistoryPredictionMaxCharCoverage() {
        return instance.hasUserHistoryPredictionMaxCharCoverage();
      }
      /**
       * <pre>
       * Changes the size of history with character coverage.
       * </pre>
       *
       * <code>optional int32 user_history_prediction_max_char_coverage = 82 [default = 0];</code>
       * @return The userHistoryPredictionMaxCharCoverage.
       */
      @java.lang.Override
      public int getUserHistoryPredictionMaxCharCoverage() {
        return instance.getUserHistoryPredictionMaxCharCoverage();
      }
      /**
       * <pre>
       * Changes the size of history with character coverage.
       * </pre>
       *
       * <code>optional int32 user_history_prediction_max_char_coverage = 82 [default = 0];</code>
       * @param value The userHistoryPredictionMaxCharCoverage to set.
       * @return This builder for chaining.
       */
      public Builder setUserHistoryPredictionMaxCharCoverage(int value) {
        copyOnWrite();
        instance.setUserHistoryPredictionMaxCharCoverage(value);
        return this;
      }
      /**
       * <pre>
       * Changes the size of history with character coverage.
       * </pre>
       *
       * <code>optional int32 user_history_prediction_max_char_coverage = 82 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearUserHistoryPredictionMaxCharCoverage() {
        copyOnWrite();
        instance.clearUserHistoryPredictionMaxCharCoverage();
        return this;
      }

      /**
       * <pre>
       * Parameter for space-insertion for English compounds
       * value 0: no insertion. Candidates will be like this.
       * - "Google"
       * - "GOOGLE"
       * - "google"
       * value 1: expand for all English candidates
       * This mode adds space-prefixed candidates for three style, like this.
       * - "Google"
       * - " Google"
       * - "GOOGLE"
       * - " GOOGLE"
       * - "google"
       * - " google"
       * </pre>
       *
       * <code>optional int32 english_variation_space_insertion_mode = 55 [default = 0];</code>
       * @return Whether the englishVariationSpaceInsertionMode field is set.
       */
      @java.lang.Override
      public boolean hasEnglishVariationSpaceInsertionMode() {
        return instance.hasEnglishVariationSpaceInsertionMode();
      }
      /**
       * <pre>
       * Parameter for space-insertion for English compounds
       * value 0: no insertion. Candidates will be like this.
       * - "Google"
       * - "GOOGLE"
       * - "google"
       * value 1: expand for all English candidates
       * This mode adds space-prefixed candidates for three style, like this.
       * - "Google"
       * - " Google"
       * - "GOOGLE"
       * - " GOOGLE"
       * - "google"
       * - " google"
       * </pre>
       *
       * <code>optional int32 english_variation_space_insertion_mode = 55 [default = 0];</code>
       * @return The englishVariationSpaceInsertionMode.
       */
      @java.lang.Override
      public int getEnglishVariationSpaceInsertionMode() {
        return instance.getEnglishVariationSpaceInsertionMode();
      }
      /**
       * <pre>
       * Parameter for space-insertion for English compounds
       * value 0: no insertion. Candidates will be like this.
       * - "Google"
       * - "GOOGLE"
       * - "google"
       * value 1: expand for all English candidates
       * This mode adds space-prefixed candidates for three style, like this.
       * - "Google"
       * - " Google"
       * - "GOOGLE"
       * - " GOOGLE"
       * - "google"
       * - " google"
       * </pre>
       *
       * <code>optional int32 english_variation_space_insertion_mode = 55 [default = 0];</code>
       * @param value The englishVariationSpaceInsertionMode to set.
       * @return This builder for chaining.
       */
      public Builder setEnglishVariationSpaceInsertionMode(int value) {
        copyOnWrite();
        instance.setEnglishVariationSpaceInsertionMode(value);
        return this;
      }
      /**
       * <pre>
       * Parameter for space-insertion for English compounds
       * value 0: no insertion. Candidates will be like this.
       * - "Google"
       * - "GOOGLE"
       * - "google"
       * value 1: expand for all English candidates
       * This mode adds space-prefixed candidates for three style, like this.
       * - "Google"
       * - " Google"
       * - "GOOGLE"
       * - " GOOGLE"
       * - "google"
       * - " google"
       * </pre>
       *
       * <code>optional int32 english_variation_space_insertion_mode = 55 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearEnglishVariationSpaceInsertionMode() {
        copyOnWrite();
        instance.clearEnglishVariationSpaceInsertionMode();
        return this;
      }

      /**
       * <code>optional int32 candidate_consistency_cost_max_diff = 63 [default = 0];</code>
       * @return Whether the candidateConsistencyCostMaxDiff field is set.
       */
      @java.lang.Override
      public boolean hasCandidateConsistencyCostMaxDiff() {
        return instance.hasCandidateConsistencyCostMaxDiff();
      }
      /**
       * <code>optional int32 candidate_consistency_cost_max_diff = 63 [default = 0];</code>
       * @return The candidateConsistencyCostMaxDiff.
       */
      @java.lang.Override
      public int getCandidateConsistencyCostMaxDiff() {
        return instance.getCandidateConsistencyCostMaxDiff();
      }
      /**
       * <code>optional int32 candidate_consistency_cost_max_diff = 63 [default = 0];</code>
       * @param value The candidateConsistencyCostMaxDiff to set.
       * @return This builder for chaining.
       */
      public Builder setCandidateConsistencyCostMaxDiff(int value) {
        copyOnWrite();
        instance.setCandidateConsistencyCostMaxDiff(value);
        return this;
      }
      /**
       * <code>optional int32 candidate_consistency_cost_max_diff = 63 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearCandidateConsistencyCostMaxDiff() {
        copyOnWrite();
        instance.clearCandidateConsistencyCostMaxDiff();
        return this;
      }

      /**
       * <code>optional int32 max_composition_event_to_process = 64 [default = 2];</code>
       * @return Whether the maxCompositionEventToProcess field is set.
       */
      @java.lang.Override
      public boolean hasMaxCompositionEventToProcess() {
        return instance.hasMaxCompositionEventToProcess();
      }
      /**
       * <code>optional int32 max_composition_event_to_process = 64 [default = 2];</code>
       * @return The maxCompositionEventToProcess.
       */
      @java.lang.Override
      public int getMaxCompositionEventToProcess() {
        return instance.getMaxCompositionEventToProcess();
      }
      /**
       * <code>optional int32 max_composition_event_to_process = 64 [default = 2];</code>
       * @param value The maxCompositionEventToProcess to set.
       * @return This builder for chaining.
       */
      public Builder setMaxCompositionEventToProcess(int value) {
        copyOnWrite();
        instance.setMaxCompositionEventToProcess(value);
        return this;
      }
      /**
       * <code>optional int32 max_composition_event_to_process = 64 [default = 2];</code>
       * @return This builder for chaining.
       */
      public Builder clearMaxCompositionEventToProcess() {
        copyOnWrite();
        instance.clearMaxCompositionEventToProcess();
        return this;
      }

      /**
       * <pre>
       * Offset to promote Katakana candidates in rewriter.
       * The promotion will be disabled if the value is negative.
       * </pre>
       *
       * <code>optional int32 katakana_promotion_offset = 83 [default = 5];</code>
       * @return Whether the katakanaPromotionOffset field is set.
       */
      @java.lang.Override
      public boolean hasKatakanaPromotionOffset() {
        return instance.hasKatakanaPromotionOffset();
      }
      /**
       * <pre>
       * Offset to promote Katakana candidates in rewriter.
       * The promotion will be disabled if the value is negative.
       * </pre>
       *
       * <code>optional int32 katakana_promotion_offset = 83 [default = 5];</code>
       * @return The katakanaPromotionOffset.
       */
      @java.lang.Override
      public int getKatakanaPromotionOffset() {
        return instance.getKatakanaPromotionOffset();
      }
      /**
       * <pre>
       * Offset to promote Katakana candidates in rewriter.
       * The promotion will be disabled if the value is negative.
       * </pre>
       *
       * <code>optional int32 katakana_promotion_offset = 83 [default = 5];</code>
       * @param value The katakanaPromotionOffset to set.
       * @return This builder for chaining.
       */
      public Builder setKatakanaPromotionOffset(int value) {
        copyOnWrite();
        instance.setKatakanaPromotionOffset(value);
        return this;
      }
      /**
       * <pre>
       * Offset to promote Katakana candidates in rewriter.
       * The promotion will be disabled if the value is negative.
       * </pre>
       *
       * <code>optional int32 katakana_promotion_offset = 83 [default = 5];</code>
       * @return This builder for chaining.
       */
      public Builder clearKatakanaPromotionOffset() {
        copyOnWrite();
        instance.clearKatakanaPromotionOffset();
        return this;
      }

      /**
       * <pre>
       * Cost offset for handwriting conversion candidate.
       * default_value: 10*log(500)
       * </pre>
       *
       * <code>optional int32 handwriting_conversion_candidate_cost_offset = 102 [default = 1151];</code>
       * @return Whether the handwritingConversionCandidateCostOffset field is set.
       */
      @java.lang.Override
      public boolean hasHandwritingConversionCandidateCostOffset() {
        return instance.hasHandwritingConversionCandidateCostOffset();
      }
      /**
       * <pre>
       * Cost offset for handwriting conversion candidate.
       * default_value: 10*log(500)
       * </pre>
       *
       * <code>optional int32 handwriting_conversion_candidate_cost_offset = 102 [default = 1151];</code>
       * @return The handwritingConversionCandidateCostOffset.
       */
      @java.lang.Override
      public int getHandwritingConversionCandidateCostOffset() {
        return instance.getHandwritingConversionCandidateCostOffset();
      }
      /**
       * <pre>
       * Cost offset for handwriting conversion candidate.
       * default_value: 10*log(500)
       * </pre>
       *
       * <code>optional int32 handwriting_conversion_candidate_cost_offset = 102 [default = 1151];</code>
       * @param value The handwritingConversionCandidateCostOffset to set.
       * @return This builder for chaining.
       */
      public Builder setHandwritingConversionCandidateCostOffset(int value) {
        copyOnWrite();
        instance.setHandwritingConversionCandidateCostOffset(value);
        return this;
      }
      /**
       * <pre>
       * Cost offset for handwriting conversion candidate.
       * default_value: 10*log(500)
       * </pre>
       *
       * <code>optional int32 handwriting_conversion_candidate_cost_offset = 102 [default = 1151];</code>
       * @return This builder for chaining.
       */
      public Builder clearHandwritingConversionCandidateCostOffset() {
        copyOnWrite();
        instance.clearHandwritingConversionCandidateCostOffset();
        return this;
      }

      /**
       * <pre>
       * Threshold for suffix NWP transition cost.
       * If the transition cost is greater than this value, the candidate will be
       * filtered.
       * The candidate will not be filtered if this value is zero.
       * </pre>
       *
       * <code>optional int32 suffix_nwp_transition_cost_threshold = 107 [default = 0];</code>
       * @return Whether the suffixNwpTransitionCostThreshold field is set.
       */
      @java.lang.Override
      public boolean hasSuffixNwpTransitionCostThreshold() {
        return instance.hasSuffixNwpTransitionCostThreshold();
      }
      /**
       * <pre>
       * Threshold for suffix NWP transition cost.
       * If the transition cost is greater than this value, the candidate will be
       * filtered.
       * The candidate will not be filtered if this value is zero.
       * </pre>
       *
       * <code>optional int32 suffix_nwp_transition_cost_threshold = 107 [default = 0];</code>
       * @return The suffixNwpTransitionCostThreshold.
       */
      @java.lang.Override
      public int getSuffixNwpTransitionCostThreshold() {
        return instance.getSuffixNwpTransitionCostThreshold();
      }
      /**
       * <pre>
       * Threshold for suffix NWP transition cost.
       * If the transition cost is greater than this value, the candidate will be
       * filtered.
       * The candidate will not be filtered if this value is zero.
       * </pre>
       *
       * <code>optional int32 suffix_nwp_transition_cost_threshold = 107 [default = 0];</code>
       * @param value The suffixNwpTransitionCostThreshold to set.
       * @return This builder for chaining.
       */
      public Builder setSuffixNwpTransitionCostThreshold(int value) {
        copyOnWrite();
        instance.setSuffixNwpTransitionCostThreshold(value);
        return this;
      }
      /**
       * <pre>
       * Threshold for suffix NWP transition cost.
       * If the transition cost is greater than this value, the candidate will be
       * filtered.
       * The candidate will not be filtered if this value is zero.
       * </pre>
       *
       * <code>optional int32 suffix_nwp_transition_cost_threshold = 107 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearSuffixNwpTransitionCostThreshold() {
        copyOnWrite();
        instance.clearSuffixNwpTransitionCostThreshold();
        return this;
      }

      /**
       * <pre>
       * Stores inner segment boundary in user history cache.
       * This information is going to be shared with user_segment_rewriter.
       * </pre>
       *
       * <code>optional bool user_history_cache_inner_segment_boundary = 135 [default = false];</code>
       * @return Whether the userHistoryCacheInnerSegmentBoundary field is set.
       */
      @java.lang.Override
      public boolean hasUserHistoryCacheInnerSegmentBoundary() {
        return instance.hasUserHistoryCacheInnerSegmentBoundary();
      }
      /**
       * <pre>
       * Stores inner segment boundary in user history cache.
       * This information is going to be shared with user_segment_rewriter.
       * </pre>
       *
       * <code>optional bool user_history_cache_inner_segment_boundary = 135 [default = false];</code>
       * @return The userHistoryCacheInnerSegmentBoundary.
       */
      @java.lang.Override
      public boolean getUserHistoryCacheInnerSegmentBoundary() {
        return instance.getUserHistoryCacheInnerSegmentBoundary();
      }
      /**
       * <pre>
       * Stores inner segment boundary in user history cache.
       * This information is going to be shared with user_segment_rewriter.
       * </pre>
       *
       * <code>optional bool user_history_cache_inner_segment_boundary = 135 [default = false];</code>
       * @param value The userHistoryCacheInnerSegmentBoundary to set.
       * @return This builder for chaining.
       */
      public Builder setUserHistoryCacheInnerSegmentBoundary(boolean value) {
        copyOnWrite();
        instance.setUserHistoryCacheInnerSegmentBoundary(value);
        return this;
      }
      /**
       * <pre>
       * Stores inner segment boundary in user history cache.
       * This information is going to be shared with user_segment_rewriter.
       * </pre>
       *
       * <code>optional bool user_history_cache_inner_segment_boundary = 135 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearUserHistoryCacheInnerSegmentBoundary() {
        copyOnWrite();
        instance.clearUserHistoryCacheInnerSegmentBoundary();
        return this;
      }

      /**
       * <pre>
       * Position of the first symbol rewriter candidate (0-origin).
       * </pre>
       *
       * <code>optional int32 symbol_rewriter_candidate_position = 132 [default = 3];</code>
       * @return Whether the symbolRewriterCandidatePosition field is set.
       */
      @java.lang.Override
      public boolean hasSymbolRewriterCandidatePosition() {
        return instance.hasSymbolRewriterCandidatePosition();
      }
      /**
       * <pre>
       * Position of the first symbol rewriter candidate (0-origin).
       * </pre>
       *
       * <code>optional int32 symbol_rewriter_candidate_position = 132 [default = 3];</code>
       * @return The symbolRewriterCandidatePosition.
       */
      @java.lang.Override
      public int getSymbolRewriterCandidatePosition() {
        return instance.getSymbolRewriterCandidatePosition();
      }
      /**
       * <pre>
       * Position of the first symbol rewriter candidate (0-origin).
       * </pre>
       *
       * <code>optional int32 symbol_rewriter_candidate_position = 132 [default = 3];</code>
       * @param value The symbolRewriterCandidatePosition to set.
       * @return This builder for chaining.
       */
      public Builder setSymbolRewriterCandidatePosition(int value) {
        copyOnWrite();
        instance.setSymbolRewriterCandidatePosition(value);
        return this;
      }
      /**
       * <pre>
       * Position of the first symbol rewriter candidate (0-origin).
       * </pre>
       *
       * <code>optional int32 symbol_rewriter_candidate_position = 132 [default = 3];</code>
       * @return This builder for chaining.
       */
      public Builder clearSymbolRewriterCandidatePosition() {
        copyOnWrite();
        instance.clearSymbolRewriterCandidatePosition();
        return this;
      }

      /**
       * <pre>
       * Number of candidates to be promoted.
       * For example, if symbol_rewriter_candidate_position == 0, and
       * symbol_rewriter_promotion_size == 5, the first 5 candidates are symbols.
       * </pre>
       *
       * <code>optional int32 symbol_rewriter_promotion_size = 133 [default = 15];</code>
       * @return Whether the symbolRewriterPromotionSize field is set.
       */
      @java.lang.Override
      public boolean hasSymbolRewriterPromotionSize() {
        return instance.hasSymbolRewriterPromotionSize();
      }
      /**
       * <pre>
       * Number of candidates to be promoted.
       * For example, if symbol_rewriter_candidate_position == 0, and
       * symbol_rewriter_promotion_size == 5, the first 5 candidates are symbols.
       * </pre>
       *
       * <code>optional int32 symbol_rewriter_promotion_size = 133 [default = 15];</code>
       * @return The symbolRewriterPromotionSize.
       */
      @java.lang.Override
      public int getSymbolRewriterPromotionSize() {
        return instance.getSymbolRewriterPromotionSize();
      }
      /**
       * <pre>
       * Number of candidates to be promoted.
       * For example, if symbol_rewriter_candidate_position == 0, and
       * symbol_rewriter_promotion_size == 5, the first 5 candidates are symbols.
       * </pre>
       *
       * <code>optional int32 symbol_rewriter_promotion_size = 133 [default = 15];</code>
       * @param value The symbolRewriterPromotionSize to set.
       * @return This builder for chaining.
       */
      public Builder setSymbolRewriterPromotionSize(int value) {
        copyOnWrite();
        instance.setSymbolRewriterPromotionSize(value);
        return this;
      }
      /**
       * <pre>
       * Number of candidates to be promoted.
       * For example, if symbol_rewriter_candidate_position == 0, and
       * symbol_rewriter_promotion_size == 5, the first 5 candidates are symbols.
       * </pre>
       *
       * <code>optional int32 symbol_rewriter_promotion_size = 133 [default = 15];</code>
       * @return This builder for chaining.
       */
      public Builder clearSymbolRewriterPromotionSize() {
        copyOnWrite();
        instance.clearSymbolRewriterPromotionSize();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:mozc.commands.DecoderExperimentParams)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "variationCharacterTypes_",
              "disableZeroQuerySuffixPrediction_",
              "englishVariationSpaceInsertionMode_",
              "candidateConsistencyCostMaxDiff_",
              "maxCompositionEventToProcess_",
              "userHistoryPredictionMaxCharCoverage_",
              "katakanaPromotionOffset_",
              "typingCorrectionApplyUserHistorySize_",
              "typingCorrectionResultRerankerMode_",
              "typingCorrectionResultRerankerInterpolationWeight_",
              "typingCorrectionResultRerankerLiteralOnTopWeight_",
              "handwritingConversionCandidateCostOffset_",
              "suffixNwpTransitionCostThreshold_",
              "symbolRewriterCandidatePosition_",
              "symbolRewriterPromotionSize_",
              "userHistoryCacheInnerSegmentBoundary_",
            };
            java.lang.String info =
                "\u0001\u0010\u0000\u0001\b\u0087\u0010\u0000\u0000\u0000\b\u100b\u0000$\u1007\u0005" +
                "7\u1004\u0007?\u1004\b@\u1004\tR\u1004\u0006S\u1004\nU\u1004\u0004_\u1004\u0001d" +
                "\u1001\u0002e\u1001\u0003f\u1004\u000bk\u1004\f\u0084\u1004\u000e\u0085\u1004\u000f" +
                "\u0087\u1007\r";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams> parser = PARSER;
          if (parser == null) {
            synchronized (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:mozc.commands.DecoderExperimentParams)
    private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams DEFAULT_INSTANCE;
    static {
      DecoderExperimentParams defaultInstance = new DecoderExperimentParams();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        DecoderExperimentParams.class, defaultInstance);
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<DecoderExperimentParams> PARSER;

    public static com.google.protobuf.Parser<DecoderExperimentParams> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface RequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mozc.commands.Request)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Enable zero query suggestion.
     * </pre>
     *
     * <code>optional bool zero_query_suggestion = 1 [default = false];</code>
     * @return Whether the zeroQuerySuggestion field is set.
     */
    boolean hasZeroQuerySuggestion();
    /**
     * <pre>
     * Enable zero query suggestion.
     * </pre>
     *
     * <code>optional bool zero_query_suggestion = 1 [default = false];</code>
     * @return The zeroQuerySuggestion.
     */
    boolean getZeroQuerySuggestion();

    /**
     * <pre>
     * Conversion's candidate includes suggestion, prediction and conversion.
     * </pre>
     *
     * <code>optional bool mixed_conversion = 2 [default = false];</code>
     * @return Whether the mixedConversion field is set.
     */
    boolean hasMixedConversion();
    /**
     * <pre>
     * Conversion's candidate includes suggestion, prediction and conversion.
     * </pre>
     *
     * <code>optional bool mixed_conversion = 2 [default = false];</code>
     * @return The mixedConversion.
     */
    boolean getMixedConversion();

    /**
     * <pre>
     * Use special Romanji table.
     * </pre>
     *
     * <code>optional .mozc.commands.Request.SpecialRomanjiTable special_romanji_table = 4 [default = DEFAULT_TABLE];</code>
     * @return Whether the specialRomanjiTable field is set.
     */
    boolean hasSpecialRomanjiTable();
    /**
     * <pre>
     * Use special Romanji table.
     * </pre>
     *
     * <code>optional .mozc.commands.Request.SpecialRomanjiTable special_romanji_table = 4 [default = DEFAULT_TABLE];</code>
     * @return The specialRomanjiTable.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.SpecialRomanjiTable getSpecialRomanjiTable();

    /**
     * <code>optional .mozc.commands.Request.SpaceOnAlphanumeric space_on_alphanumeric = 6 [default = SPACE_OR_CONVERT_KEEPING_COMPOSITION];</code>
     * @return Whether the spaceOnAlphanumeric field is set.
     */
    boolean hasSpaceOnAlphanumeric();
    /**
     * <code>optional .mozc.commands.Request.SpaceOnAlphanumeric space_on_alphanumeric = 6 [default = SPACE_OR_CONVERT_KEEPING_COMPOSITION];</code>
     * @return The spaceOnAlphanumeric.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.SpaceOnAlphanumeric getSpaceOnAlphanumeric();

    /**
     * <pre>
     * Keyboard name for touch devices.
     * For example, "TWELVE_KEY_TOGGLE_KANA", "QWERTY_KANA_NUMBER".
     * It is used to analyze touch event usage stats.
     * </pre>
     *
     * <code>optional string keyboard_name = 7;</code>
     * @return Whether the keyboardName field is set.
     */
    boolean hasKeyboardName();
    /**
     * <pre>
     * Keyboard name for touch devices.
     * For example, "TWELVE_KEY_TOGGLE_KANA", "QWERTY_KANA_NUMBER".
     * It is used to analyze touch event usage stats.
     * </pre>
     *
     * <code>optional string keyboard_name = 7;</code>
     * @return The keyboardName.
     */
    java.lang.String getKeyboardName();
    /**
     * <pre>
     * Keyboard name for touch devices.
     * For example, "TWELVE_KEY_TOGGLE_KANA", "QWERTY_KANA_NUMBER".
     * It is used to analyze touch event usage stats.
     * </pre>
     *
     * <code>optional string keyboard_name = 7;</code>
     * @return The bytes for keyboardName.
     */
    com.google.protobuf.ByteString
        getKeyboardNameBytes();

    /**
     * <pre>
     * Enables Composer's input mode auto updating by using surrounding text.
     * For example, when a composition string is "ad", a carret is at the end,
     * and a user selects HIRAGANA mode, if the user moves the carret to between
     * "a" and "d" the mode will be automatically switch to ASCII (temporarily).
     * See details in the Composer::UpdateInputMode.
     * </pre>
     *
     * <code>optional bool update_input_mode_from_surrounding_text = 8 [default = true];</code>
     * @return Whether the updateInputModeFromSurroundingText field is set.
     */
    boolean hasUpdateInputModeFromSurroundingText();
    /**
     * <pre>
     * Enables Composer's input mode auto updating by using surrounding text.
     * For example, when a composition string is "ad", a carret is at the end,
     * and a user selects HIRAGANA mode, if the user moves the carret to between
     * "a" and "d" the mode will be automatically switch to ASCII (temporarily).
     * See details in the Composer::UpdateInputMode.
     * </pre>
     *
     * <code>optional bool update_input_mode_from_surrounding_text = 8 [default = true];</code>
     * @return The updateInputModeFromSurroundingText.
     */
    boolean getUpdateInputModeFromSurroundingText();

    /**
     * <pre>
     * Enables Kana-modifier-insensitive conversion as follows:
     * 1) Voiced/Semi-voiced kana will be hit by non-modified kana.
     *    e.g.) "ば" and "ぱ" will be hit by key "は".
     * 2) Geminate consonant "っ" will be hit by non-modified kana "つ".
     * 3) Palatalized kana will be hit by non-modified kana.
     *    e.g.) "ゃ" will be hit by key "や".
     * Here is an example of the search: "学校" ("がっこう") will be hit
     * by "かつこう".
     * </pre>
     *
     * <code>optional bool kana_modifier_insensitive_conversion = 9 [default = false];</code>
     * @return Whether the kanaModifierInsensitiveConversion field is set.
     */
    boolean hasKanaModifierInsensitiveConversion();
    /**
     * <pre>
     * Enables Kana-modifier-insensitive conversion as follows:
     * 1) Voiced/Semi-voiced kana will be hit by non-modified kana.
     *    e.g.) "ば" and "ぱ" will be hit by key "は".
     * 2) Geminate consonant "っ" will be hit by non-modified kana "つ".
     * 3) Palatalized kana will be hit by non-modified kana.
     *    e.g.) "ゃ" will be hit by key "や".
     * Here is an example of the search: "学校" ("がっこう") will be hit
     * by "かつこう".
     * </pre>
     *
     * <code>optional bool kana_modifier_insensitive_conversion = 9 [default = false];</code>
     * @return The kanaModifierInsensitiveConversion.
     */
    boolean getKanaModifierInsensitiveConversion();

    /**
     * <pre>
     * Enables Auto partial suggestion (prefix candidates).
     * For Auto partial suggestion, we can see candidates that match
     * the prefix of the input reading.
     * If we commit that candidate, we will show suggestions for remaining part
     * of key.
     * Note: This feature can be enabled only for mobile due to UX design.
     * </pre>
     *
     * <code>optional bool auto_partial_suggestion = 10 [default = false];</code>
     * @return Whether the autoPartialSuggestion field is set.
     */
    boolean hasAutoPartialSuggestion();
    /**
     * <pre>
     * Enables Auto partial suggestion (prefix candidates).
     * For Auto partial suggestion, we can see candidates that match
     * the prefix of the input reading.
     * If we commit that candidate, we will show suggestions for remaining part
     * of key.
     * Note: This feature can be enabled only for mobile due to UX design.
     * </pre>
     *
     * <code>optional bool auto_partial_suggestion = 10 [default = false];</code>
     * @return The autoPartialSuggestion.
     */
    boolean getAutoPartialSuggestion();

    /**
     * <pre>
     * By default, Emoji rewriter works on conversion mode only.
     * </pre>
     *
     * <code>optional int32 emoji_rewriter_capability = 12 [default = 1];</code>
     * @return Whether the emojiRewriterCapability field is set.
     */
    boolean hasEmojiRewriterCapability();
    /**
     * <pre>
     * By default, Emoji rewriter works on conversion mode only.
     * </pre>
     *
     * <code>optional int32 emoji_rewriter_capability = 12 [default = 1];</code>
     * @return The emojiRewriterCapability.
     */
    int getEmojiRewriterCapability();

    /**
     * <code>optional .mozc.commands.Request.CrossingEdgeBehavior crossing_edge_behavior = 13 [default = DO_NOTHING];</code>
     * @return Whether the crossingEdgeBehavior field is set.
     */
    boolean hasCrossingEdgeBehavior();
    /**
     * <code>optional .mozc.commands.Request.CrossingEdgeBehavior crossing_edge_behavior = 13 [default = DO_NOTHING];</code>
     * @return The crossingEdgeBehavior.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.CrossingEdgeBehavior getCrossingEdgeBehavior();

    /**
     * <code>optional .mozc.commands.Request.LanguageAwareInputBehavior language_aware_input = 14 [default = DEFAULT_LANGUAGE_AWARE_BEHAVIOR];</code>
     * @return Whether the languageAwareInput field is set.
     */
    boolean hasLanguageAwareInput();
    /**
     * <code>optional .mozc.commands.Request.LanguageAwareInputBehavior language_aware_input = 14 [default = DEFAULT_LANGUAGE_AWARE_BEHAVIOR];</code>
     * @return The languageAwareInput.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.LanguageAwareInputBehavior getLanguageAwareInput();

    /**
     * <pre>
     * Page size of the candidate list.
     * </pre>
     *
     * <code>optional int32 candidate_page_size = 15 [default = 9];</code>
     * @return Whether the candidatePageSize field is set.
     */
    boolean hasCandidatePageSize();
    /**
     * <pre>
     * Page size of the candidate list.
     * </pre>
     *
     * <code>optional int32 candidate_page_size = 15 [default = 9];</code>
     * @return The candidatePageSize.
     */
    int getCandidatePageSize();

    /**
     * <pre>
     * The maximum limit of the candidates size.
     * If not set, converter doesn't limit the size.
     * NOTE: Each segment has at least one candidate and meta candidates even if
     *       this value is set to 0.
     * </pre>
     *
     * <code>optional int32 candidates_size_limit = 16;</code>
     * @return Whether the candidatesSizeLimit field is set.
     */
    boolean hasCandidatesSizeLimit();
    /**
     * <pre>
     * The maximum limit of the candidates size.
     * If not set, converter doesn't limit the size.
     * NOTE: Each segment has at least one candidate and meta candidates even if
     *       this value is set to 0.
     * </pre>
     *
     * <code>optional int32 candidates_size_limit = 16;</code>
     * @return The candidatesSizeLimit.
     */
    int getCandidatesSizeLimit();

    /**
     * <pre>
     * Experimentally changes the decoder's behavior.
     * This flag is usually populated through the phenotype flags.
     * </pre>
     *
     * <code>optional .mozc.commands.DecoderExperimentParams decoder_experiment_params = 17;</code>
     * @return Whether the decoderExperimentParams field is set.
     */
    boolean hasDecoderExperimentParams();
    /**
     * <pre>
     * Experimentally changes the decoder's behavior.
     * This flag is usually populated through the phenotype flags.
     * </pre>
     *
     * <code>optional .mozc.commands.DecoderExperimentParams decoder_experiment_params = 17;</code>
     * @return The decoderExperimentParams.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams getDecoderExperimentParams();

    /**
     * <pre>
     * Fills incognito_candidate_words filed of output.
     * </pre>
     *
     * <code>optional bool fill_incognito_candidate_words = 18 [default = false];</code>
     * @return Whether the fillIncognitoCandidateWords field is set.
     */
    boolean hasFillIncognitoCandidateWords();
    /**
     * <pre>
     * Fills incognito_candidate_words filed of output.
     * </pre>
     *
     * <code>optional bool fill_incognito_candidate_words = 18 [default = false];</code>
     * @return The fillIncognitoCandidateWords.
     */
    boolean getFillIncognitoCandidateWords();

    /**
     * <pre>
     * Enables a11y support for candidates.
     * If this field is set to true, a11y description is set to each candidate.
     * </pre>
     *
     * <code>optional bool enable_a11y_description = 20 [default = false];</code>
     * @return Whether the enableA11yDescription field is set.
     */
    boolean hasEnableA11YDescription();
    /**
     * <pre>
     * Enables a11y support for candidates.
     * If this field is set to true, a11y description is set to each candidate.
     * </pre>
     *
     * <code>optional bool enable_a11y_description = 20 [default = false];</code>
     * @return The enableA11yDescription.
     */
    boolean getEnableA11YDescription();

    /**
     * <pre>
     * Characters in the union of this list of groups can be contained in
     * candidates.
     * This feature is distinct from user preference. Do not make these option
     * user selectable.
     * </pre>
     *
     * <code>repeated .mozc.commands.Request.AdditionalRenderableCharacterGroup additional_renderable_character_groups = 21 [packed = true];</code>
     * @return A list containing the additionalRenderableCharacterGroups.
     */
    java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup> getAdditionalRenderableCharacterGroupsList();
    /**
     * <pre>
     * Characters in the union of this list of groups can be contained in
     * candidates.
     * This feature is distinct from user preference. Do not make these option
     * user selectable.
     * </pre>
     *
     * <code>repeated .mozc.commands.Request.AdditionalRenderableCharacterGroup additional_renderable_character_groups = 21 [packed = true];</code>
     * @return The count of additionalRenderableCharacterGroups.
     */
    int getAdditionalRenderableCharacterGroupsCount();
    /**
     * <pre>
     * Characters in the union of this list of groups can be contained in
     * candidates.
     * This feature is distinct from user preference. Do not make these option
     * user selectable.
     * </pre>
     *
     * <code>repeated .mozc.commands.Request.AdditionalRenderableCharacterGroup additional_renderable_character_groups = 21 [packed = true];</code>
     * @param index The index of the element to return.
     * @return The additionalRenderableCharacterGroups at the given index.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup getAdditionalRenderableCharacterGroups(int index);

    /**
     * <pre>
     * Whether the request is from handwriting. Candidates can be optimized
     * differently for handwriting.
     * For example, we support 混ぜ書き conversion ("かん字" → "漢字") for
     * handwriting.
     * </pre>
     *
     * <code>optional bool is_handwriting = 22 [default = false];</code>
     * @return Whether the isHandwriting field is set.
     */
    boolean hasIsHandwriting();
    /**
     * <pre>
     * Whether the request is from handwriting. Candidates can be optimized
     * differently for handwriting.
     * For example, we support 混ぜ書き conversion ("かん字" → "漢字") for
     * handwriting.
     * </pre>
     *
     * <code>optional bool is_handwriting = 22 [default = false];</code>
     * @return The isHandwriting.
     */
    boolean getIsHandwriting();

    /**
     * <pre>
     * Whether the conversion is performed in incognito mode.
     * In incognito mode, the conversion is performed without using
     * user history and user dictionary.
     * When any of this value and Config::incognito_mode are true,
     * incognito mode is enabled.
     * Clients needs to check ConversionRequest::incognito_mode() instead of
     * this value directly, as the incognito mode can be set in other ways.
     * </pre>
     *
     * <code>optional bool is_incognito_mode = 23 [default = false];</code>
     * @return Whether the isIncognitoMode field is set.
     */
    boolean hasIsIncognitoMode();
    /**
     * <pre>
     * Whether the conversion is performed in incognito mode.
     * In incognito mode, the conversion is performed without using
     * user history and user dictionary.
     * When any of this value and Config::incognito_mode are true,
     * incognito mode is enabled.
     * Clients needs to check ConversionRequest::incognito_mode() instead of
     * this value directly, as the incognito mode can be set in other ways.
     * </pre>
     *
     * <code>optional bool is_incognito_mode = 23 [default = false];</code>
     * @return The isIncognitoMode.
     */
    boolean getIsIncognitoMode();

    /**
     * <code>optional .mozc.commands.Request.DisplayValueCapability display_value_capability = 24 [default = NOT_SUPPORTED];</code>
     * @return Whether the displayValueCapability field is set.
     */
    boolean hasDisplayValueCapability();
    /**
     * <code>optional .mozc.commands.Request.DisplayValueCapability display_value_capability = 24 [default = NOT_SUPPORTED];</code>
     * @return The displayValueCapability.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.DisplayValueCapability getDisplayValueCapability();
  }
  /**
   * <pre>
   * Clients' request to the server.
   * Users cannot modify this.
   * In the future each request may be able to be overwritten by Config.
   * The server does not have to obey this request.
   * Next ID: 25
   * </pre>
   *
   * Protobuf type {@code mozc.commands.Request}
   */
  public  static final class Request extends
      com.google.protobuf.GeneratedMessageLite<
          Request, Request.Builder> implements
      // @@protoc_insertion_point(message_implements:mozc.commands.Request)
      RequestOrBuilder {
    private Request() {
      keyboardName_ = "";
      updateInputModeFromSurroundingText_ = true;
      emojiRewriterCapability_ = 1;
      candidatePageSize_ = 9;
      additionalRenderableCharacterGroups_ = emptyIntList();
    }
    /**
     * <pre>
     * Next ID: 51
     * </pre>
     *
     * Protobuf enum {@code mozc.commands.Request.SpecialRomanjiTable}
     */
    public enum SpecialRomanjiTable
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <pre>
       * Do not use special table.
       * Romanji table is selected based on Config.
       * </pre>
       *
       * <code>DEFAULT_TABLE = 0;</code>
       */
      DEFAULT_TABLE(0),
      /**
       * <pre>
       * Use special table for 12keys (to hiragana).
       * </pre>
       *
       * <code>TWELVE_KEYS_TO_HIRAGANA = 10;</code>
       */
      TWELVE_KEYS_TO_HIRAGANA(10),
      /**
       * <pre>
       * This is a temporary romaji table that is to be used instead of the
       * current 12keys-to-hiragana table.
       * TODO(noriyukit): Replace TWELVE_KEYS_TO_HIRAGANA by this.
       * </pre>
       *
       * <code>TWELVE_KEYS_TO_HIRAGANA_INTUITIVE = 10000;</code>
       */
      TWELVE_KEYS_TO_HIRAGANA_INTUITIVE(10000),
      /**
       * <pre>
       * Use special table for 12keys (to half-width ascii).
       * </pre>
       *
       * <code>TWELVE_KEYS_TO_HALFWIDTHASCII = 11;</code>
       */
      TWELVE_KEYS_TO_HALFWIDTHASCII(11),
      /**
       * <pre>
       * Use special table for flick (to hiragana).
       * </pre>
       *
       * <code>FLICK_TO_HIRAGANA = 13;</code>
       */
      FLICK_TO_HIRAGANA(13),
      /**
       * <pre>
       * This is a temporary romaji table that is to be used instead of the
       * current flick-to-hiragana table.
       * TODO(noriyukit): Replace FLICK_TO_HIRAGANA by this.
       * </pre>
       *
       * <code>FLICK_TO_HIRAGANA_INTUITIVE = 10002;</code>
       */
      FLICK_TO_HIRAGANA_INTUITIVE(10002),
      /**
       * <pre>
       * Use special table for flick (to half-width ascii).
       * </pre>
       *
       * <code>FLICK_TO_HALFWIDTHASCII = 14;</code>
       */
      FLICK_TO_HALFWIDTHASCII(14),
      /**
       * <pre>
       * Use special table for flick (to alphabet).
       * </pre>
       *
       * <code>FLICK_TO_HALFWIDTHASCII_IOS = 44;</code>
       */
      FLICK_TO_HALFWIDTHASCII_IOS(44),
      /**
       * <pre>
       * Use special table for flick (to number).
       * </pre>
       *
       * <code>FLICK_TO_NUMBER = 43;</code>
       */
      FLICK_TO_NUMBER(43),
      /**
       * <pre>
       * Use special table for both toggle and flick (to hiragana).
       * </pre>
       *
       * <code>TOGGLE_FLICK_TO_HIRAGANA = 16;</code>
       */
      TOGGLE_FLICK_TO_HIRAGANA(16),
      /**
       * <pre>
       * This is a temporary romaji table that is to be used instead of the
       * current toggle_flick_hiragana table.
       * TODO(noriyukit): Replace TOGGLE_FLICK_HIRAGANA by this.
       * </pre>
       *
       * <code>TOGGLE_FLICK_TO_HIRAGANA_INTUITIVE = 10001;</code>
       */
      TOGGLE_FLICK_TO_HIRAGANA_INTUITIVE(10001),
      /**
       * <pre>
       * Use special table for both toggle and flick (to number).
       * </pre>
       *
       * <code>TOGGLE_FLICK_TO_NUMBER = 42;</code>
       */
      TOGGLE_FLICK_TO_NUMBER(42),
      /**
       * <pre>
       * Use special table for both toggle and flick (to alphabet).
       * </pre>
       *
       * <code>TOGGLE_FLICK_TO_HALFWIDTHASCII_IOS = 45;</code>
       */
      TOGGLE_FLICK_TO_HALFWIDTHASCII_IOS(45),
      /**
       * <pre>
       * Use special table for both toggle and flick (to half-width ascii).
       * </pre>
       *
       * <code>TOGGLE_FLICK_TO_HALFWIDTHASCII = 17;</code>
       */
      TOGGLE_FLICK_TO_HALFWIDTHASCII(17),
      /**
       * <pre>
       * Use special table for Qwerty (for Mobile) (to hiragana).
       * </pre>
       *
       * <code>QWERTY_MOBILE_TO_HIRAGANA = 20;</code>
       */
      QWERTY_MOBILE_TO_HIRAGANA(20),
      /**
       * <pre>
       * Use special table for Qwerty (for Mobile) (to half-width ascii).
       * </pre>
       *
       * <code>QWERTY_MOBILE_TO_HALFWIDTHASCII = 22;</code>
       */
      QWERTY_MOBILE_TO_HALFWIDTHASCII(22),
      /**
       * <pre>
       * Use special table for Godan (to hiragana).
       * </pre>
       *
       * <code>GODAN_TO_HIRAGANA = 30;</code>
       */
      GODAN_TO_HIRAGANA(30),
      /**
       * <pre>
       * Use special table for Godan (to half-width ascii).
       * </pre>
       *
       * <code>GODAN_TO_HALFWIDTHASCII = 31;</code>
       */
      GODAN_TO_HALFWIDTHASCII(31),
      /**
       * <pre>
       * Use special table for Notouch (to hiragana).
       * </pre>
       *
       * <code>NOTOUCH_TO_HIRAGANA = 40;</code>
       */
      NOTOUCH_TO_HIRAGANA(40),
      /**
       * <pre>
       * Use special table for Notouch (to half-width ascii).
       * </pre>
       *
       * <code>NOTOUCH_TO_HALFWIDTHASCII = 41;</code>
       */
      NOTOUCH_TO_HALFWIDTHASCII(41),
      /**
       * <pre>
       * Use special table for 50keys keyboard.
       * </pre>
       *
       * <code>FIFTY_KEYS_TO_HIRAGANA = 46;</code>
       */
      FIFTY_KEYS_TO_HIRAGANA(46),
      ;

      /**
       * <pre>
       * Do not use special table.
       * Romanji table is selected based on Config.
       * </pre>
       *
       * <code>DEFAULT_TABLE = 0;</code>
       */
      public static final int DEFAULT_TABLE_VALUE = 0;
      /**
       * <pre>
       * Use special table for 12keys (to hiragana).
       * </pre>
       *
       * <code>TWELVE_KEYS_TO_HIRAGANA = 10;</code>
       */
      public static final int TWELVE_KEYS_TO_HIRAGANA_VALUE = 10;
      /**
       * <pre>
       * This is a temporary romaji table that is to be used instead of the
       * current 12keys-to-hiragana table.
       * TODO(noriyukit): Replace TWELVE_KEYS_TO_HIRAGANA by this.
       * </pre>
       *
       * <code>TWELVE_KEYS_TO_HIRAGANA_INTUITIVE = 10000;</code>
       */
      public static final int TWELVE_KEYS_TO_HIRAGANA_INTUITIVE_VALUE = 10000;
      /**
       * <pre>
       * Use special table for 12keys (to half-width ascii).
       * </pre>
       *
       * <code>TWELVE_KEYS_TO_HALFWIDTHASCII = 11;</code>
       */
      public static final int TWELVE_KEYS_TO_HALFWIDTHASCII_VALUE = 11;
      /**
       * <pre>
       * Use special table for flick (to hiragana).
       * </pre>
       *
       * <code>FLICK_TO_HIRAGANA = 13;</code>
       */
      public static final int FLICK_TO_HIRAGANA_VALUE = 13;
      /**
       * <pre>
       * This is a temporary romaji table that is to be used instead of the
       * current flick-to-hiragana table.
       * TODO(noriyukit): Replace FLICK_TO_HIRAGANA by this.
       * </pre>
       *
       * <code>FLICK_TO_HIRAGANA_INTUITIVE = 10002;</code>
       */
      public static final int FLICK_TO_HIRAGANA_INTUITIVE_VALUE = 10002;
      /**
       * <pre>
       * Use special table for flick (to half-width ascii).
       * </pre>
       *
       * <code>FLICK_TO_HALFWIDTHASCII = 14;</code>
       */
      public static final int FLICK_TO_HALFWIDTHASCII_VALUE = 14;
      /**
       * <pre>
       * Use special table for flick (to alphabet).
       * </pre>
       *
       * <code>FLICK_TO_HALFWIDTHASCII_IOS = 44;</code>
       */
      public static final int FLICK_TO_HALFWIDTHASCII_IOS_VALUE = 44;
      /**
       * <pre>
       * Use special table for flick (to number).
       * </pre>
       *
       * <code>FLICK_TO_NUMBER = 43;</code>
       */
      public static final int FLICK_TO_NUMBER_VALUE = 43;
      /**
       * <pre>
       * Use special table for both toggle and flick (to hiragana).
       * </pre>
       *
       * <code>TOGGLE_FLICK_TO_HIRAGANA = 16;</code>
       */
      public static final int TOGGLE_FLICK_TO_HIRAGANA_VALUE = 16;
      /**
       * <pre>
       * This is a temporary romaji table that is to be used instead of the
       * current toggle_flick_hiragana table.
       * TODO(noriyukit): Replace TOGGLE_FLICK_HIRAGANA by this.
       * </pre>
       *
       * <code>TOGGLE_FLICK_TO_HIRAGANA_INTUITIVE = 10001;</code>
       */
      public static final int TOGGLE_FLICK_TO_HIRAGANA_INTUITIVE_VALUE = 10001;
      /**
       * <pre>
       * Use special table for both toggle and flick (to number).
       * </pre>
       *
       * <code>TOGGLE_FLICK_TO_NUMBER = 42;</code>
       */
      public static final int TOGGLE_FLICK_TO_NUMBER_VALUE = 42;
      /**
       * <pre>
       * Use special table for both toggle and flick (to alphabet).
       * </pre>
       *
       * <code>TOGGLE_FLICK_TO_HALFWIDTHASCII_IOS = 45;</code>
       */
      public static final int TOGGLE_FLICK_TO_HALFWIDTHASCII_IOS_VALUE = 45;
      /**
       * <pre>
       * Use special table for both toggle and flick (to half-width ascii).
       * </pre>
       *
       * <code>TOGGLE_FLICK_TO_HALFWIDTHASCII = 17;</code>
       */
      public static final int TOGGLE_FLICK_TO_HALFWIDTHASCII_VALUE = 17;
      /**
       * <pre>
       * Use special table for Qwerty (for Mobile) (to hiragana).
       * </pre>
       *
       * <code>QWERTY_MOBILE_TO_HIRAGANA = 20;</code>
       */
      public static final int QWERTY_MOBILE_TO_HIRAGANA_VALUE = 20;
      /**
       * <pre>
       * Use special table for Qwerty (for Mobile) (to half-width ascii).
       * </pre>
       *
       * <code>QWERTY_MOBILE_TO_HALFWIDTHASCII = 22;</code>
       */
      public static final int QWERTY_MOBILE_TO_HALFWIDTHASCII_VALUE = 22;
      /**
       * <pre>
       * Use special table for Godan (to hiragana).
       * </pre>
       *
       * <code>GODAN_TO_HIRAGANA = 30;</code>
       */
      public static final int GODAN_TO_HIRAGANA_VALUE = 30;
      /**
       * <pre>
       * Use special table for Godan (to half-width ascii).
       * </pre>
       *
       * <code>GODAN_TO_HALFWIDTHASCII = 31;</code>
       */
      public static final int GODAN_TO_HALFWIDTHASCII_VALUE = 31;
      /**
       * <pre>
       * Use special table for Notouch (to hiragana).
       * </pre>
       *
       * <code>NOTOUCH_TO_HIRAGANA = 40;</code>
       */
      public static final int NOTOUCH_TO_HIRAGANA_VALUE = 40;
      /**
       * <pre>
       * Use special table for Notouch (to half-width ascii).
       * </pre>
       *
       * <code>NOTOUCH_TO_HALFWIDTHASCII = 41;</code>
       */
      public static final int NOTOUCH_TO_HALFWIDTHASCII_VALUE = 41;
      /**
       * <pre>
       * Use special table for 50keys keyboard.
       * </pre>
       *
       * <code>FIFTY_KEYS_TO_HIRAGANA = 46;</code>
       */
      public static final int FIFTY_KEYS_TO_HIRAGANA_VALUE = 46;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static SpecialRomanjiTable valueOf(int value) {
        return forNumber(value);
      }

      public static SpecialRomanjiTable forNumber(int value) {
        switch (value) {
          case 0: return DEFAULT_TABLE;
          case 10: return TWELVE_KEYS_TO_HIRAGANA;
          case 10000: return TWELVE_KEYS_TO_HIRAGANA_INTUITIVE;
          case 11: return TWELVE_KEYS_TO_HALFWIDTHASCII;
          case 13: return FLICK_TO_HIRAGANA;
          case 10002: return FLICK_TO_HIRAGANA_INTUITIVE;
          case 14: return FLICK_TO_HALFWIDTHASCII;
          case 44: return FLICK_TO_HALFWIDTHASCII_IOS;
          case 43: return FLICK_TO_NUMBER;
          case 16: return TOGGLE_FLICK_TO_HIRAGANA;
          case 10001: return TOGGLE_FLICK_TO_HIRAGANA_INTUITIVE;
          case 42: return TOGGLE_FLICK_TO_NUMBER;
          case 45: return TOGGLE_FLICK_TO_HALFWIDTHASCII_IOS;
          case 17: return TOGGLE_FLICK_TO_HALFWIDTHASCII;
          case 20: return QWERTY_MOBILE_TO_HIRAGANA;
          case 22: return QWERTY_MOBILE_TO_HALFWIDTHASCII;
          case 30: return GODAN_TO_HIRAGANA;
          case 31: return GODAN_TO_HALFWIDTHASCII;
          case 40: return NOTOUCH_TO_HIRAGANA;
          case 41: return NOTOUCH_TO_HALFWIDTHASCII;
          case 46: return FIFTY_KEYS_TO_HIRAGANA;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<SpecialRomanjiTable>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          SpecialRomanjiTable> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<SpecialRomanjiTable>() {
              @java.lang.Override
              public SpecialRomanjiTable findValueByNumber(int number) {
                return SpecialRomanjiTable.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return SpecialRomanjiTableVerifier.INSTANCE;
      }

      private static final class SpecialRomanjiTableVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new SpecialRomanjiTableVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return SpecialRomanjiTable.forNumber(number) != null;
              }
            };

      private final int value;

      private SpecialRomanjiTable(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.commands.Request.SpecialRomanjiTable)
    }

    /**
     * Protobuf enum {@code mozc.commands.Request.SpaceOnAlphanumeric}
     */
    public enum SpaceOnAlphanumeric
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <pre>
       * The first input is treated as a space, double input is treated
       * as a conversion.  If a character is input after the first
       * input, the composition will remain.  For example, "ab&lt;space&gt;dc"
       * becomes "ab dc" as a single composition.
       * </pre>
       *
       * <code>SPACE_OR_CONVERT_KEEPING_COMPOSITION = 0;</code>
       */
      SPACE_OR_CONVERT_KEEPING_COMPOSITION(0),
      /**
       * <pre>
       * The first input is treated as a space, double input is treated
       * as a conversion.  If a character is input after the first
       * input, the previous composition will be committed.  For
       * example, "ab&lt;space&gt;dc" results "ab " as a committed string and
       * "dc" as a composition.
       * </pre>
       *
       * <code>SPACE_OR_CONVERT_COMMITTING_COMPOSITION = 1;</code>
       */
      SPACE_OR_CONVERT_COMMITTING_COMPOSITION(1),
      /**
       * <pre>
       * Commit the composition and a space.
       * </pre>
       *
       * <code>COMMIT = 2;</code>
       */
      COMMIT(2),
      ;

      /**
       * <pre>
       * The first input is treated as a space, double input is treated
       * as a conversion.  If a character is input after the first
       * input, the composition will remain.  For example, "ab&lt;space&gt;dc"
       * becomes "ab dc" as a single composition.
       * </pre>
       *
       * <code>SPACE_OR_CONVERT_KEEPING_COMPOSITION = 0;</code>
       */
      public static final int SPACE_OR_CONVERT_KEEPING_COMPOSITION_VALUE = 0;
      /**
       * <pre>
       * The first input is treated as a space, double input is treated
       * as a conversion.  If a character is input after the first
       * input, the previous composition will be committed.  For
       * example, "ab&lt;space&gt;dc" results "ab " as a committed string and
       * "dc" as a composition.
       * </pre>
       *
       * <code>SPACE_OR_CONVERT_COMMITTING_COMPOSITION = 1;</code>
       */
      public static final int SPACE_OR_CONVERT_COMMITTING_COMPOSITION_VALUE = 1;
      /**
       * <pre>
       * Commit the composition and a space.
       * </pre>
       *
       * <code>COMMIT = 2;</code>
       */
      public static final int COMMIT_VALUE = 2;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static SpaceOnAlphanumeric valueOf(int value) {
        return forNumber(value);
      }

      public static SpaceOnAlphanumeric forNumber(int value) {
        switch (value) {
          case 0: return SPACE_OR_CONVERT_KEEPING_COMPOSITION;
          case 1: return SPACE_OR_CONVERT_COMMITTING_COMPOSITION;
          case 2: return COMMIT;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<SpaceOnAlphanumeric>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          SpaceOnAlphanumeric> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<SpaceOnAlphanumeric>() {
              @java.lang.Override
              public SpaceOnAlphanumeric findValueByNumber(int number) {
                return SpaceOnAlphanumeric.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return SpaceOnAlphanumericVerifier.INSTANCE;
      }

      private static final class SpaceOnAlphanumericVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new SpaceOnAlphanumericVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return SpaceOnAlphanumeric.forNumber(number) != null;
              }
            };

      private final int value;

      private SpaceOnAlphanumeric(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.commands.Request.SpaceOnAlphanumeric)
    }

    /**
     * <pre>
     * For emoji rewriter, it is necessary to control when the rewriter runs
     * based on the clients. The following bit set is sync'ed to
     * RewriterInterface::CapabilityType (see rewriter_interface.h, too),
     * so that clients can fill the value.
     * </pre>
     *
     * Protobuf enum {@code mozc.commands.Request.RewriterCapability}
     */
    public enum RewriterCapability
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>NOT_AVAILABLE = 0;</code>
       */
      NOT_AVAILABLE(0),
      /**
       * <code>CONVERSION = 1;</code>
       */
      CONVERSION(1),
      /**
       * <code>PREDICTION = 2;</code>
       */
      PREDICTION(2),
      /**
       * <code>SUGGESTION = 4;</code>
       */
      SUGGESTION(4),
      /**
       * <pre>
       * CONVERSION | PREDICTION | SUGGESTION.
       * </pre>
       *
       * <code>ALL = 7;</code>
       */
      ALL(7),
      ;

      /**
       * <code>NOT_AVAILABLE = 0;</code>
       */
      public static final int NOT_AVAILABLE_VALUE = 0;
      /**
       * <code>CONVERSION = 1;</code>
       */
      public static final int CONVERSION_VALUE = 1;
      /**
       * <code>PREDICTION = 2;</code>
       */
      public static final int PREDICTION_VALUE = 2;
      /**
       * <code>SUGGESTION = 4;</code>
       */
      public static final int SUGGESTION_VALUE = 4;
      /**
       * <pre>
       * CONVERSION | PREDICTION | SUGGESTION.
       * </pre>
       *
       * <code>ALL = 7;</code>
       */
      public static final int ALL_VALUE = 7;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static RewriterCapability valueOf(int value) {
        return forNumber(value);
      }

      public static RewriterCapability forNumber(int value) {
        switch (value) {
          case 0: return NOT_AVAILABLE;
          case 1: return CONVERSION;
          case 2: return PREDICTION;
          case 4: return SUGGESTION;
          case 7: return ALL;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<RewriterCapability>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          RewriterCapability> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<RewriterCapability>() {
              @java.lang.Override
              public RewriterCapability findValueByNumber(int number) {
                return RewriterCapability.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return RewriterCapabilityVerifier.INSTANCE;
      }

      private static final class RewriterCapabilityVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new RewriterCapabilityVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return RewriterCapability.forNumber(number) != null;
              }
            };

      private final int value;

      private RewriterCapability(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.commands.Request.RewriterCapability)
    }

    /**
     * <pre>
     * Controls the behavior when a user types the left/right key at the edge
     * of the preedit string (in more precise, the left key at the beginning
     * of the preedit string, or the right key at the end).
     * </pre>
     *
     * Protobuf enum {@code mozc.commands.Request.CrossingEdgeBehavior}
     */
    public enum CrossingEdgeBehavior
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <pre>
       * This is the default behavior. The cursor movement at the edge
       * will make nothing, i.e., keeping the current cursor position (at the
       * edge), consume the key event.
       * </pre>
       *
       * <code>DO_NOTHING = 0;</code>
       */
      DO_NOTHING(0),
      /**
       * <pre>
       * This is the behavior, especially designed for alphabet keyboards on
       * mobile devices. Assuming the following text:
       *   XXXXabcde|YYYYY
       * where XXXX is preceding text, abcde is composing text, YYYYY is
       * following text and '|' is the caret, when a user sends "RIGHT"
       * cursor key, we'd like to commit the abcde and move the caret to right.
       * So the user will get:
       *   XXXXabcdeY|YYYY
       * Here, what we need is committing the "abcde" with the appropriate
       * caret position. (Note that we need to handle the left cursor key, too).
       * Also, we should *NOT* consume the key, so that the key event will be
       * handled appropriately by the target application.
       * </pre>
       *
       * <code>COMMIT_WITHOUT_CONSUMING = 1;</code>
       */
      COMMIT_WITHOUT_CONSUMING(1),
      ;

      /**
       * <pre>
       * This is the default behavior. The cursor movement at the edge
       * will make nothing, i.e., keeping the current cursor position (at the
       * edge), consume the key event.
       * </pre>
       *
       * <code>DO_NOTHING = 0;</code>
       */
      public static final int DO_NOTHING_VALUE = 0;
      /**
       * <pre>
       * This is the behavior, especially designed for alphabet keyboards on
       * mobile devices. Assuming the following text:
       *   XXXXabcde|YYYYY
       * where XXXX is preceding text, abcde is composing text, YYYYY is
       * following text and '|' is the caret, when a user sends "RIGHT"
       * cursor key, we'd like to commit the abcde and move the caret to right.
       * So the user will get:
       *   XXXXabcdeY|YYYY
       * Here, what we need is committing the "abcde" with the appropriate
       * caret position. (Note that we need to handle the left cursor key, too).
       * Also, we should *NOT* consume the key, so that the key event will be
       * handled appropriately by the target application.
       * </pre>
       *
       * <code>COMMIT_WITHOUT_CONSUMING = 1;</code>
       */
      public static final int COMMIT_WITHOUT_CONSUMING_VALUE = 1;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static CrossingEdgeBehavior valueOf(int value) {
        return forNumber(value);
      }

      public static CrossingEdgeBehavior forNumber(int value) {
        switch (value) {
          case 0: return DO_NOTHING;
          case 1: return COMMIT_WITHOUT_CONSUMING;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<CrossingEdgeBehavior>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          CrossingEdgeBehavior> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<CrossingEdgeBehavior>() {
              @java.lang.Override
              public CrossingEdgeBehavior findValueByNumber(int number) {
                return CrossingEdgeBehavior.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return CrossingEdgeBehaviorVerifier.INSTANCE;
      }

      private static final class CrossingEdgeBehaviorVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new CrossingEdgeBehaviorVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return CrossingEdgeBehavior.forNumber(number) != null;
              }
            };

      private final int value;

      private CrossingEdgeBehavior(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.commands.Request.CrossingEdgeBehavior)
    }

    /**
     * <pre>
     * Controls the behavior of language aware input.  Language aware input
     * guesses the actual language regardless the input mode.  For example,
     * if user type "てｓｔ" it will be treated as "test".
     * </pre>
     *
     * Protobuf enum {@code mozc.commands.Request.LanguageAwareInputBehavior}
     */
    public enum LanguageAwareInputBehavior
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <pre>
       * Performs the default behavior considering the platform and channel.
       * </pre>
       *
       * <code>DEFAULT_LANGUAGE_AWARE_BEHAVIOR = 0;</code>
       */
      DEFAULT_LANGUAGE_AWARE_BEHAVIOR(0),
      /**
       * <pre>
       * Does not perform this functionarity.
       * </pre>
       *
       * <code>NO_LANGUAGE_AWARE_INPUT = 1;</code>
       */
      NO_LANGUAGE_AWARE_INPUT(1),
      /**
       * <pre>
       * Adds a language aware candidate to the suggestion.
       * </pre>
       *
       * <code>LANGUAGE_AWARE_SUGGESTION = 2;</code>
       */
      LANGUAGE_AWARE_SUGGESTION(2),
      ;

      /**
       * <pre>
       * Performs the default behavior considering the platform and channel.
       * </pre>
       *
       * <code>DEFAULT_LANGUAGE_AWARE_BEHAVIOR = 0;</code>
       */
      public static final int DEFAULT_LANGUAGE_AWARE_BEHAVIOR_VALUE = 0;
      /**
       * <pre>
       * Does not perform this functionarity.
       * </pre>
       *
       * <code>NO_LANGUAGE_AWARE_INPUT = 1;</code>
       */
      public static final int NO_LANGUAGE_AWARE_INPUT_VALUE = 1;
      /**
       * <pre>
       * Adds a language aware candidate to the suggestion.
       * </pre>
       *
       * <code>LANGUAGE_AWARE_SUGGESTION = 2;</code>
       */
      public static final int LANGUAGE_AWARE_SUGGESTION_VALUE = 2;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static LanguageAwareInputBehavior valueOf(int value) {
        return forNumber(value);
      }

      public static LanguageAwareInputBehavior forNumber(int value) {
        switch (value) {
          case 0: return DEFAULT_LANGUAGE_AWARE_BEHAVIOR;
          case 1: return NO_LANGUAGE_AWARE_INPUT;
          case 2: return LANGUAGE_AWARE_SUGGESTION;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<LanguageAwareInputBehavior>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          LanguageAwareInputBehavior> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<LanguageAwareInputBehavior>() {
              @java.lang.Override
              public LanguageAwareInputBehavior findValueByNumber(int number) {
                return LanguageAwareInputBehavior.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return LanguageAwareInputBehaviorVerifier.INSTANCE;
      }

      private static final class LanguageAwareInputBehaviorVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new LanguageAwareInputBehaviorVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return LanguageAwareInputBehavior.forNumber(number) != null;
              }
            };

      private final int value;

      private LanguageAwareInputBehavior(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.commands.Request.LanguageAwareInputBehavior)
    }

    /**
     * <pre>
     * Additional Character Group represents certain group of characters, that can
     * be additionaly requested from the client side, based on font-availability
     * information.
     * This enum is not intended to be used for user preference. 'Additional'
     * cases can change as time advances. For example, when KANA_SUPPLEMENT_6_0
     * becomes enough available among environments, this option becomes default
     * and the case will be removed.
     * WARNING: Although cases are mutually exclusive now, they are not
     * necessarily mutually exclusive. However, the current implementation in
     * NormalizationRewriter assumes they are mutually exclusive.
     * LINT.IfChange
     * Next ID: 15
     * </pre>
     *
     * Protobuf enum {@code mozc.commands.Request.AdditionalRenderableCharacterGroup}
     */
    public enum AdditionalRenderableCharacterGroup
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <pre>
       * Do not use this case. This case is reserved for future usage.
       * Because 0th element in enum is used as default value, in order to prevend
       * having unexpected additional group, this case represents empty set of
       * characters.
       * </pre>
       *
       * <code>EMPTY = 0;</code>
       */
      EMPTY(0),
      /**
       * <pre>
       * Additional Hiragana, Katakana, and Hentaigana.
       * It only contains KATAKANA / HIRAGANA LETTER ARCHAIC YE (U+1B000 and
       * U+1B001) since Unicode 6.0. Some fonts including M+ fonts only support
       * this letter.
       * </pre>
       *
       * <code>KANA_SUPPLEMENT_6_0 = 2;</code>
       */
      KANA_SUPPLEMENT_6_0(2),
      /**
       * <pre>
       * It contains 285 Hentaigana characters supported in KANA_SUPPLEMENT and
       * KANA_EXTENDED_A (U+1B002 ~ U+1B11E) since Unicode 10.0.
       * </pre>
       *
       * <code>KANA_SUPPLEMENT_AND_KANA_EXTENDED_A_10_0 = 3;</code>
       */
      KANA_SUPPLEMENT_AND_KANA_EXTENDED_A_10_0(3),
      /**
       * <pre>
       * It contains four archaic hiraganas/katakanas (U+1B11F ~ U+1B122) since
       * Unicode 14.0.
       * </pre>
       *
       * <code>KANA_EXTENDED_A_14_0 = 4;</code>
       */
      KANA_EXTENDED_A_14_0(4),
      /**
       * <pre>
       * Additional Emoji
       * Emoji in enum can be removed and become default several years passed
       * after the introduction. Emoji 12.1, released October 2019
       * </pre>
       *
       * <code>EMOJI_12_1 = 5;</code>
       */
      EMOJI_12_1(5),
      /**
       * <pre>
       * Emoji 13.0, released March 2020
       * </pre>
       *
       * <code>EMOJI_13_0 = 6;</code>
       */
      EMOJI_13_0(6),
      /**
       * <pre>
       * Emoji 13.1, released September 2020
       * </pre>
       *
       * <code>EMOJI_13_1 = 7;</code>
       */
      EMOJI_13_1(7),
      /**
       * <pre>
       * Emoji 14.0, released September 2021
       * </pre>
       *
       * <code>EMOJI_14_0 = 8;</code>
       */
      EMOJI_14_0(8),
      /**
       * <pre>
       * Emoji 15.0, released September 2022
       * </pre>
       *
       * <code>EMOJI_15_0 = 9;</code>
       */
      EMOJI_15_0(9),
      /**
       * <pre>
       * Emoji 15.1, released September 2023
       * </pre>
       *
       * <code>EMOJI_15_1 = 12;</code>
       */
      EMOJI_15_1(12),
      /**
       * <pre>
       * Emoji 16.0, released September 2024
       * </pre>
       *
       * <code>EMOJI_16_0 = 13;</code>
       */
      EMOJI_16_0(13),
      /**
       * <pre>
       * Emoji 17.0, released Octorber 2025
       * </pre>
       *
       * <code>EMOJI_17_0 = 14;</code>
       */
      EMOJI_17_0(14),
      /**
       * <pre>
       * Additional Hieroglyphs (U+13000 ~ U+1342E)
       * Unicode 5.2, released October 2009
       * </pre>
       *
       * <code>EGYPTIAN_HIEROGLYPH_5_2 = 10;</code>
       */
      EGYPTIAN_HIEROGLYPH_5_2(10),
      /**
       * <pre>
       * IVS characters in Adobe-Japan1 (U+E0100 ~ U+E010E)
       * </pre>
       *
       * <code>IVS_CHARACTER = 11;</code>
       */
      IVS_CHARACTER(11),
      ;

      /**
       * <pre>
       * Do not use this case. This case is reserved for future usage.
       * Because 0th element in enum is used as default value, in order to prevend
       * having unexpected additional group, this case represents empty set of
       * characters.
       * </pre>
       *
       * <code>EMPTY = 0;</code>
       */
      public static final int EMPTY_VALUE = 0;
      /**
       * <pre>
       * Additional Hiragana, Katakana, and Hentaigana.
       * It only contains KATAKANA / HIRAGANA LETTER ARCHAIC YE (U+1B000 and
       * U+1B001) since Unicode 6.0. Some fonts including M+ fonts only support
       * this letter.
       * </pre>
       *
       * <code>KANA_SUPPLEMENT_6_0 = 2;</code>
       */
      public static final int KANA_SUPPLEMENT_6_0_VALUE = 2;
      /**
       * <pre>
       * It contains 285 Hentaigana characters supported in KANA_SUPPLEMENT and
       * KANA_EXTENDED_A (U+1B002 ~ U+1B11E) since Unicode 10.0.
       * </pre>
       *
       * <code>KANA_SUPPLEMENT_AND_KANA_EXTENDED_A_10_0 = 3;</code>
       */
      public static final int KANA_SUPPLEMENT_AND_KANA_EXTENDED_A_10_0_VALUE = 3;
      /**
       * <pre>
       * It contains four archaic hiraganas/katakanas (U+1B11F ~ U+1B122) since
       * Unicode 14.0.
       * </pre>
       *
       * <code>KANA_EXTENDED_A_14_0 = 4;</code>
       */
      public static final int KANA_EXTENDED_A_14_0_VALUE = 4;
      /**
       * <pre>
       * Additional Emoji
       * Emoji in enum can be removed and become default several years passed
       * after the introduction. Emoji 12.1, released October 2019
       * </pre>
       *
       * <code>EMOJI_12_1 = 5;</code>
       */
      public static final int EMOJI_12_1_VALUE = 5;
      /**
       * <pre>
       * Emoji 13.0, released March 2020
       * </pre>
       *
       * <code>EMOJI_13_0 = 6;</code>
       */
      public static final int EMOJI_13_0_VALUE = 6;
      /**
       * <pre>
       * Emoji 13.1, released September 2020
       * </pre>
       *
       * <code>EMOJI_13_1 = 7;</code>
       */
      public static final int EMOJI_13_1_VALUE = 7;
      /**
       * <pre>
       * Emoji 14.0, released September 2021
       * </pre>
       *
       * <code>EMOJI_14_0 = 8;</code>
       */
      public static final int EMOJI_14_0_VALUE = 8;
      /**
       * <pre>
       * Emoji 15.0, released September 2022
       * </pre>
       *
       * <code>EMOJI_15_0 = 9;</code>
       */
      public static final int EMOJI_15_0_VALUE = 9;
      /**
       * <pre>
       * Emoji 15.1, released September 2023
       * </pre>
       *
       * <code>EMOJI_15_1 = 12;</code>
       */
      public static final int EMOJI_15_1_VALUE = 12;
      /**
       * <pre>
       * Emoji 16.0, released September 2024
       * </pre>
       *
       * <code>EMOJI_16_0 = 13;</code>
       */
      public static final int EMOJI_16_0_VALUE = 13;
      /**
       * <pre>
       * Emoji 17.0, released Octorber 2025
       * </pre>
       *
       * <code>EMOJI_17_0 = 14;</code>
       */
      public static final int EMOJI_17_0_VALUE = 14;
      /**
       * <pre>
       * Additional Hieroglyphs (U+13000 ~ U+1342E)
       * Unicode 5.2, released October 2009
       * </pre>
       *
       * <code>EGYPTIAN_HIEROGLYPH_5_2 = 10;</code>
       */
      public static final int EGYPTIAN_HIEROGLYPH_5_2_VALUE = 10;
      /**
       * <pre>
       * IVS characters in Adobe-Japan1 (U+E0100 ~ U+E010E)
       * </pre>
       *
       * <code>IVS_CHARACTER = 11;</code>
       */
      public static final int IVS_CHARACTER_VALUE = 11;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static AdditionalRenderableCharacterGroup valueOf(int value) {
        return forNumber(value);
      }

      public static AdditionalRenderableCharacterGroup forNumber(int value) {
        switch (value) {
          case 0: return EMPTY;
          case 2: return KANA_SUPPLEMENT_6_0;
          case 3: return KANA_SUPPLEMENT_AND_KANA_EXTENDED_A_10_0;
          case 4: return KANA_EXTENDED_A_14_0;
          case 5: return EMOJI_12_1;
          case 6: return EMOJI_13_0;
          case 7: return EMOJI_13_1;
          case 8: return EMOJI_14_0;
          case 9: return EMOJI_15_0;
          case 12: return EMOJI_15_1;
          case 13: return EMOJI_16_0;
          case 14: return EMOJI_17_0;
          case 10: return EGYPTIAN_HIEROGLYPH_5_2;
          case 11: return IVS_CHARACTER;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<AdditionalRenderableCharacterGroup>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          AdditionalRenderableCharacterGroup> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AdditionalRenderableCharacterGroup>() {
              @java.lang.Override
              public AdditionalRenderableCharacterGroup findValueByNumber(int number) {
                return AdditionalRenderableCharacterGroup.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return AdditionalRenderableCharacterGroupVerifier.INSTANCE;
      }

      private static final class AdditionalRenderableCharacterGroupVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new AdditionalRenderableCharacterGroupVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return AdditionalRenderableCharacterGroup.forNumber(number) != null;
              }
            };

      private final int value;

      private AdditionalRenderableCharacterGroup(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.commands.Request.AdditionalRenderableCharacterGroup)
    }

    /**
     * <pre>
     * Whether the client can accept display_value attribute.
     * </pre>
     *
     * Protobuf enum {@code mozc.commands.Request.DisplayValueCapability}
     */
    public enum DisplayValueCapability
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>NOT_SUPPORTED = 0;</code>
       */
      NOT_SUPPORTED(0),
      /**
       * <code>PLAIN_TEXT = 1;</code>
       */
      PLAIN_TEXT(1),
      ;

      /**
       * <code>NOT_SUPPORTED = 0;</code>
       */
      public static final int NOT_SUPPORTED_VALUE = 0;
      /**
       * <code>PLAIN_TEXT = 1;</code>
       */
      public static final int PLAIN_TEXT_VALUE = 1;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static DisplayValueCapability valueOf(int value) {
        return forNumber(value);
      }

      public static DisplayValueCapability forNumber(int value) {
        switch (value) {
          case 0: return NOT_SUPPORTED;
          case 1: return PLAIN_TEXT;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<DisplayValueCapability>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          DisplayValueCapability> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<DisplayValueCapability>() {
              @java.lang.Override
              public DisplayValueCapability findValueByNumber(int number) {
                return DisplayValueCapability.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return DisplayValueCapabilityVerifier.INSTANCE;
      }

      private static final class DisplayValueCapabilityVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new DisplayValueCapabilityVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return DisplayValueCapability.forNumber(number) != null;
              }
            };

      private final int value;

      private DisplayValueCapability(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.commands.Request.DisplayValueCapability)
    }

    private int bitField0_;
    public static final int ZERO_QUERY_SUGGESTION_FIELD_NUMBER = 1;
    private boolean zeroQuerySuggestion_;
    /**
     * <pre>
     * Enable zero query suggestion.
     * </pre>
     *
     * <code>optional bool zero_query_suggestion = 1 [default = false];</code>
     * @return Whether the zeroQuerySuggestion field is set.
     */
    @java.lang.Override
    public boolean hasZeroQuerySuggestion() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Enable zero query suggestion.
     * </pre>
     *
     * <code>optional bool zero_query_suggestion = 1 [default = false];</code>
     * @return The zeroQuerySuggestion.
     */
    @java.lang.Override
    public boolean getZeroQuerySuggestion() {
      return zeroQuerySuggestion_;
    }
    /**
     * <pre>
     * Enable zero query suggestion.
     * </pre>
     *
     * <code>optional bool zero_query_suggestion = 1 [default = false];</code>
     * @param value The zeroQuerySuggestion to set.
     */
    private void setZeroQuerySuggestion(boolean value) {
      bitField0_ |= 0x00000001;
      zeroQuerySuggestion_ = value;
    }
    /**
     * <pre>
     * Enable zero query suggestion.
     * </pre>
     *
     * <code>optional bool zero_query_suggestion = 1 [default = false];</code>
     */
    private void clearZeroQuerySuggestion() {
      bitField0_ = (bitField0_ & ~0x00000001);
      zeroQuerySuggestion_ = false;
    }

    public static final int MIXED_CONVERSION_FIELD_NUMBER = 2;
    private boolean mixedConversion_;
    /**
     * <pre>
     * Conversion's candidate includes suggestion, prediction and conversion.
     * </pre>
     *
     * <code>optional bool mixed_conversion = 2 [default = false];</code>
     * @return Whether the mixedConversion field is set.
     */
    @java.lang.Override
    public boolean hasMixedConversion() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Conversion's candidate includes suggestion, prediction and conversion.
     * </pre>
     *
     * <code>optional bool mixed_conversion = 2 [default = false];</code>
     * @return The mixedConversion.
     */
    @java.lang.Override
    public boolean getMixedConversion() {
      return mixedConversion_;
    }
    /**
     * <pre>
     * Conversion's candidate includes suggestion, prediction and conversion.
     * </pre>
     *
     * <code>optional bool mixed_conversion = 2 [default = false];</code>
     * @param value The mixedConversion to set.
     */
    private void setMixedConversion(boolean value) {
      bitField0_ |= 0x00000002;
      mixedConversion_ = value;
    }
    /**
     * <pre>
     * Conversion's candidate includes suggestion, prediction and conversion.
     * </pre>
     *
     * <code>optional bool mixed_conversion = 2 [default = false];</code>
     */
    private void clearMixedConversion() {
      bitField0_ = (bitField0_ & ~0x00000002);
      mixedConversion_ = false;
    }

    public static final int SPECIAL_ROMANJI_TABLE_FIELD_NUMBER = 4;
    private int specialRomanjiTable_;
    /**
     * <pre>
     * Use special Romanji table.
     * </pre>
     *
     * <code>optional .mozc.commands.Request.SpecialRomanjiTable special_romanji_table = 4 [default = DEFAULT_TABLE];</code>
     * @return Whether the specialRomanjiTable field is set.
     */
    @java.lang.Override
    public boolean hasSpecialRomanjiTable() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Use special Romanji table.
     * </pre>
     *
     * <code>optional .mozc.commands.Request.SpecialRomanjiTable special_romanji_table = 4 [default = DEFAULT_TABLE];</code>
     * @return The specialRomanjiTable.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.SpecialRomanjiTable getSpecialRomanjiTable() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.SpecialRomanjiTable result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.SpecialRomanjiTable.forNumber(specialRomanjiTable_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.SpecialRomanjiTable.DEFAULT_TABLE : result;
    }
    /**
     * <pre>
     * Use special Romanji table.
     * </pre>
     *
     * <code>optional .mozc.commands.Request.SpecialRomanjiTable special_romanji_table = 4 [default = DEFAULT_TABLE];</code>
     * @param value The specialRomanjiTable to set.
     */
    private void setSpecialRomanjiTable(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.SpecialRomanjiTable value) {
      specialRomanjiTable_ = value.getNumber();
      bitField0_ |= 0x00000004;
    }
    /**
     * <pre>
     * Use special Romanji table.
     * </pre>
     *
     * <code>optional .mozc.commands.Request.SpecialRomanjiTable special_romanji_table = 4 [default = DEFAULT_TABLE];</code>
     */
    private void clearSpecialRomanjiTable() {
      bitField0_ = (bitField0_ & ~0x00000004);
      specialRomanjiTable_ = 0;
    }

    public static final int SPACE_ON_ALPHANUMERIC_FIELD_NUMBER = 6;
    private int spaceOnAlphanumeric_;
    /**
     * <code>optional .mozc.commands.Request.SpaceOnAlphanumeric space_on_alphanumeric = 6 [default = SPACE_OR_CONVERT_KEEPING_COMPOSITION];</code>
     * @return Whether the spaceOnAlphanumeric field is set.
     */
    @java.lang.Override
    public boolean hasSpaceOnAlphanumeric() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <code>optional .mozc.commands.Request.SpaceOnAlphanumeric space_on_alphanumeric = 6 [default = SPACE_OR_CONVERT_KEEPING_COMPOSITION];</code>
     * @return The spaceOnAlphanumeric.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.SpaceOnAlphanumeric getSpaceOnAlphanumeric() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.SpaceOnAlphanumeric result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.SpaceOnAlphanumeric.forNumber(spaceOnAlphanumeric_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.SpaceOnAlphanumeric.SPACE_OR_CONVERT_KEEPING_COMPOSITION : result;
    }
    /**
     * <code>optional .mozc.commands.Request.SpaceOnAlphanumeric space_on_alphanumeric = 6 [default = SPACE_OR_CONVERT_KEEPING_COMPOSITION];</code>
     * @param value The spaceOnAlphanumeric to set.
     */
    private void setSpaceOnAlphanumeric(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.SpaceOnAlphanumeric value) {
      spaceOnAlphanumeric_ = value.getNumber();
      bitField0_ |= 0x00000008;
    }
    /**
     * <code>optional .mozc.commands.Request.SpaceOnAlphanumeric space_on_alphanumeric = 6 [default = SPACE_OR_CONVERT_KEEPING_COMPOSITION];</code>
     */
    private void clearSpaceOnAlphanumeric() {
      bitField0_ = (bitField0_ & ~0x00000008);
      spaceOnAlphanumeric_ = 0;
    }

    public static final int KEYBOARD_NAME_FIELD_NUMBER = 7;
    private java.lang.String keyboardName_;
    /**
     * <pre>
     * Keyboard name for touch devices.
     * For example, "TWELVE_KEY_TOGGLE_KANA", "QWERTY_KANA_NUMBER".
     * It is used to analyze touch event usage stats.
     * </pre>
     *
     * <code>optional string keyboard_name = 7;</code>
     * @return Whether the keyboardName field is set.
     */
    @java.lang.Override
    public boolean hasKeyboardName() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Keyboard name for touch devices.
     * For example, "TWELVE_KEY_TOGGLE_KANA", "QWERTY_KANA_NUMBER".
     * It is used to analyze touch event usage stats.
     * </pre>
     *
     * <code>optional string keyboard_name = 7;</code>
     * @return The keyboardName.
     */
    @java.lang.Override
    public java.lang.String getKeyboardName() {
      return keyboardName_;
    }
    /**
     * <pre>
     * Keyboard name for touch devices.
     * For example, "TWELVE_KEY_TOGGLE_KANA", "QWERTY_KANA_NUMBER".
     * It is used to analyze touch event usage stats.
     * </pre>
     *
     * <code>optional string keyboard_name = 7;</code>
     * @return The bytes for keyboardName.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getKeyboardNameBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(keyboardName_);
    }
    /**
     * <pre>
     * Keyboard name for touch devices.
     * For example, "TWELVE_KEY_TOGGLE_KANA", "QWERTY_KANA_NUMBER".
     * It is used to analyze touch event usage stats.
     * </pre>
     *
     * <code>optional string keyboard_name = 7;</code>
     * @param value The keyboardName to set.
     */
    private void setKeyboardName(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000010;
      keyboardName_ = value;
    }
    /**
     * <pre>
     * Keyboard name for touch devices.
     * For example, "TWELVE_KEY_TOGGLE_KANA", "QWERTY_KANA_NUMBER".
     * It is used to analyze touch event usage stats.
     * </pre>
     *
     * <code>optional string keyboard_name = 7;</code>
     */
    private void clearKeyboardName() {
      bitField0_ = (bitField0_ & ~0x00000010);
      keyboardName_ = getDefaultInstance().getKeyboardName();
    }
    /**
     * <pre>
     * Keyboard name for touch devices.
     * For example, "TWELVE_KEY_TOGGLE_KANA", "QWERTY_KANA_NUMBER".
     * It is used to analyze touch event usage stats.
     * </pre>
     *
     * <code>optional string keyboard_name = 7;</code>
     * @param value The bytes for keyboardName to set.
     */
    private void setKeyboardNameBytes(
        com.google.protobuf.ByteString value) {
      keyboardName_ = value.toStringUtf8();
      bitField0_ |= 0x00000010;
    }

    public static final int UPDATE_INPUT_MODE_FROM_SURROUNDING_TEXT_FIELD_NUMBER = 8;
    private boolean updateInputModeFromSurroundingText_;
    /**
     * <pre>
     * Enables Composer's input mode auto updating by using surrounding text.
     * For example, when a composition string is "ad", a carret is at the end,
     * and a user selects HIRAGANA mode, if the user moves the carret to between
     * "a" and "d" the mode will be automatically switch to ASCII (temporarily).
     * See details in the Composer::UpdateInputMode.
     * </pre>
     *
     * <code>optional bool update_input_mode_from_surrounding_text = 8 [default = true];</code>
     * @return Whether the updateInputModeFromSurroundingText field is set.
     */
    @java.lang.Override
    public boolean hasUpdateInputModeFromSurroundingText() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * Enables Composer's input mode auto updating by using surrounding text.
     * For example, when a composition string is "ad", a carret is at the end,
     * and a user selects HIRAGANA mode, if the user moves the carret to between
     * "a" and "d" the mode will be automatically switch to ASCII (temporarily).
     * See details in the Composer::UpdateInputMode.
     * </pre>
     *
     * <code>optional bool update_input_mode_from_surrounding_text = 8 [default = true];</code>
     * @return The updateInputModeFromSurroundingText.
     */
    @java.lang.Override
    public boolean getUpdateInputModeFromSurroundingText() {
      return updateInputModeFromSurroundingText_;
    }
    /**
     * <pre>
     * Enables Composer's input mode auto updating by using surrounding text.
     * For example, when a composition string is "ad", a carret is at the end,
     * and a user selects HIRAGANA mode, if the user moves the carret to between
     * "a" and "d" the mode will be automatically switch to ASCII (temporarily).
     * See details in the Composer::UpdateInputMode.
     * </pre>
     *
     * <code>optional bool update_input_mode_from_surrounding_text = 8 [default = true];</code>
     * @param value The updateInputModeFromSurroundingText to set.
     */
    private void setUpdateInputModeFromSurroundingText(boolean value) {
      bitField0_ |= 0x00000020;
      updateInputModeFromSurroundingText_ = value;
    }
    /**
     * <pre>
     * Enables Composer's input mode auto updating by using surrounding text.
     * For example, when a composition string is "ad", a carret is at the end,
     * and a user selects HIRAGANA mode, if the user moves the carret to between
     * "a" and "d" the mode will be automatically switch to ASCII (temporarily).
     * See details in the Composer::UpdateInputMode.
     * </pre>
     *
     * <code>optional bool update_input_mode_from_surrounding_text = 8 [default = true];</code>
     */
    private void clearUpdateInputModeFromSurroundingText() {
      bitField0_ = (bitField0_ & ~0x00000020);
      updateInputModeFromSurroundingText_ = true;
    }

    public static final int KANA_MODIFIER_INSENSITIVE_CONVERSION_FIELD_NUMBER = 9;
    private boolean kanaModifierInsensitiveConversion_;
    /**
     * <pre>
     * Enables Kana-modifier-insensitive conversion as follows:
     * 1) Voiced/Semi-voiced kana will be hit by non-modified kana.
     *    e.g.) "ば" and "ぱ" will be hit by key "は".
     * 2) Geminate consonant "っ" will be hit by non-modified kana "つ".
     * 3) Palatalized kana will be hit by non-modified kana.
     *    e.g.) "ゃ" will be hit by key "や".
     * Here is an example of the search: "学校" ("がっこう") will be hit
     * by "かつこう".
     * </pre>
     *
     * <code>optional bool kana_modifier_insensitive_conversion = 9 [default = false];</code>
     * @return Whether the kanaModifierInsensitiveConversion field is set.
     */
    @java.lang.Override
    public boolean hasKanaModifierInsensitiveConversion() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * Enables Kana-modifier-insensitive conversion as follows:
     * 1) Voiced/Semi-voiced kana will be hit by non-modified kana.
     *    e.g.) "ば" and "ぱ" will be hit by key "は".
     * 2) Geminate consonant "っ" will be hit by non-modified kana "つ".
     * 3) Palatalized kana will be hit by non-modified kana.
     *    e.g.) "ゃ" will be hit by key "や".
     * Here is an example of the search: "学校" ("がっこう") will be hit
     * by "かつこう".
     * </pre>
     *
     * <code>optional bool kana_modifier_insensitive_conversion = 9 [default = false];</code>
     * @return The kanaModifierInsensitiveConversion.
     */
    @java.lang.Override
    public boolean getKanaModifierInsensitiveConversion() {
      return kanaModifierInsensitiveConversion_;
    }
    /**
     * <pre>
     * Enables Kana-modifier-insensitive conversion as follows:
     * 1) Voiced/Semi-voiced kana will be hit by non-modified kana.
     *    e.g.) "ば" and "ぱ" will be hit by key "は".
     * 2) Geminate consonant "っ" will be hit by non-modified kana "つ".
     * 3) Palatalized kana will be hit by non-modified kana.
     *    e.g.) "ゃ" will be hit by key "や".
     * Here is an example of the search: "学校" ("がっこう") will be hit
     * by "かつこう".
     * </pre>
     *
     * <code>optional bool kana_modifier_insensitive_conversion = 9 [default = false];</code>
     * @param value The kanaModifierInsensitiveConversion to set.
     */
    private void setKanaModifierInsensitiveConversion(boolean value) {
      bitField0_ |= 0x00000040;
      kanaModifierInsensitiveConversion_ = value;
    }
    /**
     * <pre>
     * Enables Kana-modifier-insensitive conversion as follows:
     * 1) Voiced/Semi-voiced kana will be hit by non-modified kana.
     *    e.g.) "ば" and "ぱ" will be hit by key "は".
     * 2) Geminate consonant "っ" will be hit by non-modified kana "つ".
     * 3) Palatalized kana will be hit by non-modified kana.
     *    e.g.) "ゃ" will be hit by key "や".
     * Here is an example of the search: "学校" ("がっこう") will be hit
     * by "かつこう".
     * </pre>
     *
     * <code>optional bool kana_modifier_insensitive_conversion = 9 [default = false];</code>
     */
    private void clearKanaModifierInsensitiveConversion() {
      bitField0_ = (bitField0_ & ~0x00000040);
      kanaModifierInsensitiveConversion_ = false;
    }

    public static final int AUTO_PARTIAL_SUGGESTION_FIELD_NUMBER = 10;
    private boolean autoPartialSuggestion_;
    /**
     * <pre>
     * Enables Auto partial suggestion (prefix candidates).
     * For Auto partial suggestion, we can see candidates that match
     * the prefix of the input reading.
     * If we commit that candidate, we will show suggestions for remaining part
     * of key.
     * Note: This feature can be enabled only for mobile due to UX design.
     * </pre>
     *
     * <code>optional bool auto_partial_suggestion = 10 [default = false];</code>
     * @return Whether the autoPartialSuggestion field is set.
     */
    @java.lang.Override
    public boolean hasAutoPartialSuggestion() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * Enables Auto partial suggestion (prefix candidates).
     * For Auto partial suggestion, we can see candidates that match
     * the prefix of the input reading.
     * If we commit that candidate, we will show suggestions for remaining part
     * of key.
     * Note: This feature can be enabled only for mobile due to UX design.
     * </pre>
     *
     * <code>optional bool auto_partial_suggestion = 10 [default = false];</code>
     * @return The autoPartialSuggestion.
     */
    @java.lang.Override
    public boolean getAutoPartialSuggestion() {
      return autoPartialSuggestion_;
    }
    /**
     * <pre>
     * Enables Auto partial suggestion (prefix candidates).
     * For Auto partial suggestion, we can see candidates that match
     * the prefix of the input reading.
     * If we commit that candidate, we will show suggestions for remaining part
     * of key.
     * Note: This feature can be enabled only for mobile due to UX design.
     * </pre>
     *
     * <code>optional bool auto_partial_suggestion = 10 [default = false];</code>
     * @param value The autoPartialSuggestion to set.
     */
    private void setAutoPartialSuggestion(boolean value) {
      bitField0_ |= 0x00000080;
      autoPartialSuggestion_ = value;
    }
    /**
     * <pre>
     * Enables Auto partial suggestion (prefix candidates).
     * For Auto partial suggestion, we can see candidates that match
     * the prefix of the input reading.
     * If we commit that candidate, we will show suggestions for remaining part
     * of key.
     * Note: This feature can be enabled only for mobile due to UX design.
     * </pre>
     *
     * <code>optional bool auto_partial_suggestion = 10 [default = false];</code>
     */
    private void clearAutoPartialSuggestion() {
      bitField0_ = (bitField0_ & ~0x00000080);
      autoPartialSuggestion_ = false;
    }

    public static final int EMOJI_REWRITER_CAPABILITY_FIELD_NUMBER = 12;
    private int emojiRewriterCapability_;
    /**
     * <pre>
     * By default, Emoji rewriter works on conversion mode only.
     * </pre>
     *
     * <code>optional int32 emoji_rewriter_capability = 12 [default = 1];</code>
     * @return Whether the emojiRewriterCapability field is set.
     */
    @java.lang.Override
    public boolean hasEmojiRewriterCapability() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * By default, Emoji rewriter works on conversion mode only.
     * </pre>
     *
     * <code>optional int32 emoji_rewriter_capability = 12 [default = 1];</code>
     * @return The emojiRewriterCapability.
     */
    @java.lang.Override
    public int getEmojiRewriterCapability() {
      return emojiRewriterCapability_;
    }
    /**
     * <pre>
     * By default, Emoji rewriter works on conversion mode only.
     * </pre>
     *
     * <code>optional int32 emoji_rewriter_capability = 12 [default = 1];</code>
     * @param value The emojiRewriterCapability to set.
     */
    private void setEmojiRewriterCapability(int value) {
      bitField0_ |= 0x00000100;
      emojiRewriterCapability_ = value;
    }
    /**
     * <pre>
     * By default, Emoji rewriter works on conversion mode only.
     * </pre>
     *
     * <code>optional int32 emoji_rewriter_capability = 12 [default = 1];</code>
     */
    private void clearEmojiRewriterCapability() {
      bitField0_ = (bitField0_ & ~0x00000100);
      emojiRewriterCapability_ = 1;
    }

    public static final int CROSSING_EDGE_BEHAVIOR_FIELD_NUMBER = 13;
    private int crossingEdgeBehavior_;
    /**
     * <code>optional .mozc.commands.Request.CrossingEdgeBehavior crossing_edge_behavior = 13 [default = DO_NOTHING];</code>
     * @return Whether the crossingEdgeBehavior field is set.
     */
    @java.lang.Override
    public boolean hasCrossingEdgeBehavior() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <code>optional .mozc.commands.Request.CrossingEdgeBehavior crossing_edge_behavior = 13 [default = DO_NOTHING];</code>
     * @return The crossingEdgeBehavior.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.CrossingEdgeBehavior getCrossingEdgeBehavior() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.CrossingEdgeBehavior result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.CrossingEdgeBehavior.forNumber(crossingEdgeBehavior_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.CrossingEdgeBehavior.DO_NOTHING : result;
    }
    /**
     * <code>optional .mozc.commands.Request.CrossingEdgeBehavior crossing_edge_behavior = 13 [default = DO_NOTHING];</code>
     * @param value The crossingEdgeBehavior to set.
     */
    private void setCrossingEdgeBehavior(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.CrossingEdgeBehavior value) {
      crossingEdgeBehavior_ = value.getNumber();
      bitField0_ |= 0x00000200;
    }
    /**
     * <code>optional .mozc.commands.Request.CrossingEdgeBehavior crossing_edge_behavior = 13 [default = DO_NOTHING];</code>
     */
    private void clearCrossingEdgeBehavior() {
      bitField0_ = (bitField0_ & ~0x00000200);
      crossingEdgeBehavior_ = 0;
    }

    public static final int LANGUAGE_AWARE_INPUT_FIELD_NUMBER = 14;
    private int languageAwareInput_;
    /**
     * <code>optional .mozc.commands.Request.LanguageAwareInputBehavior language_aware_input = 14 [default = DEFAULT_LANGUAGE_AWARE_BEHAVIOR];</code>
     * @return Whether the languageAwareInput field is set.
     */
    @java.lang.Override
    public boolean hasLanguageAwareInput() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     * <code>optional .mozc.commands.Request.LanguageAwareInputBehavior language_aware_input = 14 [default = DEFAULT_LANGUAGE_AWARE_BEHAVIOR];</code>
     * @return The languageAwareInput.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.LanguageAwareInputBehavior getLanguageAwareInput() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.LanguageAwareInputBehavior result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.LanguageAwareInputBehavior.forNumber(languageAwareInput_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.LanguageAwareInputBehavior.DEFAULT_LANGUAGE_AWARE_BEHAVIOR : result;
    }
    /**
     * <code>optional .mozc.commands.Request.LanguageAwareInputBehavior language_aware_input = 14 [default = DEFAULT_LANGUAGE_AWARE_BEHAVIOR];</code>
     * @param value The languageAwareInput to set.
     */
    private void setLanguageAwareInput(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.LanguageAwareInputBehavior value) {
      languageAwareInput_ = value.getNumber();
      bitField0_ |= 0x00000400;
    }
    /**
     * <code>optional .mozc.commands.Request.LanguageAwareInputBehavior language_aware_input = 14 [default = DEFAULT_LANGUAGE_AWARE_BEHAVIOR];</code>
     */
    private void clearLanguageAwareInput() {
      bitField0_ = (bitField0_ & ~0x00000400);
      languageAwareInput_ = 0;
    }

    public static final int CANDIDATE_PAGE_SIZE_FIELD_NUMBER = 15;
    private int candidatePageSize_;
    /**
     * <pre>
     * Page size of the candidate list.
     * </pre>
     *
     * <code>optional int32 candidate_page_size = 15 [default = 9];</code>
     * @return Whether the candidatePageSize field is set.
     */
    @java.lang.Override
    public boolean hasCandidatePageSize() {
      return ((bitField0_ & 0x00000800) != 0);
    }
    /**
     * <pre>
     * Page size of the candidate list.
     * </pre>
     *
     * <code>optional int32 candidate_page_size = 15 [default = 9];</code>
     * @return The candidatePageSize.
     */
    @java.lang.Override
    public int getCandidatePageSize() {
      return candidatePageSize_;
    }
    /**
     * <pre>
     * Page size of the candidate list.
     * </pre>
     *
     * <code>optional int32 candidate_page_size = 15 [default = 9];</code>
     * @param value The candidatePageSize to set.
     */
    private void setCandidatePageSize(int value) {
      bitField0_ |= 0x00000800;
      candidatePageSize_ = value;
    }
    /**
     * <pre>
     * Page size of the candidate list.
     * </pre>
     *
     * <code>optional int32 candidate_page_size = 15 [default = 9];</code>
     */
    private void clearCandidatePageSize() {
      bitField0_ = (bitField0_ & ~0x00000800);
      candidatePageSize_ = 9;
    }

    public static final int CANDIDATES_SIZE_LIMIT_FIELD_NUMBER = 16;
    private int candidatesSizeLimit_;
    /**
     * <pre>
     * The maximum limit of the candidates size.
     * If not set, converter doesn't limit the size.
     * NOTE: Each segment has at least one candidate and meta candidates even if
     *       this value is set to 0.
     * </pre>
     *
     * <code>optional int32 candidates_size_limit = 16;</code>
     * @return Whether the candidatesSizeLimit field is set.
     */
    @java.lang.Override
    public boolean hasCandidatesSizeLimit() {
      return ((bitField0_ & 0x00001000) != 0);
    }
    /**
     * <pre>
     * The maximum limit of the candidates size.
     * If not set, converter doesn't limit the size.
     * NOTE: Each segment has at least one candidate and meta candidates even if
     *       this value is set to 0.
     * </pre>
     *
     * <code>optional int32 candidates_size_limit = 16;</code>
     * @return The candidatesSizeLimit.
     */
    @java.lang.Override
    public int getCandidatesSizeLimit() {
      return candidatesSizeLimit_;
    }
    /**
     * <pre>
     * The maximum limit of the candidates size.
     * If not set, converter doesn't limit the size.
     * NOTE: Each segment has at least one candidate and meta candidates even if
     *       this value is set to 0.
     * </pre>
     *
     * <code>optional int32 candidates_size_limit = 16;</code>
     * @param value The candidatesSizeLimit to set.
     */
    private void setCandidatesSizeLimit(int value) {
      bitField0_ |= 0x00001000;
      candidatesSizeLimit_ = value;
    }
    /**
     * <pre>
     * The maximum limit of the candidates size.
     * If not set, converter doesn't limit the size.
     * NOTE: Each segment has at least one candidate and meta candidates even if
     *       this value is set to 0.
     * </pre>
     *
     * <code>optional int32 candidates_size_limit = 16;</code>
     */
    private void clearCandidatesSizeLimit() {
      bitField0_ = (bitField0_ & ~0x00001000);
      candidatesSizeLimit_ = 0;
    }

    public static final int DECODER_EXPERIMENT_PARAMS_FIELD_NUMBER = 17;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams decoderExperimentParams_;
    /**
     * <pre>
     * Experimentally changes the decoder's behavior.
     * This flag is usually populated through the phenotype flags.
     * </pre>
     *
     * <code>optional .mozc.commands.DecoderExperimentParams decoder_experiment_params = 17;</code>
     */
    @java.lang.Override
    public boolean hasDecoderExperimentParams() {
      return ((bitField0_ & 0x00002000) != 0);
    }
    /**
     * <pre>
     * Experimentally changes the decoder's behavior.
     * This flag is usually populated through the phenotype flags.
     * </pre>
     *
     * <code>optional .mozc.commands.DecoderExperimentParams decoder_experiment_params = 17;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams getDecoderExperimentParams() {
      return decoderExperimentParams_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams.getDefaultInstance() : decoderExperimentParams_;
    }
    /**
     * <pre>
     * Experimentally changes the decoder's behavior.
     * This flag is usually populated through the phenotype flags.
     * </pre>
     *
     * <code>optional .mozc.commands.DecoderExperimentParams decoder_experiment_params = 17;</code>
     */
    private void setDecoderExperimentParams(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams value) {
      value.getClass();
  decoderExperimentParams_ = value;
      bitField0_ |= 0x00002000;
      }
    /**
     * <pre>
     * Experimentally changes the decoder's behavior.
     * This flag is usually populated through the phenotype flags.
     * </pre>
     *
     * <code>optional .mozc.commands.DecoderExperimentParams decoder_experiment_params = 17;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeDecoderExperimentParams(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams value) {
      value.getClass();
  if (decoderExperimentParams_ != null &&
          decoderExperimentParams_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams.getDefaultInstance()) {
        decoderExperimentParams_ =
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams.newBuilder(decoderExperimentParams_).mergeFrom(value).buildPartial();
      } else {
        decoderExperimentParams_ = value;
      }
      bitField0_ |= 0x00002000;
    }
    /**
     * <pre>
     * Experimentally changes the decoder's behavior.
     * This flag is usually populated through the phenotype flags.
     * </pre>
     *
     * <code>optional .mozc.commands.DecoderExperimentParams decoder_experiment_params = 17;</code>
     */
    private void clearDecoderExperimentParams() {  decoderExperimentParams_ = null;
      bitField0_ = (bitField0_ & ~0x00002000);
    }

    public static final int FILL_INCOGNITO_CANDIDATE_WORDS_FIELD_NUMBER = 18;
    private boolean fillIncognitoCandidateWords_;
    /**
     * <pre>
     * Fills incognito_candidate_words filed of output.
     * </pre>
     *
     * <code>optional bool fill_incognito_candidate_words = 18 [default = false];</code>
     * @return Whether the fillIncognitoCandidateWords field is set.
     */
    @java.lang.Override
    public boolean hasFillIncognitoCandidateWords() {
      return ((bitField0_ & 0x00004000) != 0);
    }
    /**
     * <pre>
     * Fills incognito_candidate_words filed of output.
     * </pre>
     *
     * <code>optional bool fill_incognito_candidate_words = 18 [default = false];</code>
     * @return The fillIncognitoCandidateWords.
     */
    @java.lang.Override
    public boolean getFillIncognitoCandidateWords() {
      return fillIncognitoCandidateWords_;
    }
    /**
     * <pre>
     * Fills incognito_candidate_words filed of output.
     * </pre>
     *
     * <code>optional bool fill_incognito_candidate_words = 18 [default = false];</code>
     * @param value The fillIncognitoCandidateWords to set.
     */
    private void setFillIncognitoCandidateWords(boolean value) {
      bitField0_ |= 0x00004000;
      fillIncognitoCandidateWords_ = value;
    }
    /**
     * <pre>
     * Fills incognito_candidate_words filed of output.
     * </pre>
     *
     * <code>optional bool fill_incognito_candidate_words = 18 [default = false];</code>
     */
    private void clearFillIncognitoCandidateWords() {
      bitField0_ = (bitField0_ & ~0x00004000);
      fillIncognitoCandidateWords_ = false;
    }

    public static final int ENABLE_A11Y_DESCRIPTION_FIELD_NUMBER = 20;
    private boolean enableA11YDescription_;
    /**
     * <pre>
     * Enables a11y support for candidates.
     * If this field is set to true, a11y description is set to each candidate.
     * </pre>
     *
     * <code>optional bool enable_a11y_description = 20 [default = false];</code>
     * @return Whether the enableA11yDescription field is set.
     */
    @java.lang.Override
    public boolean hasEnableA11YDescription() {
      return ((bitField0_ & 0x00008000) != 0);
    }
    /**
     * <pre>
     * Enables a11y support for candidates.
     * If this field is set to true, a11y description is set to each candidate.
     * </pre>
     *
     * <code>optional bool enable_a11y_description = 20 [default = false];</code>
     * @return The enableA11yDescription.
     */
    @java.lang.Override
    public boolean getEnableA11YDescription() {
      return enableA11YDescription_;
    }
    /**
     * <pre>
     * Enables a11y support for candidates.
     * If this field is set to true, a11y description is set to each candidate.
     * </pre>
     *
     * <code>optional bool enable_a11y_description = 20 [default = false];</code>
     * @param value The enableA11yDescription to set.
     */
    private void setEnableA11YDescription(boolean value) {
      bitField0_ |= 0x00008000;
      enableA11YDescription_ = value;
    }
    /**
     * <pre>
     * Enables a11y support for candidates.
     * If this field is set to true, a11y description is set to each candidate.
     * </pre>
     *
     * <code>optional bool enable_a11y_description = 20 [default = false];</code>
     */
    private void clearEnableA11YDescription() {
      bitField0_ = (bitField0_ & ~0x00008000);
      enableA11YDescription_ = false;
    }

    public static final int ADDITIONAL_RENDERABLE_CHARACTER_GROUPS_FIELD_NUMBER = 21;
    private com.google.protobuf.Internal.IntList additionalRenderableCharacterGroups_;
    private static final com.google.protobuf.Internal.ListAdapter.Converter<
        java.lang.Integer, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup> additionalRenderableCharacterGroups_converter_ =
            new com.google.protobuf.Internal.ListAdapter.Converter<
                java.lang.Integer, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup>() {
              @java.lang.Override
              public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup convert(java.lang.Integer from) {
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup.forNumber(from);
                return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup.EMPTY : result;
              }
            };
    /**
     * <pre>
     * Characters in the union of this list of groups can be contained in
     * candidates.
     * This feature is distinct from user preference. Do not make these option
     * user selectable.
     * </pre>
     *
     * <code>repeated .mozc.commands.Request.AdditionalRenderableCharacterGroup additional_renderable_character_groups = 21 [packed = true];</code>
     * @return A list containing the additionalRenderableCharacterGroups.
     */
    @java.lang.Override
    public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup> getAdditionalRenderableCharacterGroupsList() {
      return new com.google.protobuf.Internal.ListAdapter<
          java.lang.Integer, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup>(additionalRenderableCharacterGroups_, additionalRenderableCharacterGroups_converter_);
    }
    /**
     * <pre>
     * Characters in the union of this list of groups can be contained in
     * candidates.
     * This feature is distinct from user preference. Do not make these option
     * user selectable.
     * </pre>
     *
     * <code>repeated .mozc.commands.Request.AdditionalRenderableCharacterGroup additional_renderable_character_groups = 21 [packed = true];</code>
     * @return The count of additionalRenderableCharacterGroups.
     */
    @java.lang.Override
    public int getAdditionalRenderableCharacterGroupsCount() {
      return additionalRenderableCharacterGroups_.size();
    }
    /**
     * <pre>
     * Characters in the union of this list of groups can be contained in
     * candidates.
     * This feature is distinct from user preference. Do not make these option
     * user selectable.
     * </pre>
     *
     * <code>repeated .mozc.commands.Request.AdditionalRenderableCharacterGroup additional_renderable_character_groups = 21 [packed = true];</code>
     * @param index The index of the element to return.
     * @return The additionalRenderableCharacterGroups at the given index.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup getAdditionalRenderableCharacterGroups(int index) {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup.forNumber(additionalRenderableCharacterGroups_.getInt(index));
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup.EMPTY : result;
    }
    private int additionalRenderableCharacterGroupsMemoizedSerializedSize;
    private void ensureAdditionalRenderableCharacterGroupsIsMutable() {
      com.google.protobuf.Internal.IntList tmp = additionalRenderableCharacterGroups_;
      if (!tmp.isModifiable()) {
        additionalRenderableCharacterGroups_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
      }
    }
    /**
     * <pre>
     * Characters in the union of this list of groups can be contained in
     * candidates.
     * This feature is distinct from user preference. Do not make these option
     * user selectable.
     * </pre>
     *
     * <code>repeated .mozc.commands.Request.AdditionalRenderableCharacterGroup additional_renderable_character_groups = 21 [packed = true];</code>
     * @param index The index to set the value at.
     * @param value The additionalRenderableCharacterGroups to set.
     */
    private void setAdditionalRenderableCharacterGroups(
        int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup value) {
      value.getClass();
  ensureAdditionalRenderableCharacterGroupsIsMutable();
      additionalRenderableCharacterGroups_.setInt(index, value.getNumber());
    }
    /**
     * <pre>
     * Characters in the union of this list of groups can be contained in
     * candidates.
     * This feature is distinct from user preference. Do not make these option
     * user selectable.
     * </pre>
     *
     * <code>repeated .mozc.commands.Request.AdditionalRenderableCharacterGroup additional_renderable_character_groups = 21 [packed = true];</code>
     * @param value The additionalRenderableCharacterGroups to add.
     */
    private void addAdditionalRenderableCharacterGroups(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup value) {
      value.getClass();
  ensureAdditionalRenderableCharacterGroupsIsMutable();
      additionalRenderableCharacterGroups_.addInt(value.getNumber());
    }
    /**
     * <pre>
     * Characters in the union of this list of groups can be contained in
     * candidates.
     * This feature is distinct from user preference. Do not make these option
     * user selectable.
     * </pre>
     *
     * <code>repeated .mozc.commands.Request.AdditionalRenderableCharacterGroup additional_renderable_character_groups = 21 [packed = true];</code>
     * @param values The additionalRenderableCharacterGroups to add.
     */
    private void addAllAdditionalRenderableCharacterGroups(
        java.lang.Iterable<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup> values) {
      ensureAdditionalRenderableCharacterGroupsIsMutable();
      for (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup value : values) {
        additionalRenderableCharacterGroups_.addInt(value.getNumber());
      }
    }
    /**
     * <pre>
     * Characters in the union of this list of groups can be contained in
     * candidates.
     * This feature is distinct from user preference. Do not make these option
     * user selectable.
     * </pre>
     *
     * <code>repeated .mozc.commands.Request.AdditionalRenderableCharacterGroup additional_renderable_character_groups = 21 [packed = true];</code>
     */
    private void clearAdditionalRenderableCharacterGroups() {
      additionalRenderableCharacterGroups_ = emptyIntList();
    }

    public static final int IS_HANDWRITING_FIELD_NUMBER = 22;
    private boolean isHandwriting_;
    /**
     * <pre>
     * Whether the request is from handwriting. Candidates can be optimized
     * differently for handwriting.
     * For example, we support 混ぜ書き conversion ("かん字" → "漢字") for
     * handwriting.
     * </pre>
     *
     * <code>optional bool is_handwriting = 22 [default = false];</code>
     * @return Whether the isHandwriting field is set.
     */
    @java.lang.Override
    public boolean hasIsHandwriting() {
      return ((bitField0_ & 0x00010000) != 0);
    }
    /**
     * <pre>
     * Whether the request is from handwriting. Candidates can be optimized
     * differently for handwriting.
     * For example, we support 混ぜ書き conversion ("かん字" → "漢字") for
     * handwriting.
     * </pre>
     *
     * <code>optional bool is_handwriting = 22 [default = false];</code>
     * @return The isHandwriting.
     */
    @java.lang.Override
    public boolean getIsHandwriting() {
      return isHandwriting_;
    }
    /**
     * <pre>
     * Whether the request is from handwriting. Candidates can be optimized
     * differently for handwriting.
     * For example, we support 混ぜ書き conversion ("かん字" → "漢字") for
     * handwriting.
     * </pre>
     *
     * <code>optional bool is_handwriting = 22 [default = false];</code>
     * @param value The isHandwriting to set.
     */
    private void setIsHandwriting(boolean value) {
      bitField0_ |= 0x00010000;
      isHandwriting_ = value;
    }
    /**
     * <pre>
     * Whether the request is from handwriting. Candidates can be optimized
     * differently for handwriting.
     * For example, we support 混ぜ書き conversion ("かん字" → "漢字") for
     * handwriting.
     * </pre>
     *
     * <code>optional bool is_handwriting = 22 [default = false];</code>
     */
    private void clearIsHandwriting() {
      bitField0_ = (bitField0_ & ~0x00010000);
      isHandwriting_ = false;
    }

    public static final int IS_INCOGNITO_MODE_FIELD_NUMBER = 23;
    private boolean isIncognitoMode_;
    /**
     * <pre>
     * Whether the conversion is performed in incognito mode.
     * In incognito mode, the conversion is performed without using
     * user history and user dictionary.
     * When any of this value and Config::incognito_mode are true,
     * incognito mode is enabled.
     * Clients needs to check ConversionRequest::incognito_mode() instead of
     * this value directly, as the incognito mode can be set in other ways.
     * </pre>
     *
     * <code>optional bool is_incognito_mode = 23 [default = false];</code>
     * @return Whether the isIncognitoMode field is set.
     */
    @java.lang.Override
    public boolean hasIsIncognitoMode() {
      return ((bitField0_ & 0x00020000) != 0);
    }
    /**
     * <pre>
     * Whether the conversion is performed in incognito mode.
     * In incognito mode, the conversion is performed without using
     * user history and user dictionary.
     * When any of this value and Config::incognito_mode are true,
     * incognito mode is enabled.
     * Clients needs to check ConversionRequest::incognito_mode() instead of
     * this value directly, as the incognito mode can be set in other ways.
     * </pre>
     *
     * <code>optional bool is_incognito_mode = 23 [default = false];</code>
     * @return The isIncognitoMode.
     */
    @java.lang.Override
    public boolean getIsIncognitoMode() {
      return isIncognitoMode_;
    }
    /**
     * <pre>
     * Whether the conversion is performed in incognito mode.
     * In incognito mode, the conversion is performed without using
     * user history and user dictionary.
     * When any of this value and Config::incognito_mode are true,
     * incognito mode is enabled.
     * Clients needs to check ConversionRequest::incognito_mode() instead of
     * this value directly, as the incognito mode can be set in other ways.
     * </pre>
     *
     * <code>optional bool is_incognito_mode = 23 [default = false];</code>
     * @param value The isIncognitoMode to set.
     */
    private void setIsIncognitoMode(boolean value) {
      bitField0_ |= 0x00020000;
      isIncognitoMode_ = value;
    }
    /**
     * <pre>
     * Whether the conversion is performed in incognito mode.
     * In incognito mode, the conversion is performed without using
     * user history and user dictionary.
     * When any of this value and Config::incognito_mode are true,
     * incognito mode is enabled.
     * Clients needs to check ConversionRequest::incognito_mode() instead of
     * this value directly, as the incognito mode can be set in other ways.
     * </pre>
     *
     * <code>optional bool is_incognito_mode = 23 [default = false];</code>
     */
    private void clearIsIncognitoMode() {
      bitField0_ = (bitField0_ & ~0x00020000);
      isIncognitoMode_ = false;
    }

    public static final int DISPLAY_VALUE_CAPABILITY_FIELD_NUMBER = 24;
    private int displayValueCapability_;
    /**
     * <code>optional .mozc.commands.Request.DisplayValueCapability display_value_capability = 24 [default = NOT_SUPPORTED];</code>
     * @return Whether the displayValueCapability field is set.
     */
    @java.lang.Override
    public boolean hasDisplayValueCapability() {
      return ((bitField0_ & 0x00040000) != 0);
    }
    /**
     * <code>optional .mozc.commands.Request.DisplayValueCapability display_value_capability = 24 [default = NOT_SUPPORTED];</code>
     * @return The displayValueCapability.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.DisplayValueCapability getDisplayValueCapability() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.DisplayValueCapability result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.DisplayValueCapability.forNumber(displayValueCapability_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.DisplayValueCapability.NOT_SUPPORTED : result;
    }
    /**
     * <code>optional .mozc.commands.Request.DisplayValueCapability display_value_capability = 24 [default = NOT_SUPPORTED];</code>
     * @param value The displayValueCapability to set.
     */
    private void setDisplayValueCapability(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.DisplayValueCapability value) {
      displayValueCapability_ = value.getNumber();
      bitField0_ |= 0x00040000;
    }
    /**
     * <code>optional .mozc.commands.Request.DisplayValueCapability display_value_capability = 24 [default = NOT_SUPPORTED];</code>
     */
    private void clearDisplayValueCapability() {
      bitField0_ = (bitField0_ & ~0x00040000);
      displayValueCapability_ = 0;
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Clients' request to the server.
     * Users cannot modify this.
     * In the future each request may be able to be overwritten by Config.
     * The server does not have to obey this request.
     * Next ID: 25
     * </pre>
     *
     * Protobuf type {@code mozc.commands.Request}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request, Builder> implements
        // @@protoc_insertion_point(builder_implements:mozc.commands.Request)
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.RequestOrBuilder {
      // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Enable zero query suggestion.
       * </pre>
       *
       * <code>optional bool zero_query_suggestion = 1 [default = false];</code>
       * @return Whether the zeroQuerySuggestion field is set.
       */
      @java.lang.Override
      public boolean hasZeroQuerySuggestion() {
        return instance.hasZeroQuerySuggestion();
      }
      /**
       * <pre>
       * Enable zero query suggestion.
       * </pre>
       *
       * <code>optional bool zero_query_suggestion = 1 [default = false];</code>
       * @return The zeroQuerySuggestion.
       */
      @java.lang.Override
      public boolean getZeroQuerySuggestion() {
        return instance.getZeroQuerySuggestion();
      }
      /**
       * <pre>
       * Enable zero query suggestion.
       * </pre>
       *
       * <code>optional bool zero_query_suggestion = 1 [default = false];</code>
       * @param value The zeroQuerySuggestion to set.
       * @return This builder for chaining.
       */
      public Builder setZeroQuerySuggestion(boolean value) {
        copyOnWrite();
        instance.setZeroQuerySuggestion(value);
        return this;
      }
      /**
       * <pre>
       * Enable zero query suggestion.
       * </pre>
       *
       * <code>optional bool zero_query_suggestion = 1 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearZeroQuerySuggestion() {
        copyOnWrite();
        instance.clearZeroQuerySuggestion();
        return this;
      }

      /**
       * <pre>
       * Conversion's candidate includes suggestion, prediction and conversion.
       * </pre>
       *
       * <code>optional bool mixed_conversion = 2 [default = false];</code>
       * @return Whether the mixedConversion field is set.
       */
      @java.lang.Override
      public boolean hasMixedConversion() {
        return instance.hasMixedConversion();
      }
      /**
       * <pre>
       * Conversion's candidate includes suggestion, prediction and conversion.
       * </pre>
       *
       * <code>optional bool mixed_conversion = 2 [default = false];</code>
       * @return The mixedConversion.
       */
      @java.lang.Override
      public boolean getMixedConversion() {
        return instance.getMixedConversion();
      }
      /**
       * <pre>
       * Conversion's candidate includes suggestion, prediction and conversion.
       * </pre>
       *
       * <code>optional bool mixed_conversion = 2 [default = false];</code>
       * @param value The mixedConversion to set.
       * @return This builder for chaining.
       */
      public Builder setMixedConversion(boolean value) {
        copyOnWrite();
        instance.setMixedConversion(value);
        return this;
      }
      /**
       * <pre>
       * Conversion's candidate includes suggestion, prediction and conversion.
       * </pre>
       *
       * <code>optional bool mixed_conversion = 2 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearMixedConversion() {
        copyOnWrite();
        instance.clearMixedConversion();
        return this;
      }

      /**
       * <pre>
       * Use special Romanji table.
       * </pre>
       *
       * <code>optional .mozc.commands.Request.SpecialRomanjiTable special_romanji_table = 4 [default = DEFAULT_TABLE];</code>
       * @return Whether the specialRomanjiTable field is set.
       */
      @java.lang.Override
      public boolean hasSpecialRomanjiTable() {
        return instance.hasSpecialRomanjiTable();
      }
      /**
       * <pre>
       * Use special Romanji table.
       * </pre>
       *
       * <code>optional .mozc.commands.Request.SpecialRomanjiTable special_romanji_table = 4 [default = DEFAULT_TABLE];</code>
       * @return The specialRomanjiTable.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.SpecialRomanjiTable getSpecialRomanjiTable() {
        return instance.getSpecialRomanjiTable();
      }
      /**
       * <pre>
       * Use special Romanji table.
       * </pre>
       *
       * <code>optional .mozc.commands.Request.SpecialRomanjiTable special_romanji_table = 4 [default = DEFAULT_TABLE];</code>
       * @param value The enum numeric value on the wire for specialRomanjiTable to set.
       * @return This builder for chaining.
       */
      public Builder setSpecialRomanjiTable(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.SpecialRomanjiTable value) {
        copyOnWrite();
        instance.setSpecialRomanjiTable(value);
        return this;
      }
      /**
       * <pre>
       * Use special Romanji table.
       * </pre>
       *
       * <code>optional .mozc.commands.Request.SpecialRomanjiTable special_romanji_table = 4 [default = DEFAULT_TABLE];</code>
       * @return This builder for chaining.
       */
      public Builder clearSpecialRomanjiTable() {
        copyOnWrite();
        instance.clearSpecialRomanjiTable();
        return this;
      }

      /**
       * <code>optional .mozc.commands.Request.SpaceOnAlphanumeric space_on_alphanumeric = 6 [default = SPACE_OR_CONVERT_KEEPING_COMPOSITION];</code>
       * @return Whether the spaceOnAlphanumeric field is set.
       */
      @java.lang.Override
      public boolean hasSpaceOnAlphanumeric() {
        return instance.hasSpaceOnAlphanumeric();
      }
      /**
       * <code>optional .mozc.commands.Request.SpaceOnAlphanumeric space_on_alphanumeric = 6 [default = SPACE_OR_CONVERT_KEEPING_COMPOSITION];</code>
       * @return The spaceOnAlphanumeric.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.SpaceOnAlphanumeric getSpaceOnAlphanumeric() {
        return instance.getSpaceOnAlphanumeric();
      }
      /**
       * <code>optional .mozc.commands.Request.SpaceOnAlphanumeric space_on_alphanumeric = 6 [default = SPACE_OR_CONVERT_KEEPING_COMPOSITION];</code>
       * @param value The enum numeric value on the wire for spaceOnAlphanumeric to set.
       * @return This builder for chaining.
       */
      public Builder setSpaceOnAlphanumeric(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.SpaceOnAlphanumeric value) {
        copyOnWrite();
        instance.setSpaceOnAlphanumeric(value);
        return this;
      }
      /**
       * <code>optional .mozc.commands.Request.SpaceOnAlphanumeric space_on_alphanumeric = 6 [default = SPACE_OR_CONVERT_KEEPING_COMPOSITION];</code>
       * @return This builder for chaining.
       */
      public Builder clearSpaceOnAlphanumeric() {
        copyOnWrite();
        instance.clearSpaceOnAlphanumeric();
        return this;
      }

      /**
       * <pre>
       * Keyboard name for touch devices.
       * For example, "TWELVE_KEY_TOGGLE_KANA", "QWERTY_KANA_NUMBER".
       * It is used to analyze touch event usage stats.
       * </pre>
       *
       * <code>optional string keyboard_name = 7;</code>
       * @return Whether the keyboardName field is set.
       */
      @java.lang.Override
      public boolean hasKeyboardName() {
        return instance.hasKeyboardName();
      }
      /**
       * <pre>
       * Keyboard name for touch devices.
       * For example, "TWELVE_KEY_TOGGLE_KANA", "QWERTY_KANA_NUMBER".
       * It is used to analyze touch event usage stats.
       * </pre>
       *
       * <code>optional string keyboard_name = 7;</code>
       * @return The keyboardName.
       */
      @java.lang.Override
      public java.lang.String getKeyboardName() {
        return instance.getKeyboardName();
      }
      /**
       * <pre>
       * Keyboard name for touch devices.
       * For example, "TWELVE_KEY_TOGGLE_KANA", "QWERTY_KANA_NUMBER".
       * It is used to analyze touch event usage stats.
       * </pre>
       *
       * <code>optional string keyboard_name = 7;</code>
       * @return The bytes for keyboardName.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getKeyboardNameBytes() {
        return instance.getKeyboardNameBytes();
      }
      /**
       * <pre>
       * Keyboard name for touch devices.
       * For example, "TWELVE_KEY_TOGGLE_KANA", "QWERTY_KANA_NUMBER".
       * It is used to analyze touch event usage stats.
       * </pre>
       *
       * <code>optional string keyboard_name = 7;</code>
       * @param value The keyboardName to set.
       * @return This builder for chaining.
       */
      public Builder setKeyboardName(
          java.lang.String value) {
        copyOnWrite();
        instance.setKeyboardName(value);
        return this;
      }
      /**
       * <pre>
       * Keyboard name for touch devices.
       * For example, "TWELVE_KEY_TOGGLE_KANA", "QWERTY_KANA_NUMBER".
       * It is used to analyze touch event usage stats.
       * </pre>
       *
       * <code>optional string keyboard_name = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearKeyboardName() {
        copyOnWrite();
        instance.clearKeyboardName();
        return this;
      }
      /**
       * <pre>
       * Keyboard name for touch devices.
       * For example, "TWELVE_KEY_TOGGLE_KANA", "QWERTY_KANA_NUMBER".
       * It is used to analyze touch event usage stats.
       * </pre>
       *
       * <code>optional string keyboard_name = 7;</code>
       * @param value The bytes for keyboardName to set.
       * @return This builder for chaining.
       */
      public Builder setKeyboardNameBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setKeyboardNameBytes(value);
        return this;
      }

      /**
       * <pre>
       * Enables Composer's input mode auto updating by using surrounding text.
       * For example, when a composition string is "ad", a carret is at the end,
       * and a user selects HIRAGANA mode, if the user moves the carret to between
       * "a" and "d" the mode will be automatically switch to ASCII (temporarily).
       * See details in the Composer::UpdateInputMode.
       * </pre>
       *
       * <code>optional bool update_input_mode_from_surrounding_text = 8 [default = true];</code>
       * @return Whether the updateInputModeFromSurroundingText field is set.
       */
      @java.lang.Override
      public boolean hasUpdateInputModeFromSurroundingText() {
        return instance.hasUpdateInputModeFromSurroundingText();
      }
      /**
       * <pre>
       * Enables Composer's input mode auto updating by using surrounding text.
       * For example, when a composition string is "ad", a carret is at the end,
       * and a user selects HIRAGANA mode, if the user moves the carret to between
       * "a" and "d" the mode will be automatically switch to ASCII (temporarily).
       * See details in the Composer::UpdateInputMode.
       * </pre>
       *
       * <code>optional bool update_input_mode_from_surrounding_text = 8 [default = true];</code>
       * @return The updateInputModeFromSurroundingText.
       */
      @java.lang.Override
      public boolean getUpdateInputModeFromSurroundingText() {
        return instance.getUpdateInputModeFromSurroundingText();
      }
      /**
       * <pre>
       * Enables Composer's input mode auto updating by using surrounding text.
       * For example, when a composition string is "ad", a carret is at the end,
       * and a user selects HIRAGANA mode, if the user moves the carret to between
       * "a" and "d" the mode will be automatically switch to ASCII (temporarily).
       * See details in the Composer::UpdateInputMode.
       * </pre>
       *
       * <code>optional bool update_input_mode_from_surrounding_text = 8 [default = true];</code>
       * @param value The updateInputModeFromSurroundingText to set.
       * @return This builder for chaining.
       */
      public Builder setUpdateInputModeFromSurroundingText(boolean value) {
        copyOnWrite();
        instance.setUpdateInputModeFromSurroundingText(value);
        return this;
      }
      /**
       * <pre>
       * Enables Composer's input mode auto updating by using surrounding text.
       * For example, when a composition string is "ad", a carret is at the end,
       * and a user selects HIRAGANA mode, if the user moves the carret to between
       * "a" and "d" the mode will be automatically switch to ASCII (temporarily).
       * See details in the Composer::UpdateInputMode.
       * </pre>
       *
       * <code>optional bool update_input_mode_from_surrounding_text = 8 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearUpdateInputModeFromSurroundingText() {
        copyOnWrite();
        instance.clearUpdateInputModeFromSurroundingText();
        return this;
      }

      /**
       * <pre>
       * Enables Kana-modifier-insensitive conversion as follows:
       * 1) Voiced/Semi-voiced kana will be hit by non-modified kana.
       *    e.g.) "ば" and "ぱ" will be hit by key "は".
       * 2) Geminate consonant "っ" will be hit by non-modified kana "つ".
       * 3) Palatalized kana will be hit by non-modified kana.
       *    e.g.) "ゃ" will be hit by key "や".
       * Here is an example of the search: "学校" ("がっこう") will be hit
       * by "かつこう".
       * </pre>
       *
       * <code>optional bool kana_modifier_insensitive_conversion = 9 [default = false];</code>
       * @return Whether the kanaModifierInsensitiveConversion field is set.
       */
      @java.lang.Override
      public boolean hasKanaModifierInsensitiveConversion() {
        return instance.hasKanaModifierInsensitiveConversion();
      }
      /**
       * <pre>
       * Enables Kana-modifier-insensitive conversion as follows:
       * 1) Voiced/Semi-voiced kana will be hit by non-modified kana.
       *    e.g.) "ば" and "ぱ" will be hit by key "は".
       * 2) Geminate consonant "っ" will be hit by non-modified kana "つ".
       * 3) Palatalized kana will be hit by non-modified kana.
       *    e.g.) "ゃ" will be hit by key "や".
       * Here is an example of the search: "学校" ("がっこう") will be hit
       * by "かつこう".
       * </pre>
       *
       * <code>optional bool kana_modifier_insensitive_conversion = 9 [default = false];</code>
       * @return The kanaModifierInsensitiveConversion.
       */
      @java.lang.Override
      public boolean getKanaModifierInsensitiveConversion() {
        return instance.getKanaModifierInsensitiveConversion();
      }
      /**
       * <pre>
       * Enables Kana-modifier-insensitive conversion as follows:
       * 1) Voiced/Semi-voiced kana will be hit by non-modified kana.
       *    e.g.) "ば" and "ぱ" will be hit by key "は".
       * 2) Geminate consonant "っ" will be hit by non-modified kana "つ".
       * 3) Palatalized kana will be hit by non-modified kana.
       *    e.g.) "ゃ" will be hit by key "や".
       * Here is an example of the search: "学校" ("がっこう") will be hit
       * by "かつこう".
       * </pre>
       *
       * <code>optional bool kana_modifier_insensitive_conversion = 9 [default = false];</code>
       * @param value The kanaModifierInsensitiveConversion to set.
       * @return This builder for chaining.
       */
      public Builder setKanaModifierInsensitiveConversion(boolean value) {
        copyOnWrite();
        instance.setKanaModifierInsensitiveConversion(value);
        return this;
      }
      /**
       * <pre>
       * Enables Kana-modifier-insensitive conversion as follows:
       * 1) Voiced/Semi-voiced kana will be hit by non-modified kana.
       *    e.g.) "ば" and "ぱ" will be hit by key "は".
       * 2) Geminate consonant "っ" will be hit by non-modified kana "つ".
       * 3) Palatalized kana will be hit by non-modified kana.
       *    e.g.) "ゃ" will be hit by key "や".
       * Here is an example of the search: "学校" ("がっこう") will be hit
       * by "かつこう".
       * </pre>
       *
       * <code>optional bool kana_modifier_insensitive_conversion = 9 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearKanaModifierInsensitiveConversion() {
        copyOnWrite();
        instance.clearKanaModifierInsensitiveConversion();
        return this;
      }

      /**
       * <pre>
       * Enables Auto partial suggestion (prefix candidates).
       * For Auto partial suggestion, we can see candidates that match
       * the prefix of the input reading.
       * If we commit that candidate, we will show suggestions for remaining part
       * of key.
       * Note: This feature can be enabled only for mobile due to UX design.
       * </pre>
       *
       * <code>optional bool auto_partial_suggestion = 10 [default = false];</code>
       * @return Whether the autoPartialSuggestion field is set.
       */
      @java.lang.Override
      public boolean hasAutoPartialSuggestion() {
        return instance.hasAutoPartialSuggestion();
      }
      /**
       * <pre>
       * Enables Auto partial suggestion (prefix candidates).
       * For Auto partial suggestion, we can see candidates that match
       * the prefix of the input reading.
       * If we commit that candidate, we will show suggestions for remaining part
       * of key.
       * Note: This feature can be enabled only for mobile due to UX design.
       * </pre>
       *
       * <code>optional bool auto_partial_suggestion = 10 [default = false];</code>
       * @return The autoPartialSuggestion.
       */
      @java.lang.Override
      public boolean getAutoPartialSuggestion() {
        return instance.getAutoPartialSuggestion();
      }
      /**
       * <pre>
       * Enables Auto partial suggestion (prefix candidates).
       * For Auto partial suggestion, we can see candidates that match
       * the prefix of the input reading.
       * If we commit that candidate, we will show suggestions for remaining part
       * of key.
       * Note: This feature can be enabled only for mobile due to UX design.
       * </pre>
       *
       * <code>optional bool auto_partial_suggestion = 10 [default = false];</code>
       * @param value The autoPartialSuggestion to set.
       * @return This builder for chaining.
       */
      public Builder setAutoPartialSuggestion(boolean value) {
        copyOnWrite();
        instance.setAutoPartialSuggestion(value);
        return this;
      }
      /**
       * <pre>
       * Enables Auto partial suggestion (prefix candidates).
       * For Auto partial suggestion, we can see candidates that match
       * the prefix of the input reading.
       * If we commit that candidate, we will show suggestions for remaining part
       * of key.
       * Note: This feature can be enabled only for mobile due to UX design.
       * </pre>
       *
       * <code>optional bool auto_partial_suggestion = 10 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearAutoPartialSuggestion() {
        copyOnWrite();
        instance.clearAutoPartialSuggestion();
        return this;
      }

      /**
       * <pre>
       * By default, Emoji rewriter works on conversion mode only.
       * </pre>
       *
       * <code>optional int32 emoji_rewriter_capability = 12 [default = 1];</code>
       * @return Whether the emojiRewriterCapability field is set.
       */
      @java.lang.Override
      public boolean hasEmojiRewriterCapability() {
        return instance.hasEmojiRewriterCapability();
      }
      /**
       * <pre>
       * By default, Emoji rewriter works on conversion mode only.
       * </pre>
       *
       * <code>optional int32 emoji_rewriter_capability = 12 [default = 1];</code>
       * @return The emojiRewriterCapability.
       */
      @java.lang.Override
      public int getEmojiRewriterCapability() {
        return instance.getEmojiRewriterCapability();
      }
      /**
       * <pre>
       * By default, Emoji rewriter works on conversion mode only.
       * </pre>
       *
       * <code>optional int32 emoji_rewriter_capability = 12 [default = 1];</code>
       * @param value The emojiRewriterCapability to set.
       * @return This builder for chaining.
       */
      public Builder setEmojiRewriterCapability(int value) {
        copyOnWrite();
        instance.setEmojiRewriterCapability(value);
        return this;
      }
      /**
       * <pre>
       * By default, Emoji rewriter works on conversion mode only.
       * </pre>
       *
       * <code>optional int32 emoji_rewriter_capability = 12 [default = 1];</code>
       * @return This builder for chaining.
       */
      public Builder clearEmojiRewriterCapability() {
        copyOnWrite();
        instance.clearEmojiRewriterCapability();
        return this;
      }

      /**
       * <code>optional .mozc.commands.Request.CrossingEdgeBehavior crossing_edge_behavior = 13 [default = DO_NOTHING];</code>
       * @return Whether the crossingEdgeBehavior field is set.
       */
      @java.lang.Override
      public boolean hasCrossingEdgeBehavior() {
        return instance.hasCrossingEdgeBehavior();
      }
      /**
       * <code>optional .mozc.commands.Request.CrossingEdgeBehavior crossing_edge_behavior = 13 [default = DO_NOTHING];</code>
       * @return The crossingEdgeBehavior.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.CrossingEdgeBehavior getCrossingEdgeBehavior() {
        return instance.getCrossingEdgeBehavior();
      }
      /**
       * <code>optional .mozc.commands.Request.CrossingEdgeBehavior crossing_edge_behavior = 13 [default = DO_NOTHING];</code>
       * @param value The enum numeric value on the wire for crossingEdgeBehavior to set.
       * @return This builder for chaining.
       */
      public Builder setCrossingEdgeBehavior(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.CrossingEdgeBehavior value) {
        copyOnWrite();
        instance.setCrossingEdgeBehavior(value);
        return this;
      }
      /**
       * <code>optional .mozc.commands.Request.CrossingEdgeBehavior crossing_edge_behavior = 13 [default = DO_NOTHING];</code>
       * @return This builder for chaining.
       */
      public Builder clearCrossingEdgeBehavior() {
        copyOnWrite();
        instance.clearCrossingEdgeBehavior();
        return this;
      }

      /**
       * <code>optional .mozc.commands.Request.LanguageAwareInputBehavior language_aware_input = 14 [default = DEFAULT_LANGUAGE_AWARE_BEHAVIOR];</code>
       * @return Whether the languageAwareInput field is set.
       */
      @java.lang.Override
      public boolean hasLanguageAwareInput() {
        return instance.hasLanguageAwareInput();
      }
      /**
       * <code>optional .mozc.commands.Request.LanguageAwareInputBehavior language_aware_input = 14 [default = DEFAULT_LANGUAGE_AWARE_BEHAVIOR];</code>
       * @return The languageAwareInput.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.LanguageAwareInputBehavior getLanguageAwareInput() {
        return instance.getLanguageAwareInput();
      }
      /**
       * <code>optional .mozc.commands.Request.LanguageAwareInputBehavior language_aware_input = 14 [default = DEFAULT_LANGUAGE_AWARE_BEHAVIOR];</code>
       * @param value The enum numeric value on the wire for languageAwareInput to set.
       * @return This builder for chaining.
       */
      public Builder setLanguageAwareInput(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.LanguageAwareInputBehavior value) {
        copyOnWrite();
        instance.setLanguageAwareInput(value);
        return this;
      }
      /**
       * <code>optional .mozc.commands.Request.LanguageAwareInputBehavior language_aware_input = 14 [default = DEFAULT_LANGUAGE_AWARE_BEHAVIOR];</code>
       * @return This builder for chaining.
       */
      public Builder clearLanguageAwareInput() {
        copyOnWrite();
        instance.clearLanguageAwareInput();
        return this;
      }

      /**
       * <pre>
       * Page size of the candidate list.
       * </pre>
       *
       * <code>optional int32 candidate_page_size = 15 [default = 9];</code>
       * @return Whether the candidatePageSize field is set.
       */
      @java.lang.Override
      public boolean hasCandidatePageSize() {
        return instance.hasCandidatePageSize();
      }
      /**
       * <pre>
       * Page size of the candidate list.
       * </pre>
       *
       * <code>optional int32 candidate_page_size = 15 [default = 9];</code>
       * @return The candidatePageSize.
       */
      @java.lang.Override
      public int getCandidatePageSize() {
        return instance.getCandidatePageSize();
      }
      /**
       * <pre>
       * Page size of the candidate list.
       * </pre>
       *
       * <code>optional int32 candidate_page_size = 15 [default = 9];</code>
       * @param value The candidatePageSize to set.
       * @return This builder for chaining.
       */
      public Builder setCandidatePageSize(int value) {
        copyOnWrite();
        instance.setCandidatePageSize(value);
        return this;
      }
      /**
       * <pre>
       * Page size of the candidate list.
       * </pre>
       *
       * <code>optional int32 candidate_page_size = 15 [default = 9];</code>
       * @return This builder for chaining.
       */
      public Builder clearCandidatePageSize() {
        copyOnWrite();
        instance.clearCandidatePageSize();
        return this;
      }

      /**
       * <pre>
       * The maximum limit of the candidates size.
       * If not set, converter doesn't limit the size.
       * NOTE: Each segment has at least one candidate and meta candidates even if
       *       this value is set to 0.
       * </pre>
       *
       * <code>optional int32 candidates_size_limit = 16;</code>
       * @return Whether the candidatesSizeLimit field is set.
       */
      @java.lang.Override
      public boolean hasCandidatesSizeLimit() {
        return instance.hasCandidatesSizeLimit();
      }
      /**
       * <pre>
       * The maximum limit of the candidates size.
       * If not set, converter doesn't limit the size.
       * NOTE: Each segment has at least one candidate and meta candidates even if
       *       this value is set to 0.
       * </pre>
       *
       * <code>optional int32 candidates_size_limit = 16;</code>
       * @return The candidatesSizeLimit.
       */
      @java.lang.Override
      public int getCandidatesSizeLimit() {
        return instance.getCandidatesSizeLimit();
      }
      /**
       * <pre>
       * The maximum limit of the candidates size.
       * If not set, converter doesn't limit the size.
       * NOTE: Each segment has at least one candidate and meta candidates even if
       *       this value is set to 0.
       * </pre>
       *
       * <code>optional int32 candidates_size_limit = 16;</code>
       * @param value The candidatesSizeLimit to set.
       * @return This builder for chaining.
       */
      public Builder setCandidatesSizeLimit(int value) {
        copyOnWrite();
        instance.setCandidatesSizeLimit(value);
        return this;
      }
      /**
       * <pre>
       * The maximum limit of the candidates size.
       * If not set, converter doesn't limit the size.
       * NOTE: Each segment has at least one candidate and meta candidates even if
       *       this value is set to 0.
       * </pre>
       *
       * <code>optional int32 candidates_size_limit = 16;</code>
       * @return This builder for chaining.
       */
      public Builder clearCandidatesSizeLimit() {
        copyOnWrite();
        instance.clearCandidatesSizeLimit();
        return this;
      }

      /**
       * <pre>
       * Experimentally changes the decoder's behavior.
       * This flag is usually populated through the phenotype flags.
       * </pre>
       *
       * <code>optional .mozc.commands.DecoderExperimentParams decoder_experiment_params = 17;</code>
       */
      @java.lang.Override
      public boolean hasDecoderExperimentParams() {
        return instance.hasDecoderExperimentParams();
      }
      /**
       * <pre>
       * Experimentally changes the decoder's behavior.
       * This flag is usually populated through the phenotype flags.
       * </pre>
       *
       * <code>optional .mozc.commands.DecoderExperimentParams decoder_experiment_params = 17;</code>
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams getDecoderExperimentParams() {
        return instance.getDecoderExperimentParams();
      }
      /**
       * <pre>
       * Experimentally changes the decoder's behavior.
       * This flag is usually populated through the phenotype flags.
       * </pre>
       *
       * <code>optional .mozc.commands.DecoderExperimentParams decoder_experiment_params = 17;</code>
       */
      public Builder setDecoderExperimentParams(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams value) {
        copyOnWrite();
        instance.setDecoderExperimentParams(value);
        return this;
        }
      /**
       * <pre>
       * Experimentally changes the decoder's behavior.
       * This flag is usually populated through the phenotype flags.
       * </pre>
       *
       * <code>optional .mozc.commands.DecoderExperimentParams decoder_experiment_params = 17;</code>
       */
      public Builder setDecoderExperimentParams(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams.Builder builderForValue) {
        copyOnWrite();
        instance.setDecoderExperimentParams(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Experimentally changes the decoder's behavior.
       * This flag is usually populated through the phenotype flags.
       * </pre>
       *
       * <code>optional .mozc.commands.DecoderExperimentParams decoder_experiment_params = 17;</code>
       */
      public Builder mergeDecoderExperimentParams(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams value) {
        copyOnWrite();
        instance.mergeDecoderExperimentParams(value);
        return this;
      }
      /**
       * <pre>
       * Experimentally changes the decoder's behavior.
       * This flag is usually populated through the phenotype flags.
       * </pre>
       *
       * <code>optional .mozc.commands.DecoderExperimentParams decoder_experiment_params = 17;</code>
       */
      public Builder clearDecoderExperimentParams() {  copyOnWrite();
        instance.clearDecoderExperimentParams();
        return this;
      }

      /**
       * <pre>
       * Fills incognito_candidate_words filed of output.
       * </pre>
       *
       * <code>optional bool fill_incognito_candidate_words = 18 [default = false];</code>
       * @return Whether the fillIncognitoCandidateWords field is set.
       */
      @java.lang.Override
      public boolean hasFillIncognitoCandidateWords() {
        return instance.hasFillIncognitoCandidateWords();
      }
      /**
       * <pre>
       * Fills incognito_candidate_words filed of output.
       * </pre>
       *
       * <code>optional bool fill_incognito_candidate_words = 18 [default = false];</code>
       * @return The fillIncognitoCandidateWords.
       */
      @java.lang.Override
      public boolean getFillIncognitoCandidateWords() {
        return instance.getFillIncognitoCandidateWords();
      }
      /**
       * <pre>
       * Fills incognito_candidate_words filed of output.
       * </pre>
       *
       * <code>optional bool fill_incognito_candidate_words = 18 [default = false];</code>
       * @param value The fillIncognitoCandidateWords to set.
       * @return This builder for chaining.
       */
      public Builder setFillIncognitoCandidateWords(boolean value) {
        copyOnWrite();
        instance.setFillIncognitoCandidateWords(value);
        return this;
      }
      /**
       * <pre>
       * Fills incognito_candidate_words filed of output.
       * </pre>
       *
       * <code>optional bool fill_incognito_candidate_words = 18 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearFillIncognitoCandidateWords() {
        copyOnWrite();
        instance.clearFillIncognitoCandidateWords();
        return this;
      }

      /**
       * <pre>
       * Enables a11y support for candidates.
       * If this field is set to true, a11y description is set to each candidate.
       * </pre>
       *
       * <code>optional bool enable_a11y_description = 20 [default = false];</code>
       * @return Whether the enableA11yDescription field is set.
       */
      @java.lang.Override
      public boolean hasEnableA11YDescription() {
        return instance.hasEnableA11YDescription();
      }
      /**
       * <pre>
       * Enables a11y support for candidates.
       * If this field is set to true, a11y description is set to each candidate.
       * </pre>
       *
       * <code>optional bool enable_a11y_description = 20 [default = false];</code>
       * @return The enableA11yDescription.
       */
      @java.lang.Override
      public boolean getEnableA11YDescription() {
        return instance.getEnableA11YDescription();
      }
      /**
       * <pre>
       * Enables a11y support for candidates.
       * If this field is set to true, a11y description is set to each candidate.
       * </pre>
       *
       * <code>optional bool enable_a11y_description = 20 [default = false];</code>
       * @param value The enableA11yDescription to set.
       * @return This builder for chaining.
       */
      public Builder setEnableA11YDescription(boolean value) {
        copyOnWrite();
        instance.setEnableA11YDescription(value);
        return this;
      }
      /**
       * <pre>
       * Enables a11y support for candidates.
       * If this field is set to true, a11y description is set to each candidate.
       * </pre>
       *
       * <code>optional bool enable_a11y_description = 20 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearEnableA11YDescription() {
        copyOnWrite();
        instance.clearEnableA11YDescription();
        return this;
      }

      /**
       * <pre>
       * Characters in the union of this list of groups can be contained in
       * candidates.
       * This feature is distinct from user preference. Do not make these option
       * user selectable.
       * </pre>
       *
       * <code>repeated .mozc.commands.Request.AdditionalRenderableCharacterGroup additional_renderable_character_groups = 21 [packed = true];</code>
       * @return A list containing the additionalRenderableCharacterGroups.
       */
      @java.lang.Override
      public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup> getAdditionalRenderableCharacterGroupsList() {
        return instance.getAdditionalRenderableCharacterGroupsList();
      }
      /**
       * <pre>
       * Characters in the union of this list of groups can be contained in
       * candidates.
       * This feature is distinct from user preference. Do not make these option
       * user selectable.
       * </pre>
       *
       * <code>repeated .mozc.commands.Request.AdditionalRenderableCharacterGroup additional_renderable_character_groups = 21 [packed = true];</code>
       * @return The count of additionalRenderableCharacterGroups.
       */
      @java.lang.Override
      public int getAdditionalRenderableCharacterGroupsCount() {
        return instance.getAdditionalRenderableCharacterGroupsCount();
      }
      /**
       * <pre>
       * Characters in the union of this list of groups can be contained in
       * candidates.
       * This feature is distinct from user preference. Do not make these option
       * user selectable.
       * </pre>
       *
       * <code>repeated .mozc.commands.Request.AdditionalRenderableCharacterGroup additional_renderable_character_groups = 21 [packed = true];</code>
       * @param index The index of the element to return.
       * @return The additionalRenderableCharacterGroups at the given index.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup getAdditionalRenderableCharacterGroups(int index) {
        return instance.getAdditionalRenderableCharacterGroups(index);
      }
      /**
       * <pre>
       * Characters in the union of this list of groups can be contained in
       * candidates.
       * This feature is distinct from user preference. Do not make these option
       * user selectable.
       * </pre>
       *
       * <code>repeated .mozc.commands.Request.AdditionalRenderableCharacterGroup additional_renderable_character_groups = 21 [packed = true];</code>
       * @param index The index to set the value at.
       * @param value The additionalRenderableCharacterGroups to set.
       * @return This builder for chaining.
       */
      public Builder setAdditionalRenderableCharacterGroups(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup value) {
        copyOnWrite();
        instance.setAdditionalRenderableCharacterGroups(index, value);
        return this;
      }
      /**
       * <pre>
       * Characters in the union of this list of groups can be contained in
       * candidates.
       * This feature is distinct from user preference. Do not make these option
       * user selectable.
       * </pre>
       *
       * <code>repeated .mozc.commands.Request.AdditionalRenderableCharacterGroup additional_renderable_character_groups = 21 [packed = true];</code>
       * @param value The additionalRenderableCharacterGroups to add.
       * @return This builder for chaining.
       */
      public Builder addAdditionalRenderableCharacterGroups(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup value) {
        copyOnWrite();
        instance.addAdditionalRenderableCharacterGroups(value);
        return this;
      }
      /**
       * <pre>
       * Characters in the union of this list of groups can be contained in
       * candidates.
       * This feature is distinct from user preference. Do not make these option
       * user selectable.
       * </pre>
       *
       * <code>repeated .mozc.commands.Request.AdditionalRenderableCharacterGroup additional_renderable_character_groups = 21 [packed = true];</code>
       * @param values The additionalRenderableCharacterGroups to add.
       * @return This builder for chaining.
       */
      public Builder addAllAdditionalRenderableCharacterGroups(
          java.lang.Iterable<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup> values) {
        copyOnWrite();
        instance.addAllAdditionalRenderableCharacterGroups(values);  return this;
      }
      /**
       * <pre>
       * Characters in the union of this list of groups can be contained in
       * candidates.
       * This feature is distinct from user preference. Do not make these option
       * user selectable.
       * </pre>
       *
       * <code>repeated .mozc.commands.Request.AdditionalRenderableCharacterGroup additional_renderable_character_groups = 21 [packed = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearAdditionalRenderableCharacterGroups() {
        copyOnWrite();
        instance.clearAdditionalRenderableCharacterGroups();
        return this;
      }

      /**
       * <pre>
       * Whether the request is from handwriting. Candidates can be optimized
       * differently for handwriting.
       * For example, we support 混ぜ書き conversion ("かん字" → "漢字") for
       * handwriting.
       * </pre>
       *
       * <code>optional bool is_handwriting = 22 [default = false];</code>
       * @return Whether the isHandwriting field is set.
       */
      @java.lang.Override
      public boolean hasIsHandwriting() {
        return instance.hasIsHandwriting();
      }
      /**
       * <pre>
       * Whether the request is from handwriting. Candidates can be optimized
       * differently for handwriting.
       * For example, we support 混ぜ書き conversion ("かん字" → "漢字") for
       * handwriting.
       * </pre>
       *
       * <code>optional bool is_handwriting = 22 [default = false];</code>
       * @return The isHandwriting.
       */
      @java.lang.Override
      public boolean getIsHandwriting() {
        return instance.getIsHandwriting();
      }
      /**
       * <pre>
       * Whether the request is from handwriting. Candidates can be optimized
       * differently for handwriting.
       * For example, we support 混ぜ書き conversion ("かん字" → "漢字") for
       * handwriting.
       * </pre>
       *
       * <code>optional bool is_handwriting = 22 [default = false];</code>
       * @param value The isHandwriting to set.
       * @return This builder for chaining.
       */
      public Builder setIsHandwriting(boolean value) {
        copyOnWrite();
        instance.setIsHandwriting(value);
        return this;
      }
      /**
       * <pre>
       * Whether the request is from handwriting. Candidates can be optimized
       * differently for handwriting.
       * For example, we support 混ぜ書き conversion ("かん字" → "漢字") for
       * handwriting.
       * </pre>
       *
       * <code>optional bool is_handwriting = 22 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearIsHandwriting() {
        copyOnWrite();
        instance.clearIsHandwriting();
        return this;
      }

      /**
       * <pre>
       * Whether the conversion is performed in incognito mode.
       * In incognito mode, the conversion is performed without using
       * user history and user dictionary.
       * When any of this value and Config::incognito_mode are true,
       * incognito mode is enabled.
       * Clients needs to check ConversionRequest::incognito_mode() instead of
       * this value directly, as the incognito mode can be set in other ways.
       * </pre>
       *
       * <code>optional bool is_incognito_mode = 23 [default = false];</code>
       * @return Whether the isIncognitoMode field is set.
       */
      @java.lang.Override
      public boolean hasIsIncognitoMode() {
        return instance.hasIsIncognitoMode();
      }
      /**
       * <pre>
       * Whether the conversion is performed in incognito mode.
       * In incognito mode, the conversion is performed without using
       * user history and user dictionary.
       * When any of this value and Config::incognito_mode are true,
       * incognito mode is enabled.
       * Clients needs to check ConversionRequest::incognito_mode() instead of
       * this value directly, as the incognito mode can be set in other ways.
       * </pre>
       *
       * <code>optional bool is_incognito_mode = 23 [default = false];</code>
       * @return The isIncognitoMode.
       */
      @java.lang.Override
      public boolean getIsIncognitoMode() {
        return instance.getIsIncognitoMode();
      }
      /**
       * <pre>
       * Whether the conversion is performed in incognito mode.
       * In incognito mode, the conversion is performed without using
       * user history and user dictionary.
       * When any of this value and Config::incognito_mode are true,
       * incognito mode is enabled.
       * Clients needs to check ConversionRequest::incognito_mode() instead of
       * this value directly, as the incognito mode can be set in other ways.
       * </pre>
       *
       * <code>optional bool is_incognito_mode = 23 [default = false];</code>
       * @param value The isIncognitoMode to set.
       * @return This builder for chaining.
       */
      public Builder setIsIncognitoMode(boolean value) {
        copyOnWrite();
        instance.setIsIncognitoMode(value);
        return this;
      }
      /**
       * <pre>
       * Whether the conversion is performed in incognito mode.
       * In incognito mode, the conversion is performed without using
       * user history and user dictionary.
       * When any of this value and Config::incognito_mode are true,
       * incognito mode is enabled.
       * Clients needs to check ConversionRequest::incognito_mode() instead of
       * this value directly, as the incognito mode can be set in other ways.
       * </pre>
       *
       * <code>optional bool is_incognito_mode = 23 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearIsIncognitoMode() {
        copyOnWrite();
        instance.clearIsIncognitoMode();
        return this;
      }

      /**
       * <code>optional .mozc.commands.Request.DisplayValueCapability display_value_capability = 24 [default = NOT_SUPPORTED];</code>
       * @return Whether the displayValueCapability field is set.
       */
      @java.lang.Override
      public boolean hasDisplayValueCapability() {
        return instance.hasDisplayValueCapability();
      }
      /**
       * <code>optional .mozc.commands.Request.DisplayValueCapability display_value_capability = 24 [default = NOT_SUPPORTED];</code>
       * @return The displayValueCapability.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.DisplayValueCapability getDisplayValueCapability() {
        return instance.getDisplayValueCapability();
      }
      /**
       * <code>optional .mozc.commands.Request.DisplayValueCapability display_value_capability = 24 [default = NOT_SUPPORTED];</code>
       * @param value The enum numeric value on the wire for displayValueCapability to set.
       * @return This builder for chaining.
       */
      public Builder setDisplayValueCapability(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.DisplayValueCapability value) {
        copyOnWrite();
        instance.setDisplayValueCapability(value);
        return this;
      }
      /**
       * <code>optional .mozc.commands.Request.DisplayValueCapability display_value_capability = 24 [default = NOT_SUPPORTED];</code>
       * @return This builder for chaining.
       */
      public Builder clearDisplayValueCapability() {
        copyOnWrite();
        instance.clearDisplayValueCapability();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:mozc.commands.Request)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "zeroQuerySuggestion_",
              "mixedConversion_",
              "specialRomanjiTable_",
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.SpecialRomanjiTable.internalGetVerifier(),
              "spaceOnAlphanumeric_",
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.SpaceOnAlphanumeric.internalGetVerifier(),
              "keyboardName_",
              "updateInputModeFromSurroundingText_",
              "kanaModifierInsensitiveConversion_",
              "autoPartialSuggestion_",
              "emojiRewriterCapability_",
              "crossingEdgeBehavior_",
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.CrossingEdgeBehavior.internalGetVerifier(),
              "languageAwareInput_",
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.LanguageAwareInputBehavior.internalGetVerifier(),
              "candidatePageSize_",
              "candidatesSizeLimit_",
              "decoderExperimentParams_",
              "fillIncognitoCandidateWords_",
              "enableA11YDescription_",
              "additionalRenderableCharacterGroups_",
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup.internalGetVerifier(),
              "isHandwriting_",
              "isIncognitoMode_",
              "displayValueCapability_",
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.DisplayValueCapability.internalGetVerifier(),
            };
            java.lang.String info =
                "\u0001\u0014\u0000\u0001\u0001\u0018\u0014\u0000\u0001\u0000\u0001\u1007\u0000\u0002" +
                "\u1007\u0001\u0004\u100c\u0002\u0006\u100c\u0003\u0007\u1008\u0004\b\u1007\u0005" +
                "\t\u1007\u0006\n\u1007\u0007\f\u1004\b\r\u100c\t\u000e\u100c\n\u000f\u1004\u000b" +
                "\u0010\u1004\f\u0011\u1009\r\u0012\u1007\u000e\u0014\u1007\u000f\u0015,\u0016\u1007" +
                "\u0010\u0017\u1007\u0011\u0018\u100c\u0012";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request> parser = PARSER;
          if (parser == null) {
            synchronized (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:mozc.commands.Request)
    private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request DEFAULT_INSTANCE;
    static {
      Request defaultInstance = new Request();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Request.class, defaultInstance);
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Request> PARSER;

    public static com.google.protobuf.Parser<Request> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ApplicationInfoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mozc.commands.ApplicationInfo)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>optional uint32 process_id = 1;</code>
     * @return Whether the processId field is set.
     */
    boolean hasProcessId();
    /**
     * <code>optional uint32 process_id = 1;</code>
     * @return The processId.
     */
    int getProcessId();

    /**
     * <code>optional uint32 thread_id = 2;</code>
     * @return Whether the threadId field is set.
     */
    boolean hasThreadId();
    /**
     * <code>optional uint32 thread_id = 2;</code>
     * @return The threadId.
     */
    int getThreadId();
  }
  /**
   * <pre>
   * Note there is another ApplicationInfo inside RendererCommand.
   * Since Input is not using nested message, define ApplicationInfo here.
   * </pre>
   *
   * Protobuf type {@code mozc.commands.ApplicationInfo}
   */
  public  static final class ApplicationInfo extends
      com.google.protobuf.GeneratedMessageLite<
          ApplicationInfo, ApplicationInfo.Builder> implements
      // @@protoc_insertion_point(message_implements:mozc.commands.ApplicationInfo)
      ApplicationInfoOrBuilder {
    private ApplicationInfo() {
    }
    private int bitField0_;
    public static final int PROCESS_ID_FIELD_NUMBER = 1;
    private int processId_;
    /**
     * <code>optional uint32 process_id = 1;</code>
     * @return Whether the processId field is set.
     */
    @java.lang.Override
    public boolean hasProcessId() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional uint32 process_id = 1;</code>
     * @return The processId.
     */
    @java.lang.Override
    public int getProcessId() {
      return processId_;
    }
    /**
     * <code>optional uint32 process_id = 1;</code>
     * @param value The processId to set.
     */
    private void setProcessId(int value) {
      bitField0_ |= 0x00000001;
      processId_ = value;
    }
    /**
     * <code>optional uint32 process_id = 1;</code>
     */
    private void clearProcessId() {
      bitField0_ = (bitField0_ & ~0x00000001);
      processId_ = 0;
    }

    public static final int THREAD_ID_FIELD_NUMBER = 2;
    private int threadId_;
    /**
     * <code>optional uint32 thread_id = 2;</code>
     * @return Whether the threadId field is set.
     */
    @java.lang.Override
    public boolean hasThreadId() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional uint32 thread_id = 2;</code>
     * @return The threadId.
     */
    @java.lang.Override
    public int getThreadId() {
      return threadId_;
    }
    /**
     * <code>optional uint32 thread_id = 2;</code>
     * @param value The threadId to set.
     */
    private void setThreadId(int value) {
      bitField0_ |= 0x00000002;
      threadId_ = value;
    }
    /**
     * <code>optional uint32 thread_id = 2;</code>
     */
    private void clearThreadId() {
      bitField0_ = (bitField0_ & ~0x00000002);
      threadId_ = 0;
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Note there is another ApplicationInfo inside RendererCommand.
     * Since Input is not using nested message, define ApplicationInfo here.
     * </pre>
     *
     * Protobuf type {@code mozc.commands.ApplicationInfo}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo, Builder> implements
        // @@protoc_insertion_point(builder_implements:mozc.commands.ApplicationInfo)
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfoOrBuilder {
      // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>optional uint32 process_id = 1;</code>
       * @return Whether the processId field is set.
       */
      @java.lang.Override
      public boolean hasProcessId() {
        return instance.hasProcessId();
      }
      /**
       * <code>optional uint32 process_id = 1;</code>
       * @return The processId.
       */
      @java.lang.Override
      public int getProcessId() {
        return instance.getProcessId();
      }
      /**
       * <code>optional uint32 process_id = 1;</code>
       * @param value The processId to set.
       * @return This builder for chaining.
       */
      public Builder setProcessId(int value) {
        copyOnWrite();
        instance.setProcessId(value);
        return this;
      }
      /**
       * <code>optional uint32 process_id = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearProcessId() {
        copyOnWrite();
        instance.clearProcessId();
        return this;
      }

      /**
       * <code>optional uint32 thread_id = 2;</code>
       * @return Whether the threadId field is set.
       */
      @java.lang.Override
      public boolean hasThreadId() {
        return instance.hasThreadId();
      }
      /**
       * <code>optional uint32 thread_id = 2;</code>
       * @return The threadId.
       */
      @java.lang.Override
      public int getThreadId() {
        return instance.getThreadId();
      }
      /**
       * <code>optional uint32 thread_id = 2;</code>
       * @param value The threadId to set.
       * @return This builder for chaining.
       */
      public Builder setThreadId(int value) {
        copyOnWrite();
        instance.setThreadId(value);
        return this;
      }
      /**
       * <code>optional uint32 thread_id = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearThreadId() {
        copyOnWrite();
        instance.clearThreadId();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:mozc.commands.ApplicationInfo)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "processId_",
              "threadId_",
            };
            java.lang.String info =
                "\u0001\u0002\u0000\u0001\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u100b\u0000\u0002" +
                "\u100b\u0001";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo> parser = PARSER;
          if (parser == null) {
            synchronized (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:mozc.commands.ApplicationInfo)
    private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo DEFAULT_INSTANCE;
    static {
      ApplicationInfo defaultInstance = new ApplicationInfo();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ApplicationInfo.class, defaultInstance);
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ApplicationInfo> PARSER;

    public static com.google.protobuf.Parser<ApplicationInfo> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface UserHistoryDataOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mozc.commands.UserHistoryData)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>optional string key = 1;</code>
     * @return Whether the key field is set.
     */
    boolean hasKey();
    /**
     * <code>optional string key = 1;</code>
     * @return The key.
     */
    java.lang.String getKey();
    /**
     * <code>optional string key = 1;</code>
     * @return The bytes for key.
     */
    com.google.protobuf.ByteString
        getKeyBytes();

    /**
     * <code>optional string value = 2;</code>
     * @return Whether the value field is set.
     */
    boolean hasValue();
    /**
     * <code>optional string value = 2;</code>
     * @return The value.
     */
    java.lang.String getValue();
    /**
     * <code>optional string value = 2;</code>
     * @return The bytes for value.
     */
    com.google.protobuf.ByteString
        getValueBytes();
  }
  /**
   * Protobuf type {@code mozc.commands.UserHistoryData}
   */
  public  static final class UserHistoryData extends
      com.google.protobuf.GeneratedMessageLite<
          UserHistoryData, UserHistoryData.Builder> implements
      // @@protoc_insertion_point(message_implements:mozc.commands.UserHistoryData)
      UserHistoryDataOrBuilder {
    private UserHistoryData() {
      key_ = "";
      value_ = "";
    }
    private int bitField0_;
    public static final int KEY_FIELD_NUMBER = 1;
    private java.lang.String key_;
    /**
     * <code>optional string key = 1;</code>
     * @return Whether the key field is set.
     */
    @java.lang.Override
    public boolean hasKey() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional string key = 1;</code>
     * @return The key.
     */
    @java.lang.Override
    public java.lang.String getKey() {
      return key_;
    }
    /**
     * <code>optional string key = 1;</code>
     * @return The bytes for key.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getKeyBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(key_);
    }
    /**
     * <code>optional string key = 1;</code>
     * @param value The key to set.
     */
    private void setKey(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000001;
      key_ = value;
    }
    /**
     * <code>optional string key = 1;</code>
     */
    private void clearKey() {
      bitField0_ = (bitField0_ & ~0x00000001);
      key_ = getDefaultInstance().getKey();
    }
    /**
     * <code>optional string key = 1;</code>
     * @param value The bytes for key to set.
     */
    private void setKeyBytes(
        com.google.protobuf.ByteString value) {
      key_ = value.toStringUtf8();
      bitField0_ |= 0x00000001;
    }

    public static final int VALUE_FIELD_NUMBER = 2;
    private java.lang.String value_;
    /**
     * <code>optional string value = 2;</code>
     * @return Whether the value field is set.
     */
    @java.lang.Override
    public boolean hasValue() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional string value = 2;</code>
     * @return The value.
     */
    @java.lang.Override
    public java.lang.String getValue() {
      return value_;
    }
    /**
     * <code>optional string value = 2;</code>
     * @return The bytes for value.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getValueBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(value_);
    }
    /**
     * <code>optional string value = 2;</code>
     * @param value The value to set.
     */
    private void setValue(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000002;
      value_ = value;
    }
    /**
     * <code>optional string value = 2;</code>
     */
    private void clearValue() {
      bitField0_ = (bitField0_ & ~0x00000002);
      value_ = getDefaultInstance().getValue();
    }
    /**
     * <code>optional string value = 2;</code>
     * @param value The bytes for value to set.
     */
    private void setValueBytes(
        com.google.protobuf.ByteString value) {
      value_ = value.toStringUtf8();
      bitField0_ |= 0x00000002;
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.UserHistoryData parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.UserHistoryData parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.UserHistoryData parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.UserHistoryData parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.UserHistoryData parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.UserHistoryData parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.UserHistoryData parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.UserHistoryData parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.UserHistoryData parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.UserHistoryData parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.UserHistoryData parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.UserHistoryData parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.UserHistoryData prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code mozc.commands.UserHistoryData}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.UserHistoryData, Builder> implements
        // @@protoc_insertion_point(builder_implements:mozc.commands.UserHistoryData)
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.UserHistoryDataOrBuilder {
      // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.UserHistoryData.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>optional string key = 1;</code>
       * @return Whether the key field is set.
       */
      @java.lang.Override
      public boolean hasKey() {
        return instance.hasKey();
      }
      /**
       * <code>optional string key = 1;</code>
       * @return The key.
       */
      @java.lang.Override
      public java.lang.String getKey() {
        return instance.getKey();
      }
      /**
       * <code>optional string key = 1;</code>
       * @return The bytes for key.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getKeyBytes() {
        return instance.getKeyBytes();
      }
      /**
       * <code>optional string key = 1;</code>
       * @param value The key to set.
       * @return This builder for chaining.
       */
      public Builder setKey(
          java.lang.String value) {
        copyOnWrite();
        instance.setKey(value);
        return this;
      }
      /**
       * <code>optional string key = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearKey() {
        copyOnWrite();
        instance.clearKey();
        return this;
      }
      /**
       * <code>optional string key = 1;</code>
       * @param value The bytes for key to set.
       * @return This builder for chaining.
       */
      public Builder setKeyBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setKeyBytes(value);
        return this;
      }

      /**
       * <code>optional string value = 2;</code>
       * @return Whether the value field is set.
       */
      @java.lang.Override
      public boolean hasValue() {
        return instance.hasValue();
      }
      /**
       * <code>optional string value = 2;</code>
       * @return The value.
       */
      @java.lang.Override
      public java.lang.String getValue() {
        return instance.getValue();
      }
      /**
       * <code>optional string value = 2;</code>
       * @return The bytes for value.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getValueBytes() {
        return instance.getValueBytes();
      }
      /**
       * <code>optional string value = 2;</code>
       * @param value The value to set.
       * @return This builder for chaining.
       */
      public Builder setValue(
          java.lang.String value) {
        copyOnWrite();
        instance.setValue(value);
        return this;
      }
      /**
       * <code>optional string value = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearValue() {
        copyOnWrite();
        instance.clearValue();
        return this;
      }
      /**
       * <code>optional string value = 2;</code>
       * @param value The bytes for value to set.
       * @return This builder for chaining.
       */
      public Builder setValueBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setValueBytes(value);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:mozc.commands.UserHistoryData)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.UserHistoryData();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "key_",
              "value_",
            };
            java.lang.String info =
                "\u0001\u0002\u0000\u0001\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u1008\u0000\u0002" +
                "\u1008\u0001";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.UserHistoryData> parser = PARSER;
          if (parser == null) {
            synchronized (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.UserHistoryData.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.UserHistoryData>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:mozc.commands.UserHistoryData)
    private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.UserHistoryData DEFAULT_INSTANCE;
    static {
      UserHistoryData defaultInstance = new UserHistoryData();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        UserHistoryData.class, defaultInstance);
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.UserHistoryData getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<UserHistoryData> PARSER;

    public static com.google.protobuf.Parser<UserHistoryData> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface InputOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mozc.commands.Input)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>required .mozc.commands.Input.CommandType type = 1;</code>
     * @return Whether the type field is set.
     */
    boolean hasType();
    /**
     * <code>required .mozc.commands.Input.CommandType type = 1;</code>
     * @return The type.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.CommandType getType();

    /**
     * <pre>
     * Session ID created by CREATE_SESSION.
     * </pre>
     *
     * <code>optional uint64 id = 2 [jstype = JS_STRING];</code>
     * @return Whether the id field is set.
     */
    boolean hasId();
    /**
     * <pre>
     * Session ID created by CREATE_SESSION.
     * </pre>
     *
     * <code>optional uint64 id = 2 [jstype = JS_STRING];</code>
     * @return The id.
     */
    long getId();

    /**
     * <pre>
     * Key combinations used for SEND_KEY or TEST_SEND_KEY.
     * </pre>
     *
     * <code>optional .mozc.commands.KeyEvent key = 3;</code>
     * @return Whether the key field is set.
     */
    boolean hasKey();
    /**
     * <pre>
     * Key combinations used for SEND_KEY or TEST_SEND_KEY.
     * </pre>
     *
     * <code>optional .mozc.commands.KeyEvent key = 3;</code>
     * @return The key.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent getKey();

    /**
     * <pre>
     * Command sent to the session layer used with SEND_COMMAND.
     * </pre>
     *
     * <code>optional .mozc.commands.SessionCommand command = 4;</code>
     * @return Whether the command field is set.
     */
    boolean hasCommand();
    /**
     * <pre>
     * Command sent to the session layer used with SEND_COMMAND.
     * </pre>
     *
     * <code>optional .mozc.commands.SessionCommand command = 4;</code>
     * @return The command.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand getCommand();

    /**
     * <pre>
     * Input config
     * </pre>
     *
     * <code>optional .mozc.config.Config config = 5;</code>
     * @return Whether the config field is set.
     */
    boolean hasConfig();
    /**
     * <pre>
     * Input config
     * </pre>
     *
     * <code>optional .mozc.config.Config config = 5;</code>
     * @return The config.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config getConfig();

    /**
     * <pre>
     * Context data
     * </pre>
     *
     * <code>optional .mozc.commands.Context context = 6;</code>
     * @return Whether the context field is set.
     */
    boolean hasContext();
    /**
     * <pre>
     * Context data
     * </pre>
     *
     * <code>optional .mozc.commands.Context context = 6;</code>
     * @return The context.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context getContext();

    /**
     * <pre>
     * Client capability
     * </pre>
     *
     * <code>optional .mozc.commands.Capability capability = 7;</code>
     * @return Whether the capability field is set.
     */
    boolean hasCapability();
    /**
     * <pre>
     * Client capability
     * </pre>
     *
     * <code>optional .mozc.commands.Capability capability = 7;</code>
     * @return The capability.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability getCapability();

    /**
     * <pre>
     * Application information, like process id.
     * Server may be able to change the behavior by seeing the
     * the program name.
     * </pre>
     *
     * <code>optional .mozc.commands.ApplicationInfo application_info = 8;</code>
     * @return Whether the applicationInfo field is set.
     */
    boolean hasApplicationInfo();
    /**
     * <pre>
     * Application information, like process id.
     * Server may be able to change the behavior by seeing the
     * the program name.
     * </pre>
     *
     * <code>optional .mozc.commands.ApplicationInfo application_info = 8;</code>
     * @return The applicationInfo.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo getApplicationInfo();

    /**
     * <pre>
     * Client request
     * </pre>
     *
     * <code>optional .mozc.commands.Request request = 9;</code>
     * @return Whether the request field is set.
     */
    boolean hasRequest();
    /**
     * <pre>
     * Client request
     * </pre>
     *
     * <code>optional .mozc.commands.Request request = 9;</code>
     * @return The request.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request getRequest();

    /**
     * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
     */
    java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent> 
        getTouchEventsList();
    /**
     * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent getTouchEvents(int index);
    /**
     * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
     */
    int getTouchEventsCount();

    /**
     * <code>optional .mozc.user_dictionary.UserDictionaryImportData user_dictionary_import_data = 17;</code>
     * @return Whether the userDictionaryImportData field is set.
     */
    boolean hasUserDictionaryImportData();
    /**
     * <code>optional .mozc.user_dictionary.UserDictionaryImportData user_dictionary_import_data = 17;</code>
     * @return The userDictionaryImportData.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryImportData getUserDictionaryImportData();

    /**
     * <pre>
     * A flag to control if the server should return suggest-results or not.
     * If this is set to false, regardless of other configurations,
     * the server won't return suggestion results.
     * This is set to true by default.
     * Note that even if this flag is set to false, when a suggestion is shown
     * in the previous phase, it is possible from the client to submit it.
     * This works only for suggestions for the key insertion, but not for
     * others commands, such as predictions or conversions.
     * This flag is used for the performance improvement in terms of the
     * latency.  If you want to suppress the suggestions for the UX improment,
     * you may want to use suppress_suggestion in the Context message.
     * </pre>
     *
     * <code>optional bool request_suggestion = 14 [default = true];</code>
     * @return Whether the requestSuggestion field is set.
     */
    boolean hasRequestSuggestion();
    /**
     * <pre>
     * A flag to control if the server should return suggest-results or not.
     * If this is set to false, regardless of other configurations,
     * the server won't return suggestion results.
     * This is set to true by default.
     * Note that even if this flag is set to false, when a suggestion is shown
     * in the previous phase, it is possible from the client to submit it.
     * This works only for suggestions for the key insertion, but not for
     * others commands, such as predictions or conversions.
     * This flag is used for the performance improvement in terms of the
     * latency.  If you want to suppress the suggestions for the UX improment,
     * you may want to use suppress_suggestion in the Context message.
     * </pre>
     *
     * <code>optional bool request_suggestion = 14 [default = true];</code>
     * @return The requestSuggestion.
     */
    boolean getRequestSuggestion();

    /**
     * <code>optional .mozc.EngineReloadRequest engine_reload_request = 15;</code>
     * @return Whether the engineReloadRequest field is set.
     */
    boolean hasEngineReloadRequest();
    /**
     * <code>optional .mozc.EngineReloadRequest engine_reload_request = 15;</code>
     * @return The engineReloadRequest.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadRequest getEngineReloadRequest();

    /**
     * <code>optional .mozc.commands.UserHistoryData user_history_data = 18;</code>
     * @return Whether the userHistoryData field is set.
     */
    boolean hasUserHistoryData();
    /**
     * <code>optional .mozc.commands.UserHistoryData user_history_data = 18;</code>
     * @return The userHistoryData.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.UserHistoryData getUserHistoryData();
  }
  /**
   * Protobuf type {@code mozc.commands.Input}
   */
  public  static final class Input extends
      com.google.protobuf.GeneratedMessageLite<
          Input, Input.Builder> implements
      // @@protoc_insertion_point(message_implements:mozc.commands.Input)
      InputOrBuilder {
    private Input() {
      touchEvents_ = emptyProtobufList();
      requestSuggestion_ = true;
    }
    /**
     * Protobuf enum {@code mozc.commands.Input.CommandType}
     */
    public enum CommandType
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>NONE = 0;</code>
       */
      NONE(0),
      /**
       * <code>CREATE_SESSION = 1;</code>
       */
      CREATE_SESSION(1),
      /**
       * <code>DELETE_SESSION = 2;</code>
       */
      DELETE_SESSION(2),
      /**
       * <code>SEND_KEY = 3;</code>
       */
      SEND_KEY(3),
      /**
       * <pre>
       * Check only if the key event will be consumed.  This command is
       * for TSF on Windows.  You do not need to use this command, if it
       * is not necessary.
       * </pre>
       *
       * <code>TEST_SEND_KEY = 4;</code>
       */
      TEST_SEND_KEY(4),
      /**
       * <pre>
       * Evaluate the command specified by SessionCommand.  The output
       * format should be the same with an output of a SEND_KEY command.
       * </pre>
       *
       * <code>SEND_COMMAND = 5;</code>
       */
      SEND_COMMAND(5),
      /**
       * <pre>
       * Config accessors.
       * </pre>
       *
       * <code>GET_CONFIG = 6;</code>
       */
      GET_CONFIG(6),
      /**
       * <code>SET_CONFIG = 7;</code>
       */
      SET_CONFIG(7),
      /**
       * <pre>
       * Set client's request
       * </pre>
       *
       * <code>SET_REQUEST = 17;</code>
       */
      SET_REQUEST(17),
      /**
       * <pre>
       * sync dictionary/history data to local file
       * </pre>
       *
       * <code>SYNC_DATA = 8;</code>
       */
      SYNC_DATA(8),
      /**
       * <pre>
       * shutdowon server safely
       * </pre>
       *
       * <code>SHUTDOWN = 9;</code>
       */
      SHUTDOWN(9),
      /**
       * <pre>
       * reload mutable data (like config, user-dic, history)
       * </pre>
       *
       * <code>RELOAD = 10;</code>
       */
      RELOAD(10),
      /**
       * <pre>
       * realod mutable data and wait for finish
       * Note: Reloading of user dictionary data is async so that
       * it will not block the typing.
       * This command wait for the reloader.
       * </pre>
       *
       * <code>RELOAD_AND_WAIT = 15;</code>
       */
      RELOAD_AND_WAIT(15),
      /**
       * <pre>
       * clear user history data
       * </pre>
       *
       * <code>CLEAR_USER_HISTORY = 11;</code>
       */
      CLEAR_USER_HISTORY(11),
      /**
       * <pre>
       * clear user prediction data
       * </pre>
       *
       * <code>CLEAR_USER_PREDICTION = 12;</code>
       */
      CLEAR_USER_PREDICTION(12),
      /**
       * <pre>
       * clear unused prediction
       * </pre>
       *
       * <code>CLEAR_UNUSED_USER_PREDICTION = 16;</code>
       */
      CLEAR_UNUSED_USER_PREDICTION(16),
      /**
       * <pre>
       * clean up sessions
       * shutdwon if session is empty and
       * mozc_server is launched with timeout mode
       * </pre>
       *
       * <code>CLEANUP = 13;</code>
       */
      CLEANUP(13),
      /**
       * <pre>
       * no operation
       * can be used for pinging the server
       * </pre>
       *
       * <code>NO_OPERATION = 14;</code>
       */
      NO_OPERATION(14),
      /**
       * <pre>
       * Send an engine_reload_request (ID: 15) to reload the engine.
       * </pre>
       *
       * <code>SEND_ENGINE_RELOAD_REQUEST = 27;</code>
       */
      SEND_ENGINE_RELOAD_REQUEST(27),
      /**
       * <pre>
       * Sends reload supplemental model
       * </pre>
       *
       * <code>RELOAD_SUPPLEMENTAL_MODEL = 30;</code>
       */
      RELOAD_SUPPLEMENTAL_MODEL(30),
      /**
       * <code>GET_SERVER_VERSION = 19;</code>
       */
      GET_SERVER_VERSION(19),
      /**
       * <pre>
       * Import user dictionary from client.
       * </pre>
       *
       * <code>IMPORT_USER_DICTIONARY = 31;</code>
       */
      IMPORT_USER_DICTIONARY(31),
      /**
       * <pre>
       * Add a specific entry to the user history storage.
       * </pre>
       *
       * <code>ADD_USER_HISTORY = 32;</code>
       */
      ADD_USER_HISTORY(32),
      /**
       * <pre>
       * Number of commands.
       * When new command is added, the command should use below number
       * and NUM_OF_COMMANDS should be incremented.
       * </pre>
       *
       * <code>NUM_OF_COMMANDS = 33;</code>
       */
      NUM_OF_COMMANDS(33),
      ;

      /**
       * <code>NONE = 0;</code>
       */
      public static final int NONE_VALUE = 0;
      /**
       * <code>CREATE_SESSION = 1;</code>
       */
      public static final int CREATE_SESSION_VALUE = 1;
      /**
       * <code>DELETE_SESSION = 2;</code>
       */
      public static final int DELETE_SESSION_VALUE = 2;
      /**
       * <code>SEND_KEY = 3;</code>
       */
      public static final int SEND_KEY_VALUE = 3;
      /**
       * <pre>
       * Check only if the key event will be consumed.  This command is
       * for TSF on Windows.  You do not need to use this command, if it
       * is not necessary.
       * </pre>
       *
       * <code>TEST_SEND_KEY = 4;</code>
       */
      public static final int TEST_SEND_KEY_VALUE = 4;
      /**
       * <pre>
       * Evaluate the command specified by SessionCommand.  The output
       * format should be the same with an output of a SEND_KEY command.
       * </pre>
       *
       * <code>SEND_COMMAND = 5;</code>
       */
      public static final int SEND_COMMAND_VALUE = 5;
      /**
       * <pre>
       * Config accessors.
       * </pre>
       *
       * <code>GET_CONFIG = 6;</code>
       */
      public static final int GET_CONFIG_VALUE = 6;
      /**
       * <code>SET_CONFIG = 7;</code>
       */
      public static final int SET_CONFIG_VALUE = 7;
      /**
       * <pre>
       * Set client's request
       * </pre>
       *
       * <code>SET_REQUEST = 17;</code>
       */
      public static final int SET_REQUEST_VALUE = 17;
      /**
       * <pre>
       * sync dictionary/history data to local file
       * </pre>
       *
       * <code>SYNC_DATA = 8;</code>
       */
      public static final int SYNC_DATA_VALUE = 8;
      /**
       * <pre>
       * shutdowon server safely
       * </pre>
       *
       * <code>SHUTDOWN = 9;</code>
       */
      public static final int SHUTDOWN_VALUE = 9;
      /**
       * <pre>
       * reload mutable data (like config, user-dic, history)
       * </pre>
       *
       * <code>RELOAD = 10;</code>
       */
      public static final int RELOAD_VALUE = 10;
      /**
       * <pre>
       * realod mutable data and wait for finish
       * Note: Reloading of user dictionary data is async so that
       * it will not block the typing.
       * This command wait for the reloader.
       * </pre>
       *
       * <code>RELOAD_AND_WAIT = 15;</code>
       */
      public static final int RELOAD_AND_WAIT_VALUE = 15;
      /**
       * <pre>
       * clear user history data
       * </pre>
       *
       * <code>CLEAR_USER_HISTORY = 11;</code>
       */
      public static final int CLEAR_USER_HISTORY_VALUE = 11;
      /**
       * <pre>
       * clear user prediction data
       * </pre>
       *
       * <code>CLEAR_USER_PREDICTION = 12;</code>
       */
      public static final int CLEAR_USER_PREDICTION_VALUE = 12;
      /**
       * <pre>
       * clear unused prediction
       * </pre>
       *
       * <code>CLEAR_UNUSED_USER_PREDICTION = 16;</code>
       */
      public static final int CLEAR_UNUSED_USER_PREDICTION_VALUE = 16;
      /**
       * <pre>
       * clean up sessions
       * shutdwon if session is empty and
       * mozc_server is launched with timeout mode
       * </pre>
       *
       * <code>CLEANUP = 13;</code>
       */
      public static final int CLEANUP_VALUE = 13;
      /**
       * <pre>
       * no operation
       * can be used for pinging the server
       * </pre>
       *
       * <code>NO_OPERATION = 14;</code>
       */
      public static final int NO_OPERATION_VALUE = 14;
      /**
       * <pre>
       * Send an engine_reload_request (ID: 15) to reload the engine.
       * </pre>
       *
       * <code>SEND_ENGINE_RELOAD_REQUEST = 27;</code>
       */
      public static final int SEND_ENGINE_RELOAD_REQUEST_VALUE = 27;
      /**
       * <pre>
       * Sends reload supplemental model
       * </pre>
       *
       * <code>RELOAD_SUPPLEMENTAL_MODEL = 30;</code>
       */
      public static final int RELOAD_SUPPLEMENTAL_MODEL_VALUE = 30;
      /**
       * <code>GET_SERVER_VERSION = 19;</code>
       */
      public static final int GET_SERVER_VERSION_VALUE = 19;
      /**
       * <pre>
       * Import user dictionary from client.
       * </pre>
       *
       * <code>IMPORT_USER_DICTIONARY = 31;</code>
       */
      public static final int IMPORT_USER_DICTIONARY_VALUE = 31;
      /**
       * <pre>
       * Add a specific entry to the user history storage.
       * </pre>
       *
       * <code>ADD_USER_HISTORY = 32;</code>
       */
      public static final int ADD_USER_HISTORY_VALUE = 32;
      /**
       * <pre>
       * Number of commands.
       * When new command is added, the command should use below number
       * and NUM_OF_COMMANDS should be incremented.
       * </pre>
       *
       * <code>NUM_OF_COMMANDS = 33;</code>
       */
      public static final int NUM_OF_COMMANDS_VALUE = 33;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static CommandType valueOf(int value) {
        return forNumber(value);
      }

      public static CommandType forNumber(int value) {
        switch (value) {
          case 0: return NONE;
          case 1: return CREATE_SESSION;
          case 2: return DELETE_SESSION;
          case 3: return SEND_KEY;
          case 4: return TEST_SEND_KEY;
          case 5: return SEND_COMMAND;
          case 6: return GET_CONFIG;
          case 7: return SET_CONFIG;
          case 17: return SET_REQUEST;
          case 8: return SYNC_DATA;
          case 9: return SHUTDOWN;
          case 10: return RELOAD;
          case 15: return RELOAD_AND_WAIT;
          case 11: return CLEAR_USER_HISTORY;
          case 12: return CLEAR_USER_PREDICTION;
          case 16: return CLEAR_UNUSED_USER_PREDICTION;
          case 13: return CLEANUP;
          case 14: return NO_OPERATION;
          case 27: return SEND_ENGINE_RELOAD_REQUEST;
          case 30: return RELOAD_SUPPLEMENTAL_MODEL;
          case 19: return GET_SERVER_VERSION;
          case 31: return IMPORT_USER_DICTIONARY;
          case 32: return ADD_USER_HISTORY;
          case 33: return NUM_OF_COMMANDS;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<CommandType>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          CommandType> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<CommandType>() {
              @java.lang.Override
              public CommandType findValueByNumber(int number) {
                return CommandType.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return CommandTypeVerifier.INSTANCE;
      }

      private static final class CommandTypeVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new CommandTypeVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return CommandType.forNumber(number) != null;
              }
            };

      private final int value;

      private CommandType(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.commands.Input.CommandType)
    }

    /**
     * Protobuf enum {@code mozc.commands.Input.TouchAction}
     */
    public enum TouchAction
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>TOUCH_DOWN = 1;</code>
       */
      TOUCH_DOWN(1),
      /**
       * <code>TOUCH_MOVE = 2;</code>
       */
      TOUCH_MOVE(2),
      /**
       * <code>TOUCH_UP = 3;</code>
       */
      TOUCH_UP(3),
      ;

      /**
       * <code>TOUCH_DOWN = 1;</code>
       */
      public static final int TOUCH_DOWN_VALUE = 1;
      /**
       * <code>TOUCH_MOVE = 2;</code>
       */
      public static final int TOUCH_MOVE_VALUE = 2;
      /**
       * <code>TOUCH_UP = 3;</code>
       */
      public static final int TOUCH_UP_VALUE = 3;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static TouchAction valueOf(int value) {
        return forNumber(value);
      }

      public static TouchAction forNumber(int value) {
        switch (value) {
          case 1: return TOUCH_DOWN;
          case 2: return TOUCH_MOVE;
          case 3: return TOUCH_UP;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<TouchAction>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          TouchAction> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<TouchAction>() {
              @java.lang.Override
              public TouchAction findValueByNumber(int number) {
                return TouchAction.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return TouchActionVerifier.INSTANCE;
      }

      private static final class TouchActionVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new TouchActionVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return TouchAction.forNumber(number) != null;
              }
            };

      private final int value;

      private TouchAction(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.commands.Input.TouchAction)
    }

    public interface TouchPositionOrBuilder extends
        // @@protoc_insertion_point(interface_extends:mozc.commands.Input.TouchPosition)
        com.google.protobuf.MessageLiteOrBuilder {

      /**
       * <code>optional .mozc.commands.Input.TouchAction action = 1;</code>
       * @return Whether the action field is set.
       */
      boolean hasAction();
      /**
       * <code>optional .mozc.commands.Input.TouchAction action = 1;</code>
       * @return The action.
       */
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchAction getAction();

      /**
       * <pre>
       * x, y potision: keyboard left-top is (0, 0), right-bottom is (1, 1).
       * </pre>
       *
       * <code>optional float x = 2;</code>
       * @return Whether the x field is set.
       */
      boolean hasX();
      /**
       * <pre>
       * x, y potision: keyboard left-top is (0, 0), right-bottom is (1, 1).
       * </pre>
       *
       * <code>optional float x = 2;</code>
       * @return The x.
       */
      float getX();

      /**
       * <code>optional float y = 3;</code>
       * @return Whether the y field is set.
       */
      boolean hasY();
      /**
       * <code>optional float y = 3;</code>
       * @return The y.
       */
      float getY();

      /**
       * <pre>
       * timestamp (in ms) is set to zero when the touch event starts.
       * </pre>
       *
       * <code>optional int64 timestamp = 4;</code>
       * @return Whether the timestamp field is set.
       */
      boolean hasTimestamp();
      /**
       * <pre>
       * timestamp (in ms) is set to zero when the touch event starts.
       * </pre>
       *
       * <code>optional int64 timestamp = 4;</code>
       * @return The timestamp.
       */
      long getTimestamp();
    }
    /**
     * Protobuf type {@code mozc.commands.Input.TouchPosition}
     */
    public  static final class TouchPosition extends
        com.google.protobuf.GeneratedMessageLite<
            TouchPosition, TouchPosition.Builder> implements
        // @@protoc_insertion_point(message_implements:mozc.commands.Input.TouchPosition)
        TouchPositionOrBuilder {
      private TouchPosition() {
        action_ = 1;
      }
      private int bitField0_;
      public static final int ACTION_FIELD_NUMBER = 1;
      private int action_;
      /**
       * <code>optional .mozc.commands.Input.TouchAction action = 1;</code>
       * @return Whether the action field is set.
       */
      @java.lang.Override
      public boolean hasAction() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional .mozc.commands.Input.TouchAction action = 1;</code>
       * @return The action.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchAction getAction() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchAction result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchAction.forNumber(action_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchAction.TOUCH_DOWN : result;
      }
      /**
       * <code>optional .mozc.commands.Input.TouchAction action = 1;</code>
       * @param value The action to set.
       */
      private void setAction(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchAction value) {
        action_ = value.getNumber();
        bitField0_ |= 0x00000001;
      }
      /**
       * <code>optional .mozc.commands.Input.TouchAction action = 1;</code>
       */
      private void clearAction() {
        bitField0_ = (bitField0_ & ~0x00000001);
        action_ = 1;
      }

      public static final int X_FIELD_NUMBER = 2;
      private float x_;
      /**
       * <pre>
       * x, y potision: keyboard left-top is (0, 0), right-bottom is (1, 1).
       * </pre>
       *
       * <code>optional float x = 2;</code>
       * @return Whether the x field is set.
       */
      @java.lang.Override
      public boolean hasX() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * x, y potision: keyboard left-top is (0, 0), right-bottom is (1, 1).
       * </pre>
       *
       * <code>optional float x = 2;</code>
       * @return The x.
       */
      @java.lang.Override
      public float getX() {
        return x_;
      }
      /**
       * <pre>
       * x, y potision: keyboard left-top is (0, 0), right-bottom is (1, 1).
       * </pre>
       *
       * <code>optional float x = 2;</code>
       * @param value The x to set.
       */
      private void setX(float value) {
        bitField0_ |= 0x00000002;
        x_ = value;
      }
      /**
       * <pre>
       * x, y potision: keyboard left-top is (0, 0), right-bottom is (1, 1).
       * </pre>
       *
       * <code>optional float x = 2;</code>
       */
      private void clearX() {
        bitField0_ = (bitField0_ & ~0x00000002);
        x_ = 0F;
      }

      public static final int Y_FIELD_NUMBER = 3;
      private float y_;
      /**
       * <code>optional float y = 3;</code>
       * @return Whether the y field is set.
       */
      @java.lang.Override
      public boolean hasY() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <code>optional float y = 3;</code>
       * @return The y.
       */
      @java.lang.Override
      public float getY() {
        return y_;
      }
      /**
       * <code>optional float y = 3;</code>
       * @param value The y to set.
       */
      private void setY(float value) {
        bitField0_ |= 0x00000004;
        y_ = value;
      }
      /**
       * <code>optional float y = 3;</code>
       */
      private void clearY() {
        bitField0_ = (bitField0_ & ~0x00000004);
        y_ = 0F;
      }

      public static final int TIMESTAMP_FIELD_NUMBER = 4;
      private long timestamp_;
      /**
       * <pre>
       * timestamp (in ms) is set to zero when the touch event starts.
       * </pre>
       *
       * <code>optional int64 timestamp = 4;</code>
       * @return Whether the timestamp field is set.
       */
      @java.lang.Override
      public boolean hasTimestamp() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * timestamp (in ms) is set to zero when the touch event starts.
       * </pre>
       *
       * <code>optional int64 timestamp = 4;</code>
       * @return The timestamp.
       */
      @java.lang.Override
      public long getTimestamp() {
        return timestamp_;
      }
      /**
       * <pre>
       * timestamp (in ms) is set to zero when the touch event starts.
       * </pre>
       *
       * <code>optional int64 timestamp = 4;</code>
       * @param value The timestamp to set.
       */
      private void setTimestamp(long value) {
        bitField0_ |= 0x00000008;
        timestamp_ = value;
      }
      /**
       * <pre>
       * timestamp (in ms) is set to zero when the touch event starts.
       * </pre>
       *
       * <code>optional int64 timestamp = 4;</code>
       */
      private void clearTimestamp() {
        bitField0_ = (bitField0_ & ~0x00000008);
        timestamp_ = 0L;
      }

      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }

      public static Builder newBuilder() {
        return (Builder) DEFAULT_INSTANCE.createBuilder();
      }
      public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition prototype) {
        return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
      }

      /**
       * Protobuf type {@code mozc.commands.Input.TouchPosition}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageLite.Builder<
            org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition, Builder> implements
          // @@protoc_insertion_point(builder_implements:mozc.commands.Input.TouchPosition)
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPositionOrBuilder {
        // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition.newBuilder()
        private Builder() {
          super(DEFAULT_INSTANCE);
        }


        /**
         * <code>optional .mozc.commands.Input.TouchAction action = 1;</code>
         * @return Whether the action field is set.
         */
        @java.lang.Override
        public boolean hasAction() {
          return instance.hasAction();
        }
        /**
         * <code>optional .mozc.commands.Input.TouchAction action = 1;</code>
         * @return The action.
         */
        @java.lang.Override
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchAction getAction() {
          return instance.getAction();
        }
        /**
         * <code>optional .mozc.commands.Input.TouchAction action = 1;</code>
         * @param value The enum numeric value on the wire for action to set.
         * @return This builder for chaining.
         */
        public Builder setAction(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchAction value) {
          copyOnWrite();
          instance.setAction(value);
          return this;
        }
        /**
         * <code>optional .mozc.commands.Input.TouchAction action = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearAction() {
          copyOnWrite();
          instance.clearAction();
          return this;
        }

        /**
         * <pre>
         * x, y potision: keyboard left-top is (0, 0), right-bottom is (1, 1).
         * </pre>
         *
         * <code>optional float x = 2;</code>
         * @return Whether the x field is set.
         */
        @java.lang.Override
        public boolean hasX() {
          return instance.hasX();
        }
        /**
         * <pre>
         * x, y potision: keyboard left-top is (0, 0), right-bottom is (1, 1).
         * </pre>
         *
         * <code>optional float x = 2;</code>
         * @return The x.
         */
        @java.lang.Override
        public float getX() {
          return instance.getX();
        }
        /**
         * <pre>
         * x, y potision: keyboard left-top is (0, 0), right-bottom is (1, 1).
         * </pre>
         *
         * <code>optional float x = 2;</code>
         * @param value The x to set.
         * @return This builder for chaining.
         */
        public Builder setX(float value) {
          copyOnWrite();
          instance.setX(value);
          return this;
        }
        /**
         * <pre>
         * x, y potision: keyboard left-top is (0, 0), right-bottom is (1, 1).
         * </pre>
         *
         * <code>optional float x = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearX() {
          copyOnWrite();
          instance.clearX();
          return this;
        }

        /**
         * <code>optional float y = 3;</code>
         * @return Whether the y field is set.
         */
        @java.lang.Override
        public boolean hasY() {
          return instance.hasY();
        }
        /**
         * <code>optional float y = 3;</code>
         * @return The y.
         */
        @java.lang.Override
        public float getY() {
          return instance.getY();
        }
        /**
         * <code>optional float y = 3;</code>
         * @param value The y to set.
         * @return This builder for chaining.
         */
        public Builder setY(float value) {
          copyOnWrite();
          instance.setY(value);
          return this;
        }
        /**
         * <code>optional float y = 3;</code>
         * @return This builder for chaining.
         */
        public Builder clearY() {
          copyOnWrite();
          instance.clearY();
          return this;
        }

        /**
         * <pre>
         * timestamp (in ms) is set to zero when the touch event starts.
         * </pre>
         *
         * <code>optional int64 timestamp = 4;</code>
         * @return Whether the timestamp field is set.
         */
        @java.lang.Override
        public boolean hasTimestamp() {
          return instance.hasTimestamp();
        }
        /**
         * <pre>
         * timestamp (in ms) is set to zero when the touch event starts.
         * </pre>
         *
         * <code>optional int64 timestamp = 4;</code>
         * @return The timestamp.
         */
        @java.lang.Override
        public long getTimestamp() {
          return instance.getTimestamp();
        }
        /**
         * <pre>
         * timestamp (in ms) is set to zero when the touch event starts.
         * </pre>
         *
         * <code>optional int64 timestamp = 4;</code>
         * @param value The timestamp to set.
         * @return This builder for chaining.
         */
        public Builder setTimestamp(long value) {
          copyOnWrite();
          instance.setTimestamp(value);
          return this;
        }
        /**
         * <pre>
         * timestamp (in ms) is set to zero when the touch event starts.
         * </pre>
         *
         * <code>optional int64 timestamp = 4;</code>
         * @return This builder for chaining.
         */
        public Builder clearTimestamp() {
          copyOnWrite();
          instance.clearTimestamp();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:mozc.commands.Input.TouchPosition)
      }
      @java.lang.Override
      @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
      protected final java.lang.Object dynamicMethod(
          com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
          java.lang.Object arg0, java.lang.Object arg1) {
        switch (method) {
          case NEW_MUTABLE_INSTANCE: {
            return new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition();
          }
          case NEW_BUILDER: {
            return new Builder();
          }
          case BUILD_MESSAGE_INFO: {
              java.lang.Object[] objects = new java.lang.Object[] {
                "bitField0_",
                "action_",
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchAction.internalGetVerifier(),
                "x_",
                "y_",
                "timestamp_",
              };
              java.lang.String info =
                  "\u0001\u0004\u0000\u0001\u0001\u0004\u0004\u0000\u0000\u0000\u0001\u100c\u0000\u0002" +
                  "\u1001\u0001\u0003\u1001\u0002\u0004\u1002\u0003";
              return newMessageInfo(DEFAULT_INSTANCE, info, objects);
          }
          // fall through
          case GET_DEFAULT_INSTANCE: {
            return DEFAULT_INSTANCE;
          }
          case GET_PARSER: {
            com.google.protobuf.Parser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition> parser = PARSER;
            if (parser == null) {
              synchronized (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition.class) {
                parser = PARSER;
                if (parser == null) {
                  parser =
                      new DefaultInstanceBasedParser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition>(
                          DEFAULT_INSTANCE);
                  PARSER = parser;
                }
              }
            }
            return parser;
        }
        case GET_MEMOIZED_IS_INITIALIZED: {
          return (byte) 1;
        }
        case SET_MEMOIZED_IS_INITIALIZED: {
          return null;
        }
        }
        throw new UnsupportedOperationException();
      }


      // @@protoc_insertion_point(class_scope:mozc.commands.Input.TouchPosition)
      private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition DEFAULT_INSTANCE;
      static {
        TouchPosition defaultInstance = new TouchPosition();
        // New instances are implicitly immutable so no need to make
        // immutable.
        DEFAULT_INSTANCE = defaultInstance;
        com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
          TouchPosition.class, defaultInstance);
      }

      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static volatile com.google.protobuf.Parser<TouchPosition> PARSER;

      public static com.google.protobuf.Parser<TouchPosition> parser() {
        return DEFAULT_INSTANCE.getParserForType();
      }
    }

    public interface TouchEventOrBuilder extends
        // @@protoc_insertion_point(interface_extends:mozc.commands.Input.TouchEvent)
        com.google.protobuf.MessageLiteOrBuilder {

      /**
       * <pre>
       * source_id specifies the user action such as "X button pressed".
       * It must be unique within the same keyboard_name,
       * which is set in Request message.
       * </pre>
       *
       * <code>optional uint32 source_id = 1;</code>
       * @return Whether the sourceId field is set.
       */
      boolean hasSourceId();
      /**
       * <pre>
       * source_id specifies the user action such as "X button pressed".
       * It must be unique within the same keyboard_name,
       * which is set in Request message.
       * </pre>
       *
       * <code>optional uint32 source_id = 1;</code>
       * @return The sourceId.
       */
      int getSourceId();

      /**
       * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
       */
      java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition> 
          getStrokeList();
      /**
       * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
       */
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition getStroke(int index);
      /**
       * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
       */
      int getStrokeCount();
    }
    /**
     * <pre>
     * TouchEvent contains source_id and stroke.
     * Touch_events contain all key touch event.
     * Statistical information are collected for each source_id
     * by SessionUsageObserver.
     * </pre>
     *
     * Protobuf type {@code mozc.commands.Input.TouchEvent}
     */
    public  static final class TouchEvent extends
        com.google.protobuf.GeneratedMessageLite<
            TouchEvent, TouchEvent.Builder> implements
        // @@protoc_insertion_point(message_implements:mozc.commands.Input.TouchEvent)
        TouchEventOrBuilder {
      private TouchEvent() {
        stroke_ = emptyProtobufList();
      }
      private int bitField0_;
      public static final int SOURCE_ID_FIELD_NUMBER = 1;
      private int sourceId_;
      /**
       * <pre>
       * source_id specifies the user action such as "X button pressed".
       * It must be unique within the same keyboard_name,
       * which is set in Request message.
       * </pre>
       *
       * <code>optional uint32 source_id = 1;</code>
       * @return Whether the sourceId field is set.
       */
      @java.lang.Override
      public boolean hasSourceId() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * source_id specifies the user action such as "X button pressed".
       * It must be unique within the same keyboard_name,
       * which is set in Request message.
       * </pre>
       *
       * <code>optional uint32 source_id = 1;</code>
       * @return The sourceId.
       */
      @java.lang.Override
      public int getSourceId() {
        return sourceId_;
      }
      /**
       * <pre>
       * source_id specifies the user action such as "X button pressed".
       * It must be unique within the same keyboard_name,
       * which is set in Request message.
       * </pre>
       *
       * <code>optional uint32 source_id = 1;</code>
       * @param value The sourceId to set.
       */
      private void setSourceId(int value) {
        bitField0_ |= 0x00000001;
        sourceId_ = value;
      }
      /**
       * <pre>
       * source_id specifies the user action such as "X button pressed".
       * It must be unique within the same keyboard_name,
       * which is set in Request message.
       * </pre>
       *
       * <code>optional uint32 source_id = 1;</code>
       */
      private void clearSourceId() {
        bitField0_ = (bitField0_ & ~0x00000001);
        sourceId_ = 0;
      }

      public static final int STROKE_FIELD_NUMBER = 2;
      private com.google.protobuf.Internal.ProtobufList<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition> stroke_;
      /**
       * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
       */
      @java.lang.Override
      public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition> getStrokeList() {
        return stroke_;
      }
      /**
       * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
       */
      public java.util.List<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPositionOrBuilder> 
          getStrokeOrBuilderList() {
        return stroke_;
      }
      /**
       * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
       */
      @java.lang.Override
      public int getStrokeCount() {
        return stroke_.size();
      }
      /**
       * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition getStroke(int index) {
        return stroke_.get(index);
      }
      /**
       * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPositionOrBuilder getStrokeOrBuilder(
          int index) {
        return stroke_.get(index);
      }
      private void ensureStrokeIsMutable() {
        com.google.protobuf.Internal.ProtobufList<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition> tmp = stroke_;
        if (!tmp.isModifiable()) {
          stroke_ =
              com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
         }
      }

      /**
       * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
       */
      private void setStroke(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition value) {
        value.getClass();
  ensureStrokeIsMutable();
        stroke_.set(index, value);
      }
      /**
       * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
       */
      private void addStroke(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition value) {
        value.getClass();
  ensureStrokeIsMutable();
        stroke_.add(value);
      }
      /**
       * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
       */
      private void addStroke(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition value) {
        value.getClass();
  ensureStrokeIsMutable();
        stroke_.add(index, value);
      }
      /**
       * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
       */
      private void addAllStroke(
          java.lang.Iterable<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition> values) {
        ensureStrokeIsMutable();
        com.google.protobuf.AbstractMessageLite.addAll(
            values, stroke_);
      }
      /**
       * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
       */
      private void clearStroke() {
        stroke_ = emptyProtobufList();
      }
      /**
       * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
       */
      private void removeStroke(int index) {
        ensureStrokeIsMutable();
        stroke_.remove(index);
      }

      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }

      public static Builder newBuilder() {
        return (Builder) DEFAULT_INSTANCE.createBuilder();
      }
      public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent prototype) {
        return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
      }

      /**
       * <pre>
       * TouchEvent contains source_id and stroke.
       * Touch_events contain all key touch event.
       * Statistical information are collected for each source_id
       * by SessionUsageObserver.
       * </pre>
       *
       * Protobuf type {@code mozc.commands.Input.TouchEvent}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageLite.Builder<
            org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent, Builder> implements
          // @@protoc_insertion_point(builder_implements:mozc.commands.Input.TouchEvent)
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEventOrBuilder {
        // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent.newBuilder()
        private Builder() {
          super(DEFAULT_INSTANCE);
        }


        /**
         * <pre>
         * source_id specifies the user action such as "X button pressed".
         * It must be unique within the same keyboard_name,
         * which is set in Request message.
         * </pre>
         *
         * <code>optional uint32 source_id = 1;</code>
         * @return Whether the sourceId field is set.
         */
        @java.lang.Override
        public boolean hasSourceId() {
          return instance.hasSourceId();
        }
        /**
         * <pre>
         * source_id specifies the user action such as "X button pressed".
         * It must be unique within the same keyboard_name,
         * which is set in Request message.
         * </pre>
         *
         * <code>optional uint32 source_id = 1;</code>
         * @return The sourceId.
         */
        @java.lang.Override
        public int getSourceId() {
          return instance.getSourceId();
        }
        /**
         * <pre>
         * source_id specifies the user action such as "X button pressed".
         * It must be unique within the same keyboard_name,
         * which is set in Request message.
         * </pre>
         *
         * <code>optional uint32 source_id = 1;</code>
         * @param value The sourceId to set.
         * @return This builder for chaining.
         */
        public Builder setSourceId(int value) {
          copyOnWrite();
          instance.setSourceId(value);
          return this;
        }
        /**
         * <pre>
         * source_id specifies the user action such as "X button pressed".
         * It must be unique within the same keyboard_name,
         * which is set in Request message.
         * </pre>
         *
         * <code>optional uint32 source_id = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearSourceId() {
          copyOnWrite();
          instance.clearSourceId();
          return this;
        }

        /**
         * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
         */
        @java.lang.Override
        public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition> getStrokeList() {
          return java.util.Collections.unmodifiableList(
              instance.getStrokeList());
        }
        /**
         * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
         */
        @java.lang.Override
        public int getStrokeCount() {
          return instance.getStrokeCount();
        }/**
         * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
         */
        @java.lang.Override
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition getStroke(int index) {
          return instance.getStroke(index);
        }
        /**
         * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
         */
        public Builder setStroke(
            int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition value) {
          copyOnWrite();
          instance.setStroke(index, value);
          return this;
        }
        /**
         * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
         */
        public Builder setStroke(
            int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition.Builder builderForValue) {
          copyOnWrite();
          instance.setStroke(index,
              builderForValue.build());
          return this;
        }
        /**
         * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
         */
        public Builder addStroke(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition value) {
          copyOnWrite();
          instance.addStroke(value);
          return this;
        }
        /**
         * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
         */
        public Builder addStroke(
            int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition value) {
          copyOnWrite();
          instance.addStroke(index, value);
          return this;
        }
        /**
         * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
         */
        public Builder addStroke(
            org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition.Builder builderForValue) {
          copyOnWrite();
          instance.addStroke(builderForValue.build());
          return this;
        }
        /**
         * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
         */
        public Builder addStroke(
            int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition.Builder builderForValue) {
          copyOnWrite();
          instance.addStroke(index,
              builderForValue.build());
          return this;
        }
        /**
         * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
         */
        public Builder addAllStroke(
            java.lang.Iterable<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition> values) {
          copyOnWrite();
          instance.addAllStroke(values);
          return this;
        }
        /**
         * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
         */
        public Builder clearStroke() {
          copyOnWrite();
          instance.clearStroke();
          return this;
        }
        /**
         * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
         */
        public Builder removeStroke(int index) {
          copyOnWrite();
          instance.removeStroke(index);
          return this;
        }

        // @@protoc_insertion_point(builder_scope:mozc.commands.Input.TouchEvent)
      }
      @java.lang.Override
      @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
      protected final java.lang.Object dynamicMethod(
          com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
          java.lang.Object arg0, java.lang.Object arg1) {
        switch (method) {
          case NEW_MUTABLE_INSTANCE: {
            return new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent();
          }
          case NEW_BUILDER: {
            return new Builder();
          }
          case BUILD_MESSAGE_INFO: {
              java.lang.Object[] objects = new java.lang.Object[] {
                "bitField0_",
                "sourceId_",
                "stroke_",
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition.class,
              };
              java.lang.String info =
                  "\u0001\u0002\u0000\u0001\u0001\u0002\u0002\u0000\u0001\u0000\u0001\u100b\u0000\u0002" +
                  "\u001b";
              return newMessageInfo(DEFAULT_INSTANCE, info, objects);
          }
          // fall through
          case GET_DEFAULT_INSTANCE: {
            return DEFAULT_INSTANCE;
          }
          case GET_PARSER: {
            com.google.protobuf.Parser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent> parser = PARSER;
            if (parser == null) {
              synchronized (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent.class) {
                parser = PARSER;
                if (parser == null) {
                  parser =
                      new DefaultInstanceBasedParser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent>(
                          DEFAULT_INSTANCE);
                  PARSER = parser;
                }
              }
            }
            return parser;
        }
        case GET_MEMOIZED_IS_INITIALIZED: {
          return (byte) 1;
        }
        case SET_MEMOIZED_IS_INITIALIZED: {
          return null;
        }
        }
        throw new UnsupportedOperationException();
      }


      // @@protoc_insertion_point(class_scope:mozc.commands.Input.TouchEvent)
      private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent DEFAULT_INSTANCE;
      static {
        TouchEvent defaultInstance = new TouchEvent();
        // New instances are implicitly immutable so no need to make
        // immutable.
        DEFAULT_INSTANCE = defaultInstance;
        com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
          TouchEvent.class, defaultInstance);
      }

      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static volatile com.google.protobuf.Parser<TouchEvent> PARSER;

      public static com.google.protobuf.Parser<TouchEvent> parser() {
        return DEFAULT_INSTANCE.getParserForType();
      }
    }

    private int bitField0_;
    public static final int TYPE_FIELD_NUMBER = 1;
    private int type_;
    /**
     * <code>required .mozc.commands.Input.CommandType type = 1;</code>
     * @return Whether the type field is set.
     */
    @java.lang.Override
    public boolean hasType() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>required .mozc.commands.Input.CommandType type = 1;</code>
     * @return The type.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.CommandType getType() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.CommandType result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.CommandType.forNumber(type_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.CommandType.NONE : result;
    }
    /**
     * <code>required .mozc.commands.Input.CommandType type = 1;</code>
     * @param value The type to set.
     */
    private void setType(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.CommandType value) {
      type_ = value.getNumber();
      bitField0_ |= 0x00000001;
    }
    /**
     * <code>required .mozc.commands.Input.CommandType type = 1;</code>
     */
    private void clearType() {
      bitField0_ = (bitField0_ & ~0x00000001);
      type_ = 0;
    }

    public static final int ID_FIELD_NUMBER = 2;
    private long id_;
    /**
     * <pre>
     * Session ID created by CREATE_SESSION.
     * </pre>
     *
     * <code>optional uint64 id = 2 [jstype = JS_STRING];</code>
     * @return Whether the id field is set.
     */
    @java.lang.Override
    public boolean hasId() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Session ID created by CREATE_SESSION.
     * </pre>
     *
     * <code>optional uint64 id = 2 [jstype = JS_STRING];</code>
     * @return The id.
     */
    @java.lang.Override
    public long getId() {
      return id_;
    }
    /**
     * <pre>
     * Session ID created by CREATE_SESSION.
     * </pre>
     *
     * <code>optional uint64 id = 2 [jstype = JS_STRING];</code>
     * @param value The id to set.
     */
    private void setId(long value) {
      bitField0_ |= 0x00000002;
      id_ = value;
    }
    /**
     * <pre>
     * Session ID created by CREATE_SESSION.
     * </pre>
     *
     * <code>optional uint64 id = 2 [jstype = JS_STRING];</code>
     */
    private void clearId() {
      bitField0_ = (bitField0_ & ~0x00000002);
      id_ = 0L;
    }

    public static final int KEY_FIELD_NUMBER = 3;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent key_;
    /**
     * <pre>
     * Key combinations used for SEND_KEY or TEST_SEND_KEY.
     * </pre>
     *
     * <code>optional .mozc.commands.KeyEvent key = 3;</code>
     */
    @java.lang.Override
    public boolean hasKey() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Key combinations used for SEND_KEY or TEST_SEND_KEY.
     * </pre>
     *
     * <code>optional .mozc.commands.KeyEvent key = 3;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent getKey() {
      return key_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.getDefaultInstance() : key_;
    }
    /**
     * <pre>
     * Key combinations used for SEND_KEY or TEST_SEND_KEY.
     * </pre>
     *
     * <code>optional .mozc.commands.KeyEvent key = 3;</code>
     */
    private void setKey(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent value) {
      value.getClass();
  key_ = value;
      bitField0_ |= 0x00000004;
      }
    /**
     * <pre>
     * Key combinations used for SEND_KEY or TEST_SEND_KEY.
     * </pre>
     *
     * <code>optional .mozc.commands.KeyEvent key = 3;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeKey(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent value) {
      value.getClass();
  if (key_ != null &&
          key_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.getDefaultInstance()) {
        key_ =
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.newBuilder(key_).mergeFrom(value).buildPartial();
      } else {
        key_ = value;
      }
      bitField0_ |= 0x00000004;
    }
    /**
     * <pre>
     * Key combinations used for SEND_KEY or TEST_SEND_KEY.
     * </pre>
     *
     * <code>optional .mozc.commands.KeyEvent key = 3;</code>
     */
    private void clearKey() {  key_ = null;
      bitField0_ = (bitField0_ & ~0x00000004);
    }

    public static final int COMMAND_FIELD_NUMBER = 4;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand command_;
    /**
     * <pre>
     * Command sent to the session layer used with SEND_COMMAND.
     * </pre>
     *
     * <code>optional .mozc.commands.SessionCommand command = 4;</code>
     */
    @java.lang.Override
    public boolean hasCommand() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Command sent to the session layer used with SEND_COMMAND.
     * </pre>
     *
     * <code>optional .mozc.commands.SessionCommand command = 4;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand getCommand() {
      return command_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.getDefaultInstance() : command_;
    }
    /**
     * <pre>
     * Command sent to the session layer used with SEND_COMMAND.
     * </pre>
     *
     * <code>optional .mozc.commands.SessionCommand command = 4;</code>
     */
    private void setCommand(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand value) {
      value.getClass();
  command_ = value;
      bitField0_ |= 0x00000008;
      }
    /**
     * <pre>
     * Command sent to the session layer used with SEND_COMMAND.
     * </pre>
     *
     * <code>optional .mozc.commands.SessionCommand command = 4;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeCommand(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand value) {
      value.getClass();
  if (command_ != null &&
          command_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.getDefaultInstance()) {
        command_ =
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.newBuilder(command_).mergeFrom(value).buildPartial();
      } else {
        command_ = value;
      }
      bitField0_ |= 0x00000008;
    }
    /**
     * <pre>
     * Command sent to the session layer used with SEND_COMMAND.
     * </pre>
     *
     * <code>optional .mozc.commands.SessionCommand command = 4;</code>
     */
    private void clearCommand() {  command_ = null;
      bitField0_ = (bitField0_ & ~0x00000008);
    }

    public static final int CONFIG_FIELD_NUMBER = 5;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config config_;
    /**
     * <pre>
     * Input config
     * </pre>
     *
     * <code>optional .mozc.config.Config config = 5;</code>
     */
    @java.lang.Override
    public boolean hasConfig() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Input config
     * </pre>
     *
     * <code>optional .mozc.config.Config config = 5;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config getConfig() {
      return config_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDefaultInstance() : config_;
    }
    /**
     * <pre>
     * Input config
     * </pre>
     *
     * <code>optional .mozc.config.Config config = 5;</code>
     */
    private void setConfig(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config value) {
      value.getClass();
  config_ = value;
      bitField0_ |= 0x00000010;
      }
    /**
     * <pre>
     * Input config
     * </pre>
     *
     * <code>optional .mozc.config.Config config = 5;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeConfig(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config value) {
      value.getClass();
  if (config_ != null &&
          config_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDefaultInstance()) {
        config_ =
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.newBuilder(config_).mergeFrom(value).buildPartial();
      } else {
        config_ = value;
      }
      bitField0_ |= 0x00000010;
    }
    /**
     * <pre>
     * Input config
     * </pre>
     *
     * <code>optional .mozc.config.Config config = 5;</code>
     */
    private void clearConfig() {  config_ = null;
      bitField0_ = (bitField0_ & ~0x00000010);
    }

    public static final int CONTEXT_FIELD_NUMBER = 6;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context context_;
    /**
     * <pre>
     * Context data
     * </pre>
     *
     * <code>optional .mozc.commands.Context context = 6;</code>
     */
    @java.lang.Override
    public boolean hasContext() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * Context data
     * </pre>
     *
     * <code>optional .mozc.commands.Context context = 6;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context getContext() {
      return context_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.getDefaultInstance() : context_;
    }
    /**
     * <pre>
     * Context data
     * </pre>
     *
     * <code>optional .mozc.commands.Context context = 6;</code>
     */
    private void setContext(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context value) {
      value.getClass();
  context_ = value;
      bitField0_ |= 0x00000020;
      }
    /**
     * <pre>
     * Context data
     * </pre>
     *
     * <code>optional .mozc.commands.Context context = 6;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeContext(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context value) {
      value.getClass();
  if (context_ != null &&
          context_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.getDefaultInstance()) {
        context_ =
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.newBuilder(context_).mergeFrom(value).buildPartial();
      } else {
        context_ = value;
      }
      bitField0_ |= 0x00000020;
    }
    /**
     * <pre>
     * Context data
     * </pre>
     *
     * <code>optional .mozc.commands.Context context = 6;</code>
     */
    private void clearContext() {  context_ = null;
      bitField0_ = (bitField0_ & ~0x00000020);
    }

    public static final int CAPABILITY_FIELD_NUMBER = 7;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability capability_;
    /**
     * <pre>
     * Client capability
     * </pre>
     *
     * <code>optional .mozc.commands.Capability capability = 7;</code>
     */
    @java.lang.Override
    public boolean hasCapability() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * Client capability
     * </pre>
     *
     * <code>optional .mozc.commands.Capability capability = 7;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability getCapability() {
      return capability_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.getDefaultInstance() : capability_;
    }
    /**
     * <pre>
     * Client capability
     * </pre>
     *
     * <code>optional .mozc.commands.Capability capability = 7;</code>
     */
    private void setCapability(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability value) {
      value.getClass();
  capability_ = value;
      bitField0_ |= 0x00000040;
      }
    /**
     * <pre>
     * Client capability
     * </pre>
     *
     * <code>optional .mozc.commands.Capability capability = 7;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeCapability(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability value) {
      value.getClass();
  if (capability_ != null &&
          capability_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.getDefaultInstance()) {
        capability_ =
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.newBuilder(capability_).mergeFrom(value).buildPartial();
      } else {
        capability_ = value;
      }
      bitField0_ |= 0x00000040;
    }
    /**
     * <pre>
     * Client capability
     * </pre>
     *
     * <code>optional .mozc.commands.Capability capability = 7;</code>
     */
    private void clearCapability() {  capability_ = null;
      bitField0_ = (bitField0_ & ~0x00000040);
    }

    public static final int APPLICATION_INFO_FIELD_NUMBER = 8;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo applicationInfo_;
    /**
     * <pre>
     * Application information, like process id.
     * Server may be able to change the behavior by seeing the
     * the program name.
     * </pre>
     *
     * <code>optional .mozc.commands.ApplicationInfo application_info = 8;</code>
     */
    @java.lang.Override
    public boolean hasApplicationInfo() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * Application information, like process id.
     * Server may be able to change the behavior by seeing the
     * the program name.
     * </pre>
     *
     * <code>optional .mozc.commands.ApplicationInfo application_info = 8;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo getApplicationInfo() {
      return applicationInfo_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo.getDefaultInstance() : applicationInfo_;
    }
    /**
     * <pre>
     * Application information, like process id.
     * Server may be able to change the behavior by seeing the
     * the program name.
     * </pre>
     *
     * <code>optional .mozc.commands.ApplicationInfo application_info = 8;</code>
     */
    private void setApplicationInfo(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo value) {
      value.getClass();
  applicationInfo_ = value;
      bitField0_ |= 0x00000080;
      }
    /**
     * <pre>
     * Application information, like process id.
     * Server may be able to change the behavior by seeing the
     * the program name.
     * </pre>
     *
     * <code>optional .mozc.commands.ApplicationInfo application_info = 8;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeApplicationInfo(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo value) {
      value.getClass();
  if (applicationInfo_ != null &&
          applicationInfo_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo.getDefaultInstance()) {
        applicationInfo_ =
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo.newBuilder(applicationInfo_).mergeFrom(value).buildPartial();
      } else {
        applicationInfo_ = value;
      }
      bitField0_ |= 0x00000080;
    }
    /**
     * <pre>
     * Application information, like process id.
     * Server may be able to change the behavior by seeing the
     * the program name.
     * </pre>
     *
     * <code>optional .mozc.commands.ApplicationInfo application_info = 8;</code>
     */
    private void clearApplicationInfo() {  applicationInfo_ = null;
      bitField0_ = (bitField0_ & ~0x00000080);
    }

    public static final int REQUEST_FIELD_NUMBER = 9;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request request_;
    /**
     * <pre>
     * Client request
     * </pre>
     *
     * <code>optional .mozc.commands.Request request = 9;</code>
     */
    @java.lang.Override
    public boolean hasRequest() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * Client request
     * </pre>
     *
     * <code>optional .mozc.commands.Request request = 9;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request getRequest() {
      return request_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.getDefaultInstance() : request_;
    }
    /**
     * <pre>
     * Client request
     * </pre>
     *
     * <code>optional .mozc.commands.Request request = 9;</code>
     */
    private void setRequest(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request value) {
      value.getClass();
  request_ = value;
      bitField0_ |= 0x00000100;
      }
    /**
     * <pre>
     * Client request
     * </pre>
     *
     * <code>optional .mozc.commands.Request request = 9;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeRequest(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request value) {
      value.getClass();
  if (request_ != null &&
          request_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.getDefaultInstance()) {
        request_ =
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.newBuilder(request_).mergeFrom(value).buildPartial();
      } else {
        request_ = value;
      }
      bitField0_ |= 0x00000100;
    }
    /**
     * <pre>
     * Client request
     * </pre>
     *
     * <code>optional .mozc.commands.Request request = 9;</code>
     */
    private void clearRequest() {  request_ = null;
      bitField0_ = (bitField0_ & ~0x00000100);
    }

    public static final int TOUCH_EVENTS_FIELD_NUMBER = 12;
    private com.google.protobuf.Internal.ProtobufList<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent> touchEvents_;
    /**
     * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
     */
    @java.lang.Override
    public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent> getTouchEventsList() {
      return touchEvents_;
    }
    /**
     * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
     */
    public java.util.List<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEventOrBuilder> 
        getTouchEventsOrBuilderList() {
      return touchEvents_;
    }
    /**
     * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
     */
    @java.lang.Override
    public int getTouchEventsCount() {
      return touchEvents_.size();
    }
    /**
     * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent getTouchEvents(int index) {
      return touchEvents_.get(index);
    }
    /**
     * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
     */
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEventOrBuilder getTouchEventsOrBuilder(
        int index) {
      return touchEvents_.get(index);
    }
    private void ensureTouchEventsIsMutable() {
      com.google.protobuf.Internal.ProtobufList<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent> tmp = touchEvents_;
      if (!tmp.isModifiable()) {
        touchEvents_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
     */
    private void setTouchEvents(
        int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent value) {
      value.getClass();
  ensureTouchEventsIsMutable();
      touchEvents_.set(index, value);
    }
    /**
     * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
     */
    private void addTouchEvents(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent value) {
      value.getClass();
  ensureTouchEventsIsMutable();
      touchEvents_.add(value);
    }
    /**
     * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
     */
    private void addTouchEvents(
        int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent value) {
      value.getClass();
  ensureTouchEventsIsMutable();
      touchEvents_.add(index, value);
    }
    /**
     * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
     */
    private void addAllTouchEvents(
        java.lang.Iterable<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent> values) {
      ensureTouchEventsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, touchEvents_);
    }
    /**
     * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
     */
    private void clearTouchEvents() {
      touchEvents_ = emptyProtobufList();
    }
    /**
     * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
     */
    private void removeTouchEvents(int index) {
      ensureTouchEventsIsMutable();
      touchEvents_.remove(index);
    }

    public static final int USER_DICTIONARY_IMPORT_DATA_FIELD_NUMBER = 17;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryImportData userDictionaryImportData_;
    /**
     * <code>optional .mozc.user_dictionary.UserDictionaryImportData user_dictionary_import_data = 17;</code>
     */
    @java.lang.Override
    public boolean hasUserDictionaryImportData() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <code>optional .mozc.user_dictionary.UserDictionaryImportData user_dictionary_import_data = 17;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryImportData getUserDictionaryImportData() {
      return userDictionaryImportData_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryImportData.getDefaultInstance() : userDictionaryImportData_;
    }
    /**
     * <code>optional .mozc.user_dictionary.UserDictionaryImportData user_dictionary_import_data = 17;</code>
     */
    private void setUserDictionaryImportData(org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryImportData value) {
      value.getClass();
  userDictionaryImportData_ = value;
      bitField0_ |= 0x00000200;
      }
    /**
     * <code>optional .mozc.user_dictionary.UserDictionaryImportData user_dictionary_import_data = 17;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeUserDictionaryImportData(org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryImportData value) {
      value.getClass();
  if (userDictionaryImportData_ != null &&
          userDictionaryImportData_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryImportData.getDefaultInstance()) {
        userDictionaryImportData_ =
          org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryImportData.newBuilder(userDictionaryImportData_).mergeFrom(value).buildPartial();
      } else {
        userDictionaryImportData_ = value;
      }
      bitField0_ |= 0x00000200;
    }
    /**
     * <code>optional .mozc.user_dictionary.UserDictionaryImportData user_dictionary_import_data = 17;</code>
     */
    private void clearUserDictionaryImportData() {  userDictionaryImportData_ = null;
      bitField0_ = (bitField0_ & ~0x00000200);
    }

    public static final int REQUEST_SUGGESTION_FIELD_NUMBER = 14;
    private boolean requestSuggestion_;
    /**
     * <pre>
     * A flag to control if the server should return suggest-results or not.
     * If this is set to false, regardless of other configurations,
     * the server won't return suggestion results.
     * This is set to true by default.
     * Note that even if this flag is set to false, when a suggestion is shown
     * in the previous phase, it is possible from the client to submit it.
     * This works only for suggestions for the key insertion, but not for
     * others commands, such as predictions or conversions.
     * This flag is used for the performance improvement in terms of the
     * latency.  If you want to suppress the suggestions for the UX improment,
     * you may want to use suppress_suggestion in the Context message.
     * </pre>
     *
     * <code>optional bool request_suggestion = 14 [default = true];</code>
     * @return Whether the requestSuggestion field is set.
     */
    @java.lang.Override
    public boolean hasRequestSuggestion() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     * <pre>
     * A flag to control if the server should return suggest-results or not.
     * If this is set to false, regardless of other configurations,
     * the server won't return suggestion results.
     * This is set to true by default.
     * Note that even if this flag is set to false, when a suggestion is shown
     * in the previous phase, it is possible from the client to submit it.
     * This works only for suggestions for the key insertion, but not for
     * others commands, such as predictions or conversions.
     * This flag is used for the performance improvement in terms of the
     * latency.  If you want to suppress the suggestions for the UX improment,
     * you may want to use suppress_suggestion in the Context message.
     * </pre>
     *
     * <code>optional bool request_suggestion = 14 [default = true];</code>
     * @return The requestSuggestion.
     */
    @java.lang.Override
    public boolean getRequestSuggestion() {
      return requestSuggestion_;
    }
    /**
     * <pre>
     * A flag to control if the server should return suggest-results or not.
     * If this is set to false, regardless of other configurations,
     * the server won't return suggestion results.
     * This is set to true by default.
     * Note that even if this flag is set to false, when a suggestion is shown
     * in the previous phase, it is possible from the client to submit it.
     * This works only for suggestions for the key insertion, but not for
     * others commands, such as predictions or conversions.
     * This flag is used for the performance improvement in terms of the
     * latency.  If you want to suppress the suggestions for the UX improment,
     * you may want to use suppress_suggestion in the Context message.
     * </pre>
     *
     * <code>optional bool request_suggestion = 14 [default = true];</code>
     * @param value The requestSuggestion to set.
     */
    private void setRequestSuggestion(boolean value) {
      bitField0_ |= 0x00000400;
      requestSuggestion_ = value;
    }
    /**
     * <pre>
     * A flag to control if the server should return suggest-results or not.
     * If this is set to false, regardless of other configurations,
     * the server won't return suggestion results.
     * This is set to true by default.
     * Note that even if this flag is set to false, when a suggestion is shown
     * in the previous phase, it is possible from the client to submit it.
     * This works only for suggestions for the key insertion, but not for
     * others commands, such as predictions or conversions.
     * This flag is used for the performance improvement in terms of the
     * latency.  If you want to suppress the suggestions for the UX improment,
     * you may want to use suppress_suggestion in the Context message.
     * </pre>
     *
     * <code>optional bool request_suggestion = 14 [default = true];</code>
     */
    private void clearRequestSuggestion() {
      bitField0_ = (bitField0_ & ~0x00000400);
      requestSuggestion_ = true;
    }

    public static final int ENGINE_RELOAD_REQUEST_FIELD_NUMBER = 15;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadRequest engineReloadRequest_;
    /**
     * <code>optional .mozc.EngineReloadRequest engine_reload_request = 15;</code>
     */
    @java.lang.Override
    public boolean hasEngineReloadRequest() {
      return ((bitField0_ & 0x00000800) != 0);
    }
    /**
     * <code>optional .mozc.EngineReloadRequest engine_reload_request = 15;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadRequest getEngineReloadRequest() {
      return engineReloadRequest_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadRequest.getDefaultInstance() : engineReloadRequest_;
    }
    /**
     * <code>optional .mozc.EngineReloadRequest engine_reload_request = 15;</code>
     */
    private void setEngineReloadRequest(org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadRequest value) {
      value.getClass();
  engineReloadRequest_ = value;
      bitField0_ |= 0x00000800;
      }
    /**
     * <code>optional .mozc.EngineReloadRequest engine_reload_request = 15;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeEngineReloadRequest(org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadRequest value) {
      value.getClass();
  if (engineReloadRequest_ != null &&
          engineReloadRequest_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadRequest.getDefaultInstance()) {
        engineReloadRequest_ =
          org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadRequest.newBuilder(engineReloadRequest_).mergeFrom(value).buildPartial();
      } else {
        engineReloadRequest_ = value;
      }
      bitField0_ |= 0x00000800;
    }
    /**
     * <code>optional .mozc.EngineReloadRequest engine_reload_request = 15;</code>
     */
    private void clearEngineReloadRequest() {  engineReloadRequest_ = null;
      bitField0_ = (bitField0_ & ~0x00000800);
    }

    public static final int USER_HISTORY_DATA_FIELD_NUMBER = 18;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.UserHistoryData userHistoryData_;
    /**
     * <code>optional .mozc.commands.UserHistoryData user_history_data = 18;</code>
     */
    @java.lang.Override
    public boolean hasUserHistoryData() {
      return ((bitField0_ & 0x00001000) != 0);
    }
    /**
     * <code>optional .mozc.commands.UserHistoryData user_history_data = 18;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.UserHistoryData getUserHistoryData() {
      return userHistoryData_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.UserHistoryData.getDefaultInstance() : userHistoryData_;
    }
    /**
     * <code>optional .mozc.commands.UserHistoryData user_history_data = 18;</code>
     */
    private void setUserHistoryData(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.UserHistoryData value) {
      value.getClass();
  userHistoryData_ = value;
      bitField0_ |= 0x00001000;
      }
    /**
     * <code>optional .mozc.commands.UserHistoryData user_history_data = 18;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeUserHistoryData(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.UserHistoryData value) {
      value.getClass();
  if (userHistoryData_ != null &&
          userHistoryData_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.UserHistoryData.getDefaultInstance()) {
        userHistoryData_ =
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.UserHistoryData.newBuilder(userHistoryData_).mergeFrom(value).buildPartial();
      } else {
        userHistoryData_ = value;
      }
      bitField0_ |= 0x00001000;
    }
    /**
     * <code>optional .mozc.commands.UserHistoryData user_history_data = 18;</code>
     */
    private void clearUserHistoryData() {  userHistoryData_ = null;
      bitField0_ = (bitField0_ & ~0x00001000);
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code mozc.commands.Input}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input, Builder> implements
        // @@protoc_insertion_point(builder_implements:mozc.commands.Input)
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.InputOrBuilder {
      // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>required .mozc.commands.Input.CommandType type = 1;</code>
       * @return Whether the type field is set.
       */
      @java.lang.Override
      public boolean hasType() {
        return instance.hasType();
      }
      /**
       * <code>required .mozc.commands.Input.CommandType type = 1;</code>
       * @return The type.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.CommandType getType() {
        return instance.getType();
      }
      /**
       * <code>required .mozc.commands.Input.CommandType type = 1;</code>
       * @param value The enum numeric value on the wire for type to set.
       * @return This builder for chaining.
       */
      public Builder setType(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.CommandType value) {
        copyOnWrite();
        instance.setType(value);
        return this;
      }
      /**
       * <code>required .mozc.commands.Input.CommandType type = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearType() {
        copyOnWrite();
        instance.clearType();
        return this;
      }

      /**
       * <pre>
       * Session ID created by CREATE_SESSION.
       * </pre>
       *
       * <code>optional uint64 id = 2 [jstype = JS_STRING];</code>
       * @return Whether the id field is set.
       */
      @java.lang.Override
      public boolean hasId() {
        return instance.hasId();
      }
      /**
       * <pre>
       * Session ID created by CREATE_SESSION.
       * </pre>
       *
       * <code>optional uint64 id = 2 [jstype = JS_STRING];</code>
       * @return The id.
       */
      @java.lang.Override
      public long getId() {
        return instance.getId();
      }
      /**
       * <pre>
       * Session ID created by CREATE_SESSION.
       * </pre>
       *
       * <code>optional uint64 id = 2 [jstype = JS_STRING];</code>
       * @param value The id to set.
       * @return This builder for chaining.
       */
      public Builder setId(long value) {
        copyOnWrite();
        instance.setId(value);
        return this;
      }
      /**
       * <pre>
       * Session ID created by CREATE_SESSION.
       * </pre>
       *
       * <code>optional uint64 id = 2 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearId() {
        copyOnWrite();
        instance.clearId();
        return this;
      }

      /**
       * <pre>
       * Key combinations used for SEND_KEY or TEST_SEND_KEY.
       * </pre>
       *
       * <code>optional .mozc.commands.KeyEvent key = 3;</code>
       */
      @java.lang.Override
      public boolean hasKey() {
        return instance.hasKey();
      }
      /**
       * <pre>
       * Key combinations used for SEND_KEY or TEST_SEND_KEY.
       * </pre>
       *
       * <code>optional .mozc.commands.KeyEvent key = 3;</code>
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent getKey() {
        return instance.getKey();
      }
      /**
       * <pre>
       * Key combinations used for SEND_KEY or TEST_SEND_KEY.
       * </pre>
       *
       * <code>optional .mozc.commands.KeyEvent key = 3;</code>
       */
      public Builder setKey(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent value) {
        copyOnWrite();
        instance.setKey(value);
        return this;
        }
      /**
       * <pre>
       * Key combinations used for SEND_KEY or TEST_SEND_KEY.
       * </pre>
       *
       * <code>optional .mozc.commands.KeyEvent key = 3;</code>
       */
      public Builder setKey(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.Builder builderForValue) {
        copyOnWrite();
        instance.setKey(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Key combinations used for SEND_KEY or TEST_SEND_KEY.
       * </pre>
       *
       * <code>optional .mozc.commands.KeyEvent key = 3;</code>
       */
      public Builder mergeKey(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent value) {
        copyOnWrite();
        instance.mergeKey(value);
        return this;
      }
      /**
       * <pre>
       * Key combinations used for SEND_KEY or TEST_SEND_KEY.
       * </pre>
       *
       * <code>optional .mozc.commands.KeyEvent key = 3;</code>
       */
      public Builder clearKey() {  copyOnWrite();
        instance.clearKey();
        return this;
      }

      /**
       * <pre>
       * Command sent to the session layer used with SEND_COMMAND.
       * </pre>
       *
       * <code>optional .mozc.commands.SessionCommand command = 4;</code>
       */
      @java.lang.Override
      public boolean hasCommand() {
        return instance.hasCommand();
      }
      /**
       * <pre>
       * Command sent to the session layer used with SEND_COMMAND.
       * </pre>
       *
       * <code>optional .mozc.commands.SessionCommand command = 4;</code>
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand getCommand() {
        return instance.getCommand();
      }
      /**
       * <pre>
       * Command sent to the session layer used with SEND_COMMAND.
       * </pre>
       *
       * <code>optional .mozc.commands.SessionCommand command = 4;</code>
       */
      public Builder setCommand(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand value) {
        copyOnWrite();
        instance.setCommand(value);
        return this;
        }
      /**
       * <pre>
       * Command sent to the session layer used with SEND_COMMAND.
       * </pre>
       *
       * <code>optional .mozc.commands.SessionCommand command = 4;</code>
       */
      public Builder setCommand(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.Builder builderForValue) {
        copyOnWrite();
        instance.setCommand(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Command sent to the session layer used with SEND_COMMAND.
       * </pre>
       *
       * <code>optional .mozc.commands.SessionCommand command = 4;</code>
       */
      public Builder mergeCommand(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand value) {
        copyOnWrite();
        instance.mergeCommand(value);
        return this;
      }
      /**
       * <pre>
       * Command sent to the session layer used with SEND_COMMAND.
       * </pre>
       *
       * <code>optional .mozc.commands.SessionCommand command = 4;</code>
       */
      public Builder clearCommand() {  copyOnWrite();
        instance.clearCommand();
        return this;
      }

      /**
       * <pre>
       * Input config
       * </pre>
       *
       * <code>optional .mozc.config.Config config = 5;</code>
       */
      @java.lang.Override
      public boolean hasConfig() {
        return instance.hasConfig();
      }
      /**
       * <pre>
       * Input config
       * </pre>
       *
       * <code>optional .mozc.config.Config config = 5;</code>
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config getConfig() {
        return instance.getConfig();
      }
      /**
       * <pre>
       * Input config
       * </pre>
       *
       * <code>optional .mozc.config.Config config = 5;</code>
       */
      public Builder setConfig(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config value) {
        copyOnWrite();
        instance.setConfig(value);
        return this;
        }
      /**
       * <pre>
       * Input config
       * </pre>
       *
       * <code>optional .mozc.config.Config config = 5;</code>
       */
      public Builder setConfig(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.Builder builderForValue) {
        copyOnWrite();
        instance.setConfig(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Input config
       * </pre>
       *
       * <code>optional .mozc.config.Config config = 5;</code>
       */
      public Builder mergeConfig(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config value) {
        copyOnWrite();
        instance.mergeConfig(value);
        return this;
      }
      /**
       * <pre>
       * Input config
       * </pre>
       *
       * <code>optional .mozc.config.Config config = 5;</code>
       */
      public Builder clearConfig() {  copyOnWrite();
        instance.clearConfig();
        return this;
      }

      /**
       * <pre>
       * Context data
       * </pre>
       *
       * <code>optional .mozc.commands.Context context = 6;</code>
       */
      @java.lang.Override
      public boolean hasContext() {
        return instance.hasContext();
      }
      /**
       * <pre>
       * Context data
       * </pre>
       *
       * <code>optional .mozc.commands.Context context = 6;</code>
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context getContext() {
        return instance.getContext();
      }
      /**
       * <pre>
       * Context data
       * </pre>
       *
       * <code>optional .mozc.commands.Context context = 6;</code>
       */
      public Builder setContext(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context value) {
        copyOnWrite();
        instance.setContext(value);
        return this;
        }
      /**
       * <pre>
       * Context data
       * </pre>
       *
       * <code>optional .mozc.commands.Context context = 6;</code>
       */
      public Builder setContext(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.Builder builderForValue) {
        copyOnWrite();
        instance.setContext(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Context data
       * </pre>
       *
       * <code>optional .mozc.commands.Context context = 6;</code>
       */
      public Builder mergeContext(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context value) {
        copyOnWrite();
        instance.mergeContext(value);
        return this;
      }
      /**
       * <pre>
       * Context data
       * </pre>
       *
       * <code>optional .mozc.commands.Context context = 6;</code>
       */
      public Builder clearContext() {  copyOnWrite();
        instance.clearContext();
        return this;
      }

      /**
       * <pre>
       * Client capability
       * </pre>
       *
       * <code>optional .mozc.commands.Capability capability = 7;</code>
       */
      @java.lang.Override
      public boolean hasCapability() {
        return instance.hasCapability();
      }
      /**
       * <pre>
       * Client capability
       * </pre>
       *
       * <code>optional .mozc.commands.Capability capability = 7;</code>
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability getCapability() {
        return instance.getCapability();
      }
      /**
       * <pre>
       * Client capability
       * </pre>
       *
       * <code>optional .mozc.commands.Capability capability = 7;</code>
       */
      public Builder setCapability(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability value) {
        copyOnWrite();
        instance.setCapability(value);
        return this;
        }
      /**
       * <pre>
       * Client capability
       * </pre>
       *
       * <code>optional .mozc.commands.Capability capability = 7;</code>
       */
      public Builder setCapability(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.Builder builderForValue) {
        copyOnWrite();
        instance.setCapability(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Client capability
       * </pre>
       *
       * <code>optional .mozc.commands.Capability capability = 7;</code>
       */
      public Builder mergeCapability(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability value) {
        copyOnWrite();
        instance.mergeCapability(value);
        return this;
      }
      /**
       * <pre>
       * Client capability
       * </pre>
       *
       * <code>optional .mozc.commands.Capability capability = 7;</code>
       */
      public Builder clearCapability() {  copyOnWrite();
        instance.clearCapability();
        return this;
      }

      /**
       * <pre>
       * Application information, like process id.
       * Server may be able to change the behavior by seeing the
       * the program name.
       * </pre>
       *
       * <code>optional .mozc.commands.ApplicationInfo application_info = 8;</code>
       */
      @java.lang.Override
      public boolean hasApplicationInfo() {
        return instance.hasApplicationInfo();
      }
      /**
       * <pre>
       * Application information, like process id.
       * Server may be able to change the behavior by seeing the
       * the program name.
       * </pre>
       *
       * <code>optional .mozc.commands.ApplicationInfo application_info = 8;</code>
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo getApplicationInfo() {
        return instance.getApplicationInfo();
      }
      /**
       * <pre>
       * Application information, like process id.
       * Server may be able to change the behavior by seeing the
       * the program name.
       * </pre>
       *
       * <code>optional .mozc.commands.ApplicationInfo application_info = 8;</code>
       */
      public Builder setApplicationInfo(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo value) {
        copyOnWrite();
        instance.setApplicationInfo(value);
        return this;
        }
      /**
       * <pre>
       * Application information, like process id.
       * Server may be able to change the behavior by seeing the
       * the program name.
       * </pre>
       *
       * <code>optional .mozc.commands.ApplicationInfo application_info = 8;</code>
       */
      public Builder setApplicationInfo(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo.Builder builderForValue) {
        copyOnWrite();
        instance.setApplicationInfo(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Application information, like process id.
       * Server may be able to change the behavior by seeing the
       * the program name.
       * </pre>
       *
       * <code>optional .mozc.commands.ApplicationInfo application_info = 8;</code>
       */
      public Builder mergeApplicationInfo(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo value) {
        copyOnWrite();
        instance.mergeApplicationInfo(value);
        return this;
      }
      /**
       * <pre>
       * Application information, like process id.
       * Server may be able to change the behavior by seeing the
       * the program name.
       * </pre>
       *
       * <code>optional .mozc.commands.ApplicationInfo application_info = 8;</code>
       */
      public Builder clearApplicationInfo() {  copyOnWrite();
        instance.clearApplicationInfo();
        return this;
      }

      /**
       * <pre>
       * Client request
       * </pre>
       *
       * <code>optional .mozc.commands.Request request = 9;</code>
       */
      @java.lang.Override
      public boolean hasRequest() {
        return instance.hasRequest();
      }
      /**
       * <pre>
       * Client request
       * </pre>
       *
       * <code>optional .mozc.commands.Request request = 9;</code>
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request getRequest() {
        return instance.getRequest();
      }
      /**
       * <pre>
       * Client request
       * </pre>
       *
       * <code>optional .mozc.commands.Request request = 9;</code>
       */
      public Builder setRequest(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request value) {
        copyOnWrite();
        instance.setRequest(value);
        return this;
        }
      /**
       * <pre>
       * Client request
       * </pre>
       *
       * <code>optional .mozc.commands.Request request = 9;</code>
       */
      public Builder setRequest(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.Builder builderForValue) {
        copyOnWrite();
        instance.setRequest(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Client request
       * </pre>
       *
       * <code>optional .mozc.commands.Request request = 9;</code>
       */
      public Builder mergeRequest(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request value) {
        copyOnWrite();
        instance.mergeRequest(value);
        return this;
      }
      /**
       * <pre>
       * Client request
       * </pre>
       *
       * <code>optional .mozc.commands.Request request = 9;</code>
       */
      public Builder clearRequest() {  copyOnWrite();
        instance.clearRequest();
        return this;
      }

      /**
       * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
       */
      @java.lang.Override
      public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent> getTouchEventsList() {
        return java.util.Collections.unmodifiableList(
            instance.getTouchEventsList());
      }
      /**
       * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
       */
      @java.lang.Override
      public int getTouchEventsCount() {
        return instance.getTouchEventsCount();
      }/**
       * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent getTouchEvents(int index) {
        return instance.getTouchEvents(index);
      }
      /**
       * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
       */
      public Builder setTouchEvents(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent value) {
        copyOnWrite();
        instance.setTouchEvents(index, value);
        return this;
      }
      /**
       * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
       */
      public Builder setTouchEvents(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent.Builder builderForValue) {
        copyOnWrite();
        instance.setTouchEvents(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
       */
      public Builder addTouchEvents(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent value) {
        copyOnWrite();
        instance.addTouchEvents(value);
        return this;
      }
      /**
       * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
       */
      public Builder addTouchEvents(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent value) {
        copyOnWrite();
        instance.addTouchEvents(index, value);
        return this;
      }
      /**
       * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
       */
      public Builder addTouchEvents(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent.Builder builderForValue) {
        copyOnWrite();
        instance.addTouchEvents(builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
       */
      public Builder addTouchEvents(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent.Builder builderForValue) {
        copyOnWrite();
        instance.addTouchEvents(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
       */
      public Builder addAllTouchEvents(
          java.lang.Iterable<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent> values) {
        copyOnWrite();
        instance.addAllTouchEvents(values);
        return this;
      }
      /**
       * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
       */
      public Builder clearTouchEvents() {
        copyOnWrite();
        instance.clearTouchEvents();
        return this;
      }
      /**
       * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
       */
      public Builder removeTouchEvents(int index) {
        copyOnWrite();
        instance.removeTouchEvents(index);
        return this;
      }

      /**
       * <code>optional .mozc.user_dictionary.UserDictionaryImportData user_dictionary_import_data = 17;</code>
       */
      @java.lang.Override
      public boolean hasUserDictionaryImportData() {
        return instance.hasUserDictionaryImportData();
      }
      /**
       * <code>optional .mozc.user_dictionary.UserDictionaryImportData user_dictionary_import_data = 17;</code>
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryImportData getUserDictionaryImportData() {
        return instance.getUserDictionaryImportData();
      }
      /**
       * <code>optional .mozc.user_dictionary.UserDictionaryImportData user_dictionary_import_data = 17;</code>
       */
      public Builder setUserDictionaryImportData(org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryImportData value) {
        copyOnWrite();
        instance.setUserDictionaryImportData(value);
        return this;
        }
      /**
       * <code>optional .mozc.user_dictionary.UserDictionaryImportData user_dictionary_import_data = 17;</code>
       */
      public Builder setUserDictionaryImportData(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryImportData.Builder builderForValue) {
        copyOnWrite();
        instance.setUserDictionaryImportData(builderForValue.build());
        return this;
      }
      /**
       * <code>optional .mozc.user_dictionary.UserDictionaryImportData user_dictionary_import_data = 17;</code>
       */
      public Builder mergeUserDictionaryImportData(org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryImportData value) {
        copyOnWrite();
        instance.mergeUserDictionaryImportData(value);
        return this;
      }
      /**
       * <code>optional .mozc.user_dictionary.UserDictionaryImportData user_dictionary_import_data = 17;</code>
       */
      public Builder clearUserDictionaryImportData() {  copyOnWrite();
        instance.clearUserDictionaryImportData();
        return this;
      }

      /**
       * <pre>
       * A flag to control if the server should return suggest-results or not.
       * If this is set to false, regardless of other configurations,
       * the server won't return suggestion results.
       * This is set to true by default.
       * Note that even if this flag is set to false, when a suggestion is shown
       * in the previous phase, it is possible from the client to submit it.
       * This works only for suggestions for the key insertion, but not for
       * others commands, such as predictions or conversions.
       * This flag is used for the performance improvement in terms of the
       * latency.  If you want to suppress the suggestions for the UX improment,
       * you may want to use suppress_suggestion in the Context message.
       * </pre>
       *
       * <code>optional bool request_suggestion = 14 [default = true];</code>
       * @return Whether the requestSuggestion field is set.
       */
      @java.lang.Override
      public boolean hasRequestSuggestion() {
        return instance.hasRequestSuggestion();
      }
      /**
       * <pre>
       * A flag to control if the server should return suggest-results or not.
       * If this is set to false, regardless of other configurations,
       * the server won't return suggestion results.
       * This is set to true by default.
       * Note that even if this flag is set to false, when a suggestion is shown
       * in the previous phase, it is possible from the client to submit it.
       * This works only for suggestions for the key insertion, but not for
       * others commands, such as predictions or conversions.
       * This flag is used for the performance improvement in terms of the
       * latency.  If you want to suppress the suggestions for the UX improment,
       * you may want to use suppress_suggestion in the Context message.
       * </pre>
       *
       * <code>optional bool request_suggestion = 14 [default = true];</code>
       * @return The requestSuggestion.
       */
      @java.lang.Override
      public boolean getRequestSuggestion() {
        return instance.getRequestSuggestion();
      }
      /**
       * <pre>
       * A flag to control if the server should return suggest-results or not.
       * If this is set to false, regardless of other configurations,
       * the server won't return suggestion results.
       * This is set to true by default.
       * Note that even if this flag is set to false, when a suggestion is shown
       * in the previous phase, it is possible from the client to submit it.
       * This works only for suggestions for the key insertion, but not for
       * others commands, such as predictions or conversions.
       * This flag is used for the performance improvement in terms of the
       * latency.  If you want to suppress the suggestions for the UX improment,
       * you may want to use suppress_suggestion in the Context message.
       * </pre>
       *
       * <code>optional bool request_suggestion = 14 [default = true];</code>
       * @param value The requestSuggestion to set.
       * @return This builder for chaining.
       */
      public Builder setRequestSuggestion(boolean value) {
        copyOnWrite();
        instance.setRequestSuggestion(value);
        return this;
      }
      /**
       * <pre>
       * A flag to control if the server should return suggest-results or not.
       * If this is set to false, regardless of other configurations,
       * the server won't return suggestion results.
       * This is set to true by default.
       * Note that even if this flag is set to false, when a suggestion is shown
       * in the previous phase, it is possible from the client to submit it.
       * This works only for suggestions for the key insertion, but not for
       * others commands, such as predictions or conversions.
       * This flag is used for the performance improvement in terms of the
       * latency.  If you want to suppress the suggestions for the UX improment,
       * you may want to use suppress_suggestion in the Context message.
       * </pre>
       *
       * <code>optional bool request_suggestion = 14 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearRequestSuggestion() {
        copyOnWrite();
        instance.clearRequestSuggestion();
        return this;
      }

      /**
       * <code>optional .mozc.EngineReloadRequest engine_reload_request = 15;</code>
       */
      @java.lang.Override
      public boolean hasEngineReloadRequest() {
        return instance.hasEngineReloadRequest();
      }
      /**
       * <code>optional .mozc.EngineReloadRequest engine_reload_request = 15;</code>
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadRequest getEngineReloadRequest() {
        return instance.getEngineReloadRequest();
      }
      /**
       * <code>optional .mozc.EngineReloadRequest engine_reload_request = 15;</code>
       */
      public Builder setEngineReloadRequest(org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadRequest value) {
        copyOnWrite();
        instance.setEngineReloadRequest(value);
        return this;
        }
      /**
       * <code>optional .mozc.EngineReloadRequest engine_reload_request = 15;</code>
       */
      public Builder setEngineReloadRequest(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadRequest.Builder builderForValue) {
        copyOnWrite();
        instance.setEngineReloadRequest(builderForValue.build());
        return this;
      }
      /**
       * <code>optional .mozc.EngineReloadRequest engine_reload_request = 15;</code>
       */
      public Builder mergeEngineReloadRequest(org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadRequest value) {
        copyOnWrite();
        instance.mergeEngineReloadRequest(value);
        return this;
      }
      /**
       * <code>optional .mozc.EngineReloadRequest engine_reload_request = 15;</code>
       */
      public Builder clearEngineReloadRequest() {  copyOnWrite();
        instance.clearEngineReloadRequest();
        return this;
      }

      /**
       * <code>optional .mozc.commands.UserHistoryData user_history_data = 18;</code>
       */
      @java.lang.Override
      public boolean hasUserHistoryData() {
        return instance.hasUserHistoryData();
      }
      /**
       * <code>optional .mozc.commands.UserHistoryData user_history_data = 18;</code>
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.UserHistoryData getUserHistoryData() {
        return instance.getUserHistoryData();
      }
      /**
       * <code>optional .mozc.commands.UserHistoryData user_history_data = 18;</code>
       */
      public Builder setUserHistoryData(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.UserHistoryData value) {
        copyOnWrite();
        instance.setUserHistoryData(value);
        return this;
        }
      /**
       * <code>optional .mozc.commands.UserHistoryData user_history_data = 18;</code>
       */
      public Builder setUserHistoryData(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.UserHistoryData.Builder builderForValue) {
        copyOnWrite();
        instance.setUserHistoryData(builderForValue.build());
        return this;
      }
      /**
       * <code>optional .mozc.commands.UserHistoryData user_history_data = 18;</code>
       */
      public Builder mergeUserHistoryData(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.UserHistoryData value) {
        copyOnWrite();
        instance.mergeUserHistoryData(value);
        return this;
      }
      /**
       * <code>optional .mozc.commands.UserHistoryData user_history_data = 18;</code>
       */
      public Builder clearUserHistoryData() {  copyOnWrite();
        instance.clearUserHistoryData();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:mozc.commands.Input)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "type_",
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.CommandType.internalGetVerifier(),
              "id_",
              "key_",
              "command_",
              "config_",
              "context_",
              "capability_",
              "applicationInfo_",
              "request_",
              "touchEvents_",
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent.class,
              "requestSuggestion_",
              "engineReloadRequest_",
              "userDictionaryImportData_",
              "userHistoryData_",
            };
            java.lang.String info =
                "\u0001\u000e\u0000\u0001\u0001\u0012\u000e\u0000\u0001\u0003\u0001\u150c\u0000\u0002" +
                "\u1003\u0001\u0003\u1009\u0002\u0004\u1409\u0003\u0005\u1009\u0004\u0006\u1009\u0005" +
                "\u0007\u1009\u0006\b\u1009\u0007\t\u1009\b\f\u001b\u000e\u1007\n\u000f\u1409\u000b" +
                "\u0011\u1009\t\u0012\u1009\f";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input> parser = PARSER;
          if (parser == null) {
            synchronized (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:mozc.commands.Input)
    private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input DEFAULT_INSTANCE;
    static {
      Input defaultInstance = new Input();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Input.class, defaultInstance);
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Input> PARSER;

    public static com.google.protobuf.Parser<Input> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ResultTokenOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mozc.commands.ResultToken)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * `value` and `key` represents Segment.Candidate. If the candidante has
     * functional values, they are stored as a sepalate ResultToken.
     * e.g. A candidate of {value="今日は", content_value="今日"} results
     * two ResultToken of {value="今日"} and {value="は"}.
     * </pre>
     *
     * <code>optional string value = 1;</code>
     * @return Whether the value field is set.
     */
    boolean hasValue();
    /**
     * <pre>
     * `value` and `key` represents Segment.Candidate. If the candidante has
     * functional values, they are stored as a sepalate ResultToken.
     * e.g. A candidate of {value="今日は", content_value="今日"} results
     * two ResultToken of {value="今日"} and {value="は"}.
     * </pre>
     *
     * <code>optional string value = 1;</code>
     * @return The value.
     */
    java.lang.String getValue();
    /**
     * <pre>
     * `value` and `key` represents Segment.Candidate. If the candidante has
     * functional values, they are stored as a sepalate ResultToken.
     * e.g. A candidate of {value="今日は", content_value="今日"} results
     * two ResultToken of {value="今日"} and {value="は"}.
     * </pre>
     *
     * <code>optional string value = 1;</code>
     * @return The bytes for value.
     */
    com.google.protobuf.ByteString
        getValueBytes();

    /**
     * <code>optional string key = 2;</code>
     * @return Whether the key field is set.
     */
    boolean hasKey();
    /**
     * <code>optional string key = 2;</code>
     * @return The key.
     */
    java.lang.String getKey();
    /**
     * <code>optional string key = 2;</code>
     * @return The bytes for key.
     */
    com.google.protobuf.ByteString
        getKeyBytes();

    /**
     * <pre>
     * `lid` and `rid` are copied from Segment.Candidate. -1 is used as a unknown
     * POS. e.g. A candidate of {value="朝は", content_value="朝", lid=2, rid=3}
     * results two ResultToken of {value="朝", lid=2, rid=-1} and
     * {value="は", lid=-1, rid=3}.
     * </pre>
     *
     * <code>optional int32 lid = 3 [default = -1];</code>
     * @return Whether the lid field is set.
     */
    boolean hasLid();
    /**
     * <pre>
     * `lid` and `rid` are copied from Segment.Candidate. -1 is used as a unknown
     * POS. e.g. A candidate of {value="朝は", content_value="朝", lid=2, rid=3}
     * results two ResultToken of {value="朝", lid=2, rid=-1} and
     * {value="は", lid=-1, rid=3}.
     * </pre>
     *
     * <code>optional int32 lid = 3 [default = -1];</code>
     * @return The lid.
     */
    int getLid();

    /**
     * <code>optional int32 rid = 4 [default = -1];</code>
     * @return Whether the rid field is set.
     */
    boolean hasRid();
    /**
     * <code>optional int32 rid = 4 [default = -1];</code>
     * @return The rid.
     */
    int getRid();
  }
  /**
   * <pre>
   * Detailed information of Result.
   * </pre>
   *
   * Protobuf type {@code mozc.commands.ResultToken}
   */
  public  static final class ResultToken extends
      com.google.protobuf.GeneratedMessageLite<
          ResultToken, ResultToken.Builder> implements
      // @@protoc_insertion_point(message_implements:mozc.commands.ResultToken)
      ResultTokenOrBuilder {
    private ResultToken() {
      value_ = "";
      key_ = "";
      lid_ = -1;
      rid_ = -1;
    }
    private int bitField0_;
    public static final int VALUE_FIELD_NUMBER = 1;
    private java.lang.String value_;
    /**
     * <pre>
     * `value` and `key` represents Segment.Candidate. If the candidante has
     * functional values, they are stored as a sepalate ResultToken.
     * e.g. A candidate of {value="今日は", content_value="今日"} results
     * two ResultToken of {value="今日"} and {value="は"}.
     * </pre>
     *
     * <code>optional string value = 1;</code>
     * @return Whether the value field is set.
     */
    @java.lang.Override
    public boolean hasValue() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * `value` and `key` represents Segment.Candidate. If the candidante has
     * functional values, they are stored as a sepalate ResultToken.
     * e.g. A candidate of {value="今日は", content_value="今日"} results
     * two ResultToken of {value="今日"} and {value="は"}.
     * </pre>
     *
     * <code>optional string value = 1;</code>
     * @return The value.
     */
    @java.lang.Override
    public java.lang.String getValue() {
      return value_;
    }
    /**
     * <pre>
     * `value` and `key` represents Segment.Candidate. If the candidante has
     * functional values, they are stored as a sepalate ResultToken.
     * e.g. A candidate of {value="今日は", content_value="今日"} results
     * two ResultToken of {value="今日"} and {value="は"}.
     * </pre>
     *
     * <code>optional string value = 1;</code>
     * @return The bytes for value.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getValueBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(value_);
    }
    /**
     * <pre>
     * `value` and `key` represents Segment.Candidate. If the candidante has
     * functional values, they are stored as a sepalate ResultToken.
     * e.g. A candidate of {value="今日は", content_value="今日"} results
     * two ResultToken of {value="今日"} and {value="は"}.
     * </pre>
     *
     * <code>optional string value = 1;</code>
     * @param value The value to set.
     */
    private void setValue(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000001;
      value_ = value;
    }
    /**
     * <pre>
     * `value` and `key` represents Segment.Candidate. If the candidante has
     * functional values, they are stored as a sepalate ResultToken.
     * e.g. A candidate of {value="今日は", content_value="今日"} results
     * two ResultToken of {value="今日"} and {value="は"}.
     * </pre>
     *
     * <code>optional string value = 1;</code>
     */
    private void clearValue() {
      bitField0_ = (bitField0_ & ~0x00000001);
      value_ = getDefaultInstance().getValue();
    }
    /**
     * <pre>
     * `value` and `key` represents Segment.Candidate. If the candidante has
     * functional values, they are stored as a sepalate ResultToken.
     * e.g. A candidate of {value="今日は", content_value="今日"} results
     * two ResultToken of {value="今日"} and {value="は"}.
     * </pre>
     *
     * <code>optional string value = 1;</code>
     * @param value The bytes for value to set.
     */
    private void setValueBytes(
        com.google.protobuf.ByteString value) {
      value_ = value.toStringUtf8();
      bitField0_ |= 0x00000001;
    }

    public static final int KEY_FIELD_NUMBER = 2;
    private java.lang.String key_;
    /**
     * <code>optional string key = 2;</code>
     * @return Whether the key field is set.
     */
    @java.lang.Override
    public boolean hasKey() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional string key = 2;</code>
     * @return The key.
     */
    @java.lang.Override
    public java.lang.String getKey() {
      return key_;
    }
    /**
     * <code>optional string key = 2;</code>
     * @return The bytes for key.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getKeyBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(key_);
    }
    /**
     * <code>optional string key = 2;</code>
     * @param value The key to set.
     */
    private void setKey(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000002;
      key_ = value;
    }
    /**
     * <code>optional string key = 2;</code>
     */
    private void clearKey() {
      bitField0_ = (bitField0_ & ~0x00000002);
      key_ = getDefaultInstance().getKey();
    }
    /**
     * <code>optional string key = 2;</code>
     * @param value The bytes for key to set.
     */
    private void setKeyBytes(
        com.google.protobuf.ByteString value) {
      key_ = value.toStringUtf8();
      bitField0_ |= 0x00000002;
    }

    public static final int LID_FIELD_NUMBER = 3;
    private int lid_;
    /**
     * <pre>
     * `lid` and `rid` are copied from Segment.Candidate. -1 is used as a unknown
     * POS. e.g. A candidate of {value="朝は", content_value="朝", lid=2, rid=3}
     * results two ResultToken of {value="朝", lid=2, rid=-1} and
     * {value="は", lid=-1, rid=3}.
     * </pre>
     *
     * <code>optional int32 lid = 3 [default = -1];</code>
     * @return Whether the lid field is set.
     */
    @java.lang.Override
    public boolean hasLid() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * `lid` and `rid` are copied from Segment.Candidate. -1 is used as a unknown
     * POS. e.g. A candidate of {value="朝は", content_value="朝", lid=2, rid=3}
     * results two ResultToken of {value="朝", lid=2, rid=-1} and
     * {value="は", lid=-1, rid=3}.
     * </pre>
     *
     * <code>optional int32 lid = 3 [default = -1];</code>
     * @return The lid.
     */
    @java.lang.Override
    public int getLid() {
      return lid_;
    }
    /**
     * <pre>
     * `lid` and `rid` are copied from Segment.Candidate. -1 is used as a unknown
     * POS. e.g. A candidate of {value="朝は", content_value="朝", lid=2, rid=3}
     * results two ResultToken of {value="朝", lid=2, rid=-1} and
     * {value="は", lid=-1, rid=3}.
     * </pre>
     *
     * <code>optional int32 lid = 3 [default = -1];</code>
     * @param value The lid to set.
     */
    private void setLid(int value) {
      bitField0_ |= 0x00000004;
      lid_ = value;
    }
    /**
     * <pre>
     * `lid` and `rid` are copied from Segment.Candidate. -1 is used as a unknown
     * POS. e.g. A candidate of {value="朝は", content_value="朝", lid=2, rid=3}
     * results two ResultToken of {value="朝", lid=2, rid=-1} and
     * {value="は", lid=-1, rid=3}.
     * </pre>
     *
     * <code>optional int32 lid = 3 [default = -1];</code>
     */
    private void clearLid() {
      bitField0_ = (bitField0_ & ~0x00000004);
      lid_ = -1;
    }

    public static final int RID_FIELD_NUMBER = 4;
    private int rid_;
    /**
     * <code>optional int32 rid = 4 [default = -1];</code>
     * @return Whether the rid field is set.
     */
    @java.lang.Override
    public boolean hasRid() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <code>optional int32 rid = 4 [default = -1];</code>
     * @return The rid.
     */
    @java.lang.Override
    public int getRid() {
      return rid_;
    }
    /**
     * <code>optional int32 rid = 4 [default = -1];</code>
     * @param value The rid to set.
     */
    private void setRid(int value) {
      bitField0_ |= 0x00000008;
      rid_ = value;
    }
    /**
     * <code>optional int32 rid = 4 [default = -1];</code>
     */
    private void clearRid() {
      bitField0_ = (bitField0_ & ~0x00000008);
      rid_ = -1;
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Detailed information of Result.
     * </pre>
     *
     * Protobuf type {@code mozc.commands.ResultToken}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken, Builder> implements
        // @@protoc_insertion_point(builder_implements:mozc.commands.ResultToken)
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultTokenOrBuilder {
      // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * `value` and `key` represents Segment.Candidate. If the candidante has
       * functional values, they are stored as a sepalate ResultToken.
       * e.g. A candidate of {value="今日は", content_value="今日"} results
       * two ResultToken of {value="今日"} and {value="は"}.
       * </pre>
       *
       * <code>optional string value = 1;</code>
       * @return Whether the value field is set.
       */
      @java.lang.Override
      public boolean hasValue() {
        return instance.hasValue();
      }
      /**
       * <pre>
       * `value` and `key` represents Segment.Candidate. If the candidante has
       * functional values, they are stored as a sepalate ResultToken.
       * e.g. A candidate of {value="今日は", content_value="今日"} results
       * two ResultToken of {value="今日"} and {value="は"}.
       * </pre>
       *
       * <code>optional string value = 1;</code>
       * @return The value.
       */
      @java.lang.Override
      public java.lang.String getValue() {
        return instance.getValue();
      }
      /**
       * <pre>
       * `value` and `key` represents Segment.Candidate. If the candidante has
       * functional values, they are stored as a sepalate ResultToken.
       * e.g. A candidate of {value="今日は", content_value="今日"} results
       * two ResultToken of {value="今日"} and {value="は"}.
       * </pre>
       *
       * <code>optional string value = 1;</code>
       * @return The bytes for value.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getValueBytes() {
        return instance.getValueBytes();
      }
      /**
       * <pre>
       * `value` and `key` represents Segment.Candidate. If the candidante has
       * functional values, they are stored as a sepalate ResultToken.
       * e.g. A candidate of {value="今日は", content_value="今日"} results
       * two ResultToken of {value="今日"} and {value="は"}.
       * </pre>
       *
       * <code>optional string value = 1;</code>
       * @param value The value to set.
       * @return This builder for chaining.
       */
      public Builder setValue(
          java.lang.String value) {
        copyOnWrite();
        instance.setValue(value);
        return this;
      }
      /**
       * <pre>
       * `value` and `key` represents Segment.Candidate. If the candidante has
       * functional values, they are stored as a sepalate ResultToken.
       * e.g. A candidate of {value="今日は", content_value="今日"} results
       * two ResultToken of {value="今日"} and {value="は"}.
       * </pre>
       *
       * <code>optional string value = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearValue() {
        copyOnWrite();
        instance.clearValue();
        return this;
      }
      /**
       * <pre>
       * `value` and `key` represents Segment.Candidate. If the candidante has
       * functional values, they are stored as a sepalate ResultToken.
       * e.g. A candidate of {value="今日は", content_value="今日"} results
       * two ResultToken of {value="今日"} and {value="は"}.
       * </pre>
       *
       * <code>optional string value = 1;</code>
       * @param value The bytes for value to set.
       * @return This builder for chaining.
       */
      public Builder setValueBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setValueBytes(value);
        return this;
      }

      /**
       * <code>optional string key = 2;</code>
       * @return Whether the key field is set.
       */
      @java.lang.Override
      public boolean hasKey() {
        return instance.hasKey();
      }
      /**
       * <code>optional string key = 2;</code>
       * @return The key.
       */
      @java.lang.Override
      public java.lang.String getKey() {
        return instance.getKey();
      }
      /**
       * <code>optional string key = 2;</code>
       * @return The bytes for key.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getKeyBytes() {
        return instance.getKeyBytes();
      }
      /**
       * <code>optional string key = 2;</code>
       * @param value The key to set.
       * @return This builder for chaining.
       */
      public Builder setKey(
          java.lang.String value) {
        copyOnWrite();
        instance.setKey(value);
        return this;
      }
      /**
       * <code>optional string key = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearKey() {
        copyOnWrite();
        instance.clearKey();
        return this;
      }
      /**
       * <code>optional string key = 2;</code>
       * @param value The bytes for key to set.
       * @return This builder for chaining.
       */
      public Builder setKeyBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setKeyBytes(value);
        return this;
      }

      /**
       * <pre>
       * `lid` and `rid` are copied from Segment.Candidate. -1 is used as a unknown
       * POS. e.g. A candidate of {value="朝は", content_value="朝", lid=2, rid=3}
       * results two ResultToken of {value="朝", lid=2, rid=-1} and
       * {value="は", lid=-1, rid=3}.
       * </pre>
       *
       * <code>optional int32 lid = 3 [default = -1];</code>
       * @return Whether the lid field is set.
       */
      @java.lang.Override
      public boolean hasLid() {
        return instance.hasLid();
      }
      /**
       * <pre>
       * `lid` and `rid` are copied from Segment.Candidate. -1 is used as a unknown
       * POS. e.g. A candidate of {value="朝は", content_value="朝", lid=2, rid=3}
       * results two ResultToken of {value="朝", lid=2, rid=-1} and
       * {value="は", lid=-1, rid=3}.
       * </pre>
       *
       * <code>optional int32 lid = 3 [default = -1];</code>
       * @return The lid.
       */
      @java.lang.Override
      public int getLid() {
        return instance.getLid();
      }
      /**
       * <pre>
       * `lid` and `rid` are copied from Segment.Candidate. -1 is used as a unknown
       * POS. e.g. A candidate of {value="朝は", content_value="朝", lid=2, rid=3}
       * results two ResultToken of {value="朝", lid=2, rid=-1} and
       * {value="は", lid=-1, rid=3}.
       * </pre>
       *
       * <code>optional int32 lid = 3 [default = -1];</code>
       * @param value The lid to set.
       * @return This builder for chaining.
       */
      public Builder setLid(int value) {
        copyOnWrite();
        instance.setLid(value);
        return this;
      }
      /**
       * <pre>
       * `lid` and `rid` are copied from Segment.Candidate. -1 is used as a unknown
       * POS. e.g. A candidate of {value="朝は", content_value="朝", lid=2, rid=3}
       * results two ResultToken of {value="朝", lid=2, rid=-1} and
       * {value="は", lid=-1, rid=3}.
       * </pre>
       *
       * <code>optional int32 lid = 3 [default = -1];</code>
       * @return This builder for chaining.
       */
      public Builder clearLid() {
        copyOnWrite();
        instance.clearLid();
        return this;
      }

      /**
       * <code>optional int32 rid = 4 [default = -1];</code>
       * @return Whether the rid field is set.
       */
      @java.lang.Override
      public boolean hasRid() {
        return instance.hasRid();
      }
      /**
       * <code>optional int32 rid = 4 [default = -1];</code>
       * @return The rid.
       */
      @java.lang.Override
      public int getRid() {
        return instance.getRid();
      }
      /**
       * <code>optional int32 rid = 4 [default = -1];</code>
       * @param value The rid to set.
       * @return This builder for chaining.
       */
      public Builder setRid(int value) {
        copyOnWrite();
        instance.setRid(value);
        return this;
      }
      /**
       * <code>optional int32 rid = 4 [default = -1];</code>
       * @return This builder for chaining.
       */
      public Builder clearRid() {
        copyOnWrite();
        instance.clearRid();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:mozc.commands.ResultToken)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "value_",
              "key_",
              "lid_",
              "rid_",
            };
            java.lang.String info =
                "\u0001\u0004\u0000\u0001\u0001\u0004\u0004\u0000\u0000\u0000\u0001\u1008\u0000\u0002" +
                "\u1008\u0001\u0003\u1004\u0002\u0004\u1004\u0003";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken> parser = PARSER;
          if (parser == null) {
            synchronized (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:mozc.commands.ResultToken)
    private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken DEFAULT_INSTANCE;
    static {
      ResultToken defaultInstance = new ResultToken();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ResultToken.class, defaultInstance);
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ResultToken> PARSER;

    public static com.google.protobuf.Parser<ResultToken> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ResultOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mozc.commands.Result)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>required .mozc.commands.Result.ResultType type = 1;</code>
     * @return Whether the type field is set.
     */
    boolean hasType();
    /**
     * <code>required .mozc.commands.Result.ResultType type = 1;</code>
     * @return The type.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.ResultType getType();

    /**
     * <pre>
     * The result of conversion.
     * </pre>
     *
     * <code>required string value = 2;</code>
     * @return Whether the value field is set.
     */
    boolean hasValue();
    /**
     * <pre>
     * The result of conversion.
     * </pre>
     *
     * <code>required string value = 2;</code>
     * @return The value.
     */
    java.lang.String getValue();
    /**
     * <pre>
     * The result of conversion.
     * </pre>
     *
     * <code>required string value = 2;</code>
     * @return The bytes for value.
     */
    com.google.protobuf.ByteString
        getValueBytes();

    /**
     * <pre>
     * Source of the value.  It is almost always the reading of the value.
     * </pre>
     *
     * <code>optional string key = 3;</code>
     * @return Whether the key field is set.
     */
    boolean hasKey();
    /**
     * <pre>
     * Source of the value.  It is almost always the reading of the value.
     * </pre>
     *
     * <code>optional string key = 3;</code>
     * @return The key.
     */
    java.lang.String getKey();
    /**
     * <pre>
     * Source of the value.  It is almost always the reading of the value.
     * </pre>
     *
     * <code>optional string key = 3;</code>
     * @return The bytes for key.
     */
    com.google.protobuf.ByteString
        getKeyBytes();

    /**
     * <pre>
     * The caret position after the result submission.
     * "0" means the end of the result, and a positive value means moving forward
     * and a negative value backward.
     * e.g.) "-s", where s is the length of value, means the caret position
     * after the committing should be the beginning of the committed value.
     * </pre>
     *
     * <code>optional int32 cursor_offset = 4 [default = 0];</code>
     * @return Whether the cursorOffset field is set.
     */
    boolean hasCursorOffset();
    /**
     * <pre>
     * The caret position after the result submission.
     * "0" means the end of the result, and a positive value means moving forward
     * and a negative value backward.
     * e.g.) "-s", where s is the length of value, means the caret position
     * after the committing should be the beginning of the committed value.
     * </pre>
     *
     * <code>optional int32 cursor_offset = 4 [default = 0];</code>
     * @return The cursorOffset.
     */
    int getCursorOffset();

    /**
     * <pre>
     * Additional information propagated from the internal status.
     * </pre>
     *
     * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
     */
    java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken> 
        getTokensList();
    /**
     * <pre>
     * Additional information propagated from the internal status.
     * </pre>
     *
     * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken getTokens(int index);
    /**
     * <pre>
     * Additional information propagated from the internal status.
     * </pre>
     *
     * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
     */
    int getTokensCount();
  }
  /**
   * <pre>
   * Result contains data to be submitted to the host application by the
   * ime client.
   * </pre>
   *
   * Protobuf type {@code mozc.commands.Result}
   */
  public  static final class Result extends
      com.google.protobuf.GeneratedMessageLite<
          Result, Result.Builder> implements
      // @@protoc_insertion_point(message_implements:mozc.commands.Result)
      ResultOrBuilder {
    private Result() {
      value_ = "";
      key_ = "";
      tokens_ = emptyProtobufList();
    }
    /**
     * Protobuf enum {@code mozc.commands.Result.ResultType}
     */
    public enum ResultType
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>NONE = 0;</code>
       */
      NONE(0),
      /**
       * <code>STRING = 1;</code>
       */
      STRING(1),
      ;

      /**
       * <code>NONE = 0;</code>
       */
      public static final int NONE_VALUE = 0;
      /**
       * <code>STRING = 1;</code>
       */
      public static final int STRING_VALUE = 1;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static ResultType valueOf(int value) {
        return forNumber(value);
      }

      public static ResultType forNumber(int value) {
        switch (value) {
          case 0: return NONE;
          case 1: return STRING;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<ResultType>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          ResultType> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<ResultType>() {
              @java.lang.Override
              public ResultType findValueByNumber(int number) {
                return ResultType.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return ResultTypeVerifier.INSTANCE;
      }

      private static final class ResultTypeVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new ResultTypeVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return ResultType.forNumber(number) != null;
              }
            };

      private final int value;

      private ResultType(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.commands.Result.ResultType)
    }

    private int bitField0_;
    public static final int TYPE_FIELD_NUMBER = 1;
    private int type_;
    /**
     * <code>required .mozc.commands.Result.ResultType type = 1;</code>
     * @return Whether the type field is set.
     */
    @java.lang.Override
    public boolean hasType() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>required .mozc.commands.Result.ResultType type = 1;</code>
     * @return The type.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.ResultType getType() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.ResultType result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.ResultType.forNumber(type_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.ResultType.NONE : result;
    }
    /**
     * <code>required .mozc.commands.Result.ResultType type = 1;</code>
     * @param value The type to set.
     */
    private void setType(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.ResultType value) {
      type_ = value.getNumber();
      bitField0_ |= 0x00000001;
    }
    /**
     * <code>required .mozc.commands.Result.ResultType type = 1;</code>
     */
    private void clearType() {
      bitField0_ = (bitField0_ & ~0x00000001);
      type_ = 0;
    }

    public static final int VALUE_FIELD_NUMBER = 2;
    private java.lang.String value_;
    /**
     * <pre>
     * The result of conversion.
     * </pre>
     *
     * <code>required string value = 2;</code>
     * @return Whether the value field is set.
     */
    @java.lang.Override
    public boolean hasValue() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * The result of conversion.
     * </pre>
     *
     * <code>required string value = 2;</code>
     * @return The value.
     */
    @java.lang.Override
    public java.lang.String getValue() {
      return value_;
    }
    /**
     * <pre>
     * The result of conversion.
     * </pre>
     *
     * <code>required string value = 2;</code>
     * @return The bytes for value.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getValueBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(value_);
    }
    /**
     * <pre>
     * The result of conversion.
     * </pre>
     *
     * <code>required string value = 2;</code>
     * @param value The value to set.
     */
    private void setValue(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000002;
      value_ = value;
    }
    /**
     * <pre>
     * The result of conversion.
     * </pre>
     *
     * <code>required string value = 2;</code>
     */
    private void clearValue() {
      bitField0_ = (bitField0_ & ~0x00000002);
      value_ = getDefaultInstance().getValue();
    }
    /**
     * <pre>
     * The result of conversion.
     * </pre>
     *
     * <code>required string value = 2;</code>
     * @param value The bytes for value to set.
     */
    private void setValueBytes(
        com.google.protobuf.ByteString value) {
      value_ = value.toStringUtf8();
      bitField0_ |= 0x00000002;
    }

    public static final int KEY_FIELD_NUMBER = 3;
    private java.lang.String key_;
    /**
     * <pre>
     * Source of the value.  It is almost always the reading of the value.
     * </pre>
     *
     * <code>optional string key = 3;</code>
     * @return Whether the key field is set.
     */
    @java.lang.Override
    public boolean hasKey() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Source of the value.  It is almost always the reading of the value.
     * </pre>
     *
     * <code>optional string key = 3;</code>
     * @return The key.
     */
    @java.lang.Override
    public java.lang.String getKey() {
      return key_;
    }
    /**
     * <pre>
     * Source of the value.  It is almost always the reading of the value.
     * </pre>
     *
     * <code>optional string key = 3;</code>
     * @return The bytes for key.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getKeyBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(key_);
    }
    /**
     * <pre>
     * Source of the value.  It is almost always the reading of the value.
     * </pre>
     *
     * <code>optional string key = 3;</code>
     * @param value The key to set.
     */
    private void setKey(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000004;
      key_ = value;
    }
    /**
     * <pre>
     * Source of the value.  It is almost always the reading of the value.
     * </pre>
     *
     * <code>optional string key = 3;</code>
     */
    private void clearKey() {
      bitField0_ = (bitField0_ & ~0x00000004);
      key_ = getDefaultInstance().getKey();
    }
    /**
     * <pre>
     * Source of the value.  It is almost always the reading of the value.
     * </pre>
     *
     * <code>optional string key = 3;</code>
     * @param value The bytes for key to set.
     */
    private void setKeyBytes(
        com.google.protobuf.ByteString value) {
      key_ = value.toStringUtf8();
      bitField0_ |= 0x00000004;
    }

    public static final int CURSOR_OFFSET_FIELD_NUMBER = 4;
    private int cursorOffset_;
    /**
     * <pre>
     * The caret position after the result submission.
     * "0" means the end of the result, and a positive value means moving forward
     * and a negative value backward.
     * e.g.) "-s", where s is the length of value, means the caret position
     * after the committing should be the beginning of the committed value.
     * </pre>
     *
     * <code>optional int32 cursor_offset = 4 [default = 0];</code>
     * @return Whether the cursorOffset field is set.
     */
    @java.lang.Override
    public boolean hasCursorOffset() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * The caret position after the result submission.
     * "0" means the end of the result, and a positive value means moving forward
     * and a negative value backward.
     * e.g.) "-s", where s is the length of value, means the caret position
     * after the committing should be the beginning of the committed value.
     * </pre>
     *
     * <code>optional int32 cursor_offset = 4 [default = 0];</code>
     * @return The cursorOffset.
     */
    @java.lang.Override
    public int getCursorOffset() {
      return cursorOffset_;
    }
    /**
     * <pre>
     * The caret position after the result submission.
     * "0" means the end of the result, and a positive value means moving forward
     * and a negative value backward.
     * e.g.) "-s", where s is the length of value, means the caret position
     * after the committing should be the beginning of the committed value.
     * </pre>
     *
     * <code>optional int32 cursor_offset = 4 [default = 0];</code>
     * @param value The cursorOffset to set.
     */
    private void setCursorOffset(int value) {
      bitField0_ |= 0x00000008;
      cursorOffset_ = value;
    }
    /**
     * <pre>
     * The caret position after the result submission.
     * "0" means the end of the result, and a positive value means moving forward
     * and a negative value backward.
     * e.g.) "-s", where s is the length of value, means the caret position
     * after the committing should be the beginning of the committed value.
     * </pre>
     *
     * <code>optional int32 cursor_offset = 4 [default = 0];</code>
     */
    private void clearCursorOffset() {
      bitField0_ = (bitField0_ & ~0x00000008);
      cursorOffset_ = 0;
    }

    public static final int TOKENS_FIELD_NUMBER = 5;
    private com.google.protobuf.Internal.ProtobufList<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken> tokens_;
    /**
     * <pre>
     * Additional information propagated from the internal status.
     * </pre>
     *
     * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
     */
    @java.lang.Override
    public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken> getTokensList() {
      return tokens_;
    }
    /**
     * <pre>
     * Additional information propagated from the internal status.
     * </pre>
     *
     * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
     */
    public java.util.List<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultTokenOrBuilder> 
        getTokensOrBuilderList() {
      return tokens_;
    }
    /**
     * <pre>
     * Additional information propagated from the internal status.
     * </pre>
     *
     * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
     */
    @java.lang.Override
    public int getTokensCount() {
      return tokens_.size();
    }
    /**
     * <pre>
     * Additional information propagated from the internal status.
     * </pre>
     *
     * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken getTokens(int index) {
      return tokens_.get(index);
    }
    /**
     * <pre>
     * Additional information propagated from the internal status.
     * </pre>
     *
     * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
     */
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultTokenOrBuilder getTokensOrBuilder(
        int index) {
      return tokens_.get(index);
    }
    private void ensureTokensIsMutable() {
      com.google.protobuf.Internal.ProtobufList<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken> tmp = tokens_;
      if (!tmp.isModifiable()) {
        tokens_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * Additional information propagated from the internal status.
     * </pre>
     *
     * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
     */
    private void setTokens(
        int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken value) {
      value.getClass();
  ensureTokensIsMutable();
      tokens_.set(index, value);
    }
    /**
     * <pre>
     * Additional information propagated from the internal status.
     * </pre>
     *
     * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
     */
    private void addTokens(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken value) {
      value.getClass();
  ensureTokensIsMutable();
      tokens_.add(value);
    }
    /**
     * <pre>
     * Additional information propagated from the internal status.
     * </pre>
     *
     * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
     */
    private void addTokens(
        int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken value) {
      value.getClass();
  ensureTokensIsMutable();
      tokens_.add(index, value);
    }
    /**
     * <pre>
     * Additional information propagated from the internal status.
     * </pre>
     *
     * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
     */
    private void addAllTokens(
        java.lang.Iterable<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken> values) {
      ensureTokensIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, tokens_);
    }
    /**
     * <pre>
     * Additional information propagated from the internal status.
     * </pre>
     *
     * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
     */
    private void clearTokens() {
      tokens_ = emptyProtobufList();
    }
    /**
     * <pre>
     * Additional information propagated from the internal status.
     * </pre>
     *
     * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
     */
    private void removeTokens(int index) {
      ensureTokensIsMutable();
      tokens_.remove(index);
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Result contains data to be submitted to the host application by the
     * ime client.
     * </pre>
     *
     * Protobuf type {@code mozc.commands.Result}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result, Builder> implements
        // @@protoc_insertion_point(builder_implements:mozc.commands.Result)
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultOrBuilder {
      // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>required .mozc.commands.Result.ResultType type = 1;</code>
       * @return Whether the type field is set.
       */
      @java.lang.Override
      public boolean hasType() {
        return instance.hasType();
      }
      /**
       * <code>required .mozc.commands.Result.ResultType type = 1;</code>
       * @return The type.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.ResultType getType() {
        return instance.getType();
      }
      /**
       * <code>required .mozc.commands.Result.ResultType type = 1;</code>
       * @param value The enum numeric value on the wire for type to set.
       * @return This builder for chaining.
       */
      public Builder setType(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.ResultType value) {
        copyOnWrite();
        instance.setType(value);
        return this;
      }
      /**
       * <code>required .mozc.commands.Result.ResultType type = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearType() {
        copyOnWrite();
        instance.clearType();
        return this;
      }

      /**
       * <pre>
       * The result of conversion.
       * </pre>
       *
       * <code>required string value = 2;</code>
       * @return Whether the value field is set.
       */
      @java.lang.Override
      public boolean hasValue() {
        return instance.hasValue();
      }
      /**
       * <pre>
       * The result of conversion.
       * </pre>
       *
       * <code>required string value = 2;</code>
       * @return The value.
       */
      @java.lang.Override
      public java.lang.String getValue() {
        return instance.getValue();
      }
      /**
       * <pre>
       * The result of conversion.
       * </pre>
       *
       * <code>required string value = 2;</code>
       * @return The bytes for value.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getValueBytes() {
        return instance.getValueBytes();
      }
      /**
       * <pre>
       * The result of conversion.
       * </pre>
       *
       * <code>required string value = 2;</code>
       * @param value The value to set.
       * @return This builder for chaining.
       */
      public Builder setValue(
          java.lang.String value) {
        copyOnWrite();
        instance.setValue(value);
        return this;
      }
      /**
       * <pre>
       * The result of conversion.
       * </pre>
       *
       * <code>required string value = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearValue() {
        copyOnWrite();
        instance.clearValue();
        return this;
      }
      /**
       * <pre>
       * The result of conversion.
       * </pre>
       *
       * <code>required string value = 2;</code>
       * @param value The bytes for value to set.
       * @return This builder for chaining.
       */
      public Builder setValueBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setValueBytes(value);
        return this;
      }

      /**
       * <pre>
       * Source of the value.  It is almost always the reading of the value.
       * </pre>
       *
       * <code>optional string key = 3;</code>
       * @return Whether the key field is set.
       */
      @java.lang.Override
      public boolean hasKey() {
        return instance.hasKey();
      }
      /**
       * <pre>
       * Source of the value.  It is almost always the reading of the value.
       * </pre>
       *
       * <code>optional string key = 3;</code>
       * @return The key.
       */
      @java.lang.Override
      public java.lang.String getKey() {
        return instance.getKey();
      }
      /**
       * <pre>
       * Source of the value.  It is almost always the reading of the value.
       * </pre>
       *
       * <code>optional string key = 3;</code>
       * @return The bytes for key.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getKeyBytes() {
        return instance.getKeyBytes();
      }
      /**
       * <pre>
       * Source of the value.  It is almost always the reading of the value.
       * </pre>
       *
       * <code>optional string key = 3;</code>
       * @param value The key to set.
       * @return This builder for chaining.
       */
      public Builder setKey(
          java.lang.String value) {
        copyOnWrite();
        instance.setKey(value);
        return this;
      }
      /**
       * <pre>
       * Source of the value.  It is almost always the reading of the value.
       * </pre>
       *
       * <code>optional string key = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearKey() {
        copyOnWrite();
        instance.clearKey();
        return this;
      }
      /**
       * <pre>
       * Source of the value.  It is almost always the reading of the value.
       * </pre>
       *
       * <code>optional string key = 3;</code>
       * @param value The bytes for key to set.
       * @return This builder for chaining.
       */
      public Builder setKeyBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setKeyBytes(value);
        return this;
      }

      /**
       * <pre>
       * The caret position after the result submission.
       * "0" means the end of the result, and a positive value means moving forward
       * and a negative value backward.
       * e.g.) "-s", where s is the length of value, means the caret position
       * after the committing should be the beginning of the committed value.
       * </pre>
       *
       * <code>optional int32 cursor_offset = 4 [default = 0];</code>
       * @return Whether the cursorOffset field is set.
       */
      @java.lang.Override
      public boolean hasCursorOffset() {
        return instance.hasCursorOffset();
      }
      /**
       * <pre>
       * The caret position after the result submission.
       * "0" means the end of the result, and a positive value means moving forward
       * and a negative value backward.
       * e.g.) "-s", where s is the length of value, means the caret position
       * after the committing should be the beginning of the committed value.
       * </pre>
       *
       * <code>optional int32 cursor_offset = 4 [default = 0];</code>
       * @return The cursorOffset.
       */
      @java.lang.Override
      public int getCursorOffset() {
        return instance.getCursorOffset();
      }
      /**
       * <pre>
       * The caret position after the result submission.
       * "0" means the end of the result, and a positive value means moving forward
       * and a negative value backward.
       * e.g.) "-s", where s is the length of value, means the caret position
       * after the committing should be the beginning of the committed value.
       * </pre>
       *
       * <code>optional int32 cursor_offset = 4 [default = 0];</code>
       * @param value The cursorOffset to set.
       * @return This builder for chaining.
       */
      public Builder setCursorOffset(int value) {
        copyOnWrite();
        instance.setCursorOffset(value);
        return this;
      }
      /**
       * <pre>
       * The caret position after the result submission.
       * "0" means the end of the result, and a positive value means moving forward
       * and a negative value backward.
       * e.g.) "-s", where s is the length of value, means the caret position
       * after the committing should be the beginning of the committed value.
       * </pre>
       *
       * <code>optional int32 cursor_offset = 4 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearCursorOffset() {
        copyOnWrite();
        instance.clearCursorOffset();
        return this;
      }

      /**
       * <pre>
       * Additional information propagated from the internal status.
       * </pre>
       *
       * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
       */
      @java.lang.Override
      public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken> getTokensList() {
        return java.util.Collections.unmodifiableList(
            instance.getTokensList());
      }
      /**
       * <pre>
       * Additional information propagated from the internal status.
       * </pre>
       *
       * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
       */
      @java.lang.Override
      public int getTokensCount() {
        return instance.getTokensCount();
      }/**
       * <pre>
       * Additional information propagated from the internal status.
       * </pre>
       *
       * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken getTokens(int index) {
        return instance.getTokens(index);
      }
      /**
       * <pre>
       * Additional information propagated from the internal status.
       * </pre>
       *
       * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
       */
      public Builder setTokens(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken value) {
        copyOnWrite();
        instance.setTokens(index, value);
        return this;
      }
      /**
       * <pre>
       * Additional information propagated from the internal status.
       * </pre>
       *
       * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
       */
      public Builder setTokens(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken.Builder builderForValue) {
        copyOnWrite();
        instance.setTokens(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Additional information propagated from the internal status.
       * </pre>
       *
       * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
       */
      public Builder addTokens(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken value) {
        copyOnWrite();
        instance.addTokens(value);
        return this;
      }
      /**
       * <pre>
       * Additional information propagated from the internal status.
       * </pre>
       *
       * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
       */
      public Builder addTokens(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken value) {
        copyOnWrite();
        instance.addTokens(index, value);
        return this;
      }
      /**
       * <pre>
       * Additional information propagated from the internal status.
       * </pre>
       *
       * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
       */
      public Builder addTokens(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken.Builder builderForValue) {
        copyOnWrite();
        instance.addTokens(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Additional information propagated from the internal status.
       * </pre>
       *
       * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
       */
      public Builder addTokens(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken.Builder builderForValue) {
        copyOnWrite();
        instance.addTokens(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Additional information propagated from the internal status.
       * </pre>
       *
       * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
       */
      public Builder addAllTokens(
          java.lang.Iterable<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken> values) {
        copyOnWrite();
        instance.addAllTokens(values);
        return this;
      }
      /**
       * <pre>
       * Additional information propagated from the internal status.
       * </pre>
       *
       * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
       */
      public Builder clearTokens() {
        copyOnWrite();
        instance.clearTokens();
        return this;
      }
      /**
       * <pre>
       * Additional information propagated from the internal status.
       * </pre>
       *
       * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
       */
      public Builder removeTokens(int index) {
        copyOnWrite();
        instance.removeTokens(index);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:mozc.commands.Result)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "type_",
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.ResultType.internalGetVerifier(),
              "value_",
              "key_",
              "cursorOffset_",
              "tokens_",
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken.class,
            };
            java.lang.String info =
                "\u0001\u0005\u0000\u0001\u0001\u0005\u0005\u0000\u0001\u0002\u0001\u150c\u0000\u0002" +
                "\u1508\u0001\u0003\u1008\u0002\u0004\u1004\u0003\u0005\u001b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result> parser = PARSER;
          if (parser == null) {
            synchronized (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:mozc.commands.Result)
    private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result DEFAULT_INSTANCE;
    static {
      Result defaultInstance = new Result();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Result.class, defaultInstance);
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Result> PARSER;

    public static com.google.protobuf.Parser<Result> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface PreeditOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mozc.commands.Preedit)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>required uint32 cursor = 1;</code>
     * @return Whether the cursor field is set.
     */
    boolean hasCursor();
    /**
     * <code>required uint32 cursor = 1;</code>
     * @return The cursor.
     */
    int getCursor();

    /**
     * <code>repeated group Segment = 2 { ... }</code>
     */
    java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment> 
        getSegmentList();
    /**
     * <code>repeated group Segment = 2 { ... }</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment getSegment(int index);
    /**
     * <code>repeated group Segment = 2 { ... }</code>
     */
    int getSegmentCount();

    /**
     * <pre>
     * The position of the first segment whose annotation is 'HIGHLIGHT'. Not set
     * if there are no such segments.
     * </pre>
     *
     * <code>optional uint32 highlighted_position = 3;</code>
     * @return Whether the highlightedPosition field is set.
     */
    boolean hasHighlightedPosition();
    /**
     * <pre>
     * The position of the first segment whose annotation is 'HIGHLIGHT'. Not set
     * if there are no such segments.
     * </pre>
     *
     * <code>optional uint32 highlighted_position = 3;</code>
     * @return The highlightedPosition.
     */
    int getHighlightedPosition();

    /**
     * <pre>
     * This flag is set to true if the character at the cursor position
     * is in toggleable state.  For example, when the table is
     * TOGGLE_FLICK_TO_HIRAGANA and key event '1' is received
     * repeatedly, the preedit toggles like あ -&gt; い -&gt; う -&gt; ....  This
     * flag is true during this cycle.  This state is reset when user
     * types another key or SessionCommand::STOP_KEY_TOGGLING is
     * received.
     * </pre>
     *
     * <code>optional bool is_toggleable = 4 [default = false];</code>
     * @return Whether the isToggleable field is set.
     */
    boolean hasIsToggleable();
    /**
     * <pre>
     * This flag is set to true if the character at the cursor position
     * is in toggleable state.  For example, when the table is
     * TOGGLE_FLICK_TO_HIRAGANA and key event '1' is received
     * repeatedly, the preedit toggles like あ -&gt; い -&gt; う -&gt; ....  This
     * flag is true during this cycle.  This state is reset when user
     * types another key or SessionCommand::STOP_KEY_TOGGLING is
     * received.
     * </pre>
     *
     * <code>optional bool is_toggleable = 4 [default = false];</code>
     * @return The isToggleable.
     */
    boolean getIsToggleable();
  }
  /**
   * <pre>
   * Preedit represents a composition data, which is rendered on the
   * host application by the ime client.  On Japanese IME, the both
   * Preedit and Conversion statuses are represented by this message.
   * </pre>
   *
   * Protobuf type {@code mozc.commands.Preedit}
   */
  public  static final class Preedit extends
      com.google.protobuf.GeneratedMessageLite<
          Preedit, Preedit.Builder> implements
      // @@protoc_insertion_point(message_implements:mozc.commands.Preedit)
      PreeditOrBuilder {
    private Preedit() {
      segment_ = emptyProtobufList();
    }
    public interface SegmentOrBuilder extends
        // @@protoc_insertion_point(interface_extends:mozc.commands.Preedit.Segment)
        com.google.protobuf.MessageLiteOrBuilder {

      /**
       * <code>required .mozc.commands.Preedit.Segment.Annotation annotation = 3;</code>
       * @return Whether the annotation field is set.
       */
      boolean hasAnnotation();
      /**
       * <code>required .mozc.commands.Preedit.Segment.Annotation annotation = 3;</code>
       * @return The annotation.
       */
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.Annotation getAnnotation();

      /**
       * <code>required string value = 4;</code>
       * @return Whether the value field is set.
       */
      boolean hasValue();
      /**
       * <code>required string value = 4;</code>
       * @return The value.
       */
      java.lang.String getValue();
      /**
       * <code>required string value = 4;</code>
       * @return The bytes for value.
       */
      com.google.protobuf.ByteString
          getValueBytes();

      /**
       * <pre>
       * The length of value in characters.  This is NOT a number in
       * bytes or logical character units.  So, the length of "abc" and
       * "あいう" should be 3, "ヴ" should be 1 and "ｳﾞ" and "う゛"
       * should be 2.
       * </pre>
       *
       * <code>required uint32 value_length = 5;</code>
       * @return Whether the valueLength field is set.
       */
      boolean hasValueLength();
      /**
       * <pre>
       * The length of value in characters.  This is NOT a number in
       * bytes or logical character units.  So, the length of "abc" and
       * "あいう" should be 3, "ヴ" should be 1 and "ｳﾞ" and "う゛"
       * should be 2.
       * </pre>
       *
       * <code>required uint32 value_length = 5;</code>
       * @return The valueLength.
       */
      int getValueLength();

      /**
       * <pre>
       * Source of the value.  It is almost always the reading of the value.
       * </pre>
       *
       * <code>optional string key = 6;</code>
       * @return Whether the key field is set.
       */
      boolean hasKey();
      /**
       * <pre>
       * Source of the value.  It is almost always the reading of the value.
       * </pre>
       *
       * <code>optional string key = 6;</code>
       * @return The key.
       */
      java.lang.String getKey();
      /**
       * <pre>
       * Source of the value.  It is almost always the reading of the value.
       * </pre>
       *
       * <code>optional string key = 6;</code>
       * @return The bytes for key.
       */
      com.google.protobuf.ByteString
          getKeyBytes();
    }
    /**
     * <pre>
     * The string data of Preedit is separated into Segment messages
     * presenting the ime server's status.  On Preedit status of
     * Japanese IME, there are up to three segments; left side chars of
     * cursor, forcused char, right side chars of cursor.  On Conversion
     * status of Japanese IME, the messages literally represent the
     * segments of the conversion.
     * </pre>
     *
     * Protobuf type {@code mozc.commands.Preedit.Segment}
     */
    public  static final class Segment extends
        com.google.protobuf.GeneratedMessageLite<
            Segment, Segment.Builder> implements
        // @@protoc_insertion_point(message_implements:mozc.commands.Preedit.Segment)
        SegmentOrBuilder {
      private Segment() {
        value_ = "";
        key_ = "";
      }
      /**
       * Protobuf enum {@code mozc.commands.Preedit.Segment.Annotation}
       */
      public enum Annotation
          implements com.google.protobuf.Internal.EnumLite {
        /**
         * <code>NONE = 0;</code>
         */
        NONE(0),
        /**
         * <code>UNDERLINE = 1;</code>
         */
        UNDERLINE(1),
        /**
         * <code>HIGHLIGHT = 2;</code>
         */
        HIGHLIGHT(2),
        ;

        /**
         * <code>NONE = 0;</code>
         */
        public static final int NONE_VALUE = 0;
        /**
         * <code>UNDERLINE = 1;</code>
         */
        public static final int UNDERLINE_VALUE = 1;
        /**
         * <code>HIGHLIGHT = 2;</code>
         */
        public static final int HIGHLIGHT_VALUE = 2;


        @java.lang.Override
        public final int getNumber() {
          return value;
        }

        /**
         * @param value The number of the enum to look for.
         * @return The enum associated with the given number.
         * @deprecated Use {@link #forNumber(int)} instead.
         */
        @java.lang.Deprecated
        public static Annotation valueOf(int value) {
          return forNumber(value);
        }

        public static Annotation forNumber(int value) {
          switch (value) {
            case 0: return NONE;
            case 1: return UNDERLINE;
            case 2: return HIGHLIGHT;
            default: return null;
          }
        }

        public static com.google.protobuf.Internal.EnumLiteMap<Annotation>
            internalGetValueMap() {
          return internalValueMap;
        }
        private static final com.google.protobuf.Internal.EnumLiteMap<
            Annotation> internalValueMap =
              new com.google.protobuf.Internal.EnumLiteMap<Annotation>() {
                @java.lang.Override
                public Annotation findValueByNumber(int number) {
                  return Annotation.forNumber(number);
                }
              };

        public static com.google.protobuf.Internal.EnumVerifier 
            internalGetVerifier() {
          return AnnotationVerifier.INSTANCE;
        }

        private static final class AnnotationVerifier implements 
             com.google.protobuf.Internal.EnumVerifier { 
                static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new AnnotationVerifier();
                @java.lang.Override
                public boolean isInRange(int number) {
                  return Annotation.forNumber(number) != null;
                }
              };

        private final int value;

        private Annotation(int value) {
          this.value = value;
        }

        // @@protoc_insertion_point(enum_scope:mozc.commands.Preedit.Segment.Annotation)
      }

      private int bitField0_;
      public static final int ANNOTATION_FIELD_NUMBER = 3;
      private int annotation_;
      /**
       * <code>required .mozc.commands.Preedit.Segment.Annotation annotation = 3;</code>
       * @return Whether the annotation field is set.
       */
      @java.lang.Override
      public boolean hasAnnotation() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>required .mozc.commands.Preedit.Segment.Annotation annotation = 3;</code>
       * @return The annotation.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.Annotation getAnnotation() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.Annotation result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.Annotation.forNumber(annotation_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.Annotation.NONE : result;
      }
      /**
       * <code>required .mozc.commands.Preedit.Segment.Annotation annotation = 3;</code>
       * @param value The annotation to set.
       */
      private void setAnnotation(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.Annotation value) {
        annotation_ = value.getNumber();
        bitField0_ |= 0x00000001;
      }
      /**
       * <code>required .mozc.commands.Preedit.Segment.Annotation annotation = 3;</code>
       */
      private void clearAnnotation() {
        bitField0_ = (bitField0_ & ~0x00000001);
        annotation_ = 0;
      }

      public static final int VALUE_FIELD_NUMBER = 4;
      private java.lang.String value_;
      /**
       * <code>required string value = 4;</code>
       * @return Whether the value field is set.
       */
      @java.lang.Override
      public boolean hasValue() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>required string value = 4;</code>
       * @return The value.
       */
      @java.lang.Override
      public java.lang.String getValue() {
        return value_;
      }
      /**
       * <code>required string value = 4;</code>
       * @return The bytes for value.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getValueBytes() {
        return com.google.protobuf.ByteString.copyFromUtf8(value_);
      }
      /**
       * <code>required string value = 4;</code>
       * @param value The value to set.
       */
      private void setValue(
          java.lang.String value) {
        java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000002;
        value_ = value;
      }
      /**
       * <code>required string value = 4;</code>
       */
      private void clearValue() {
        bitField0_ = (bitField0_ & ~0x00000002);
        value_ = getDefaultInstance().getValue();
      }
      /**
       * <code>required string value = 4;</code>
       * @param value The bytes for value to set.
       */
      private void setValueBytes(
          com.google.protobuf.ByteString value) {
        value_ = value.toStringUtf8();
        bitField0_ |= 0x00000002;
      }

      public static final int VALUE_LENGTH_FIELD_NUMBER = 5;
      private int valueLength_;
      /**
       * <pre>
       * The length of value in characters.  This is NOT a number in
       * bytes or logical character units.  So, the length of "abc" and
       * "あいう" should be 3, "ヴ" should be 1 and "ｳﾞ" and "う゛"
       * should be 2.
       * </pre>
       *
       * <code>required uint32 value_length = 5;</code>
       * @return Whether the valueLength field is set.
       */
      @java.lang.Override
      public boolean hasValueLength() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * The length of value in characters.  This is NOT a number in
       * bytes or logical character units.  So, the length of "abc" and
       * "あいう" should be 3, "ヴ" should be 1 and "ｳﾞ" and "う゛"
       * should be 2.
       * </pre>
       *
       * <code>required uint32 value_length = 5;</code>
       * @return The valueLength.
       */
      @java.lang.Override
      public int getValueLength() {
        return valueLength_;
      }
      /**
       * <pre>
       * The length of value in characters.  This is NOT a number in
       * bytes or logical character units.  So, the length of "abc" and
       * "あいう" should be 3, "ヴ" should be 1 and "ｳﾞ" and "う゛"
       * should be 2.
       * </pre>
       *
       * <code>required uint32 value_length = 5;</code>
       * @param value The valueLength to set.
       */
      private void setValueLength(int value) {
        bitField0_ |= 0x00000004;
        valueLength_ = value;
      }
      /**
       * <pre>
       * The length of value in characters.  This is NOT a number in
       * bytes or logical character units.  So, the length of "abc" and
       * "あいう" should be 3, "ヴ" should be 1 and "ｳﾞ" and "う゛"
       * should be 2.
       * </pre>
       *
       * <code>required uint32 value_length = 5;</code>
       */
      private void clearValueLength() {
        bitField0_ = (bitField0_ & ~0x00000004);
        valueLength_ = 0;
      }

      public static final int KEY_FIELD_NUMBER = 6;
      private java.lang.String key_;
      /**
       * <pre>
       * Source of the value.  It is almost always the reading of the value.
       * </pre>
       *
       * <code>optional string key = 6;</code>
       * @return Whether the key field is set.
       */
      @java.lang.Override
      public boolean hasKey() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * Source of the value.  It is almost always the reading of the value.
       * </pre>
       *
       * <code>optional string key = 6;</code>
       * @return The key.
       */
      @java.lang.Override
      public java.lang.String getKey() {
        return key_;
      }
      /**
       * <pre>
       * Source of the value.  It is almost always the reading of the value.
       * </pre>
       *
       * <code>optional string key = 6;</code>
       * @return The bytes for key.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getKeyBytes() {
        return com.google.protobuf.ByteString.copyFromUtf8(key_);
      }
      /**
       * <pre>
       * Source of the value.  It is almost always the reading of the value.
       * </pre>
       *
       * <code>optional string key = 6;</code>
       * @param value The key to set.
       */
      private void setKey(
          java.lang.String value) {
        java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000008;
        key_ = value;
      }
      /**
       * <pre>
       * Source of the value.  It is almost always the reading of the value.
       * </pre>
       *
       * <code>optional string key = 6;</code>
       */
      private void clearKey() {
        bitField0_ = (bitField0_ & ~0x00000008);
        key_ = getDefaultInstance().getKey();
      }
      /**
       * <pre>
       * Source of the value.  It is almost always the reading of the value.
       * </pre>
       *
       * <code>optional string key = 6;</code>
       * @param value The bytes for key to set.
       */
      private void setKeyBytes(
          com.google.protobuf.ByteString value) {
        key_ = value.toStringUtf8();
        bitField0_ |= 0x00000008;
      }

      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }

      public static Builder newBuilder() {
        return (Builder) DEFAULT_INSTANCE.createBuilder();
      }
      public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment prototype) {
        return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
      }

      /**
       * <pre>
       * The string data of Preedit is separated into Segment messages
       * presenting the ime server's status.  On Preedit status of
       * Japanese IME, there are up to three segments; left side chars of
       * cursor, forcused char, right side chars of cursor.  On Conversion
       * status of Japanese IME, the messages literally represent the
       * segments of the conversion.
       * </pre>
       *
       * Protobuf type {@code mozc.commands.Preedit.Segment}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageLite.Builder<
            org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment, Builder> implements
          // @@protoc_insertion_point(builder_implements:mozc.commands.Preedit.Segment)
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.SegmentOrBuilder {
        // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.newBuilder()
        private Builder() {
          super(DEFAULT_INSTANCE);
        }


        /**
         * <code>required .mozc.commands.Preedit.Segment.Annotation annotation = 3;</code>
         * @return Whether the annotation field is set.
         */
        @java.lang.Override
        public boolean hasAnnotation() {
          return instance.hasAnnotation();
        }
        /**
         * <code>required .mozc.commands.Preedit.Segment.Annotation annotation = 3;</code>
         * @return The annotation.
         */
        @java.lang.Override
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.Annotation getAnnotation() {
          return instance.getAnnotation();
        }
        /**
         * <code>required .mozc.commands.Preedit.Segment.Annotation annotation = 3;</code>
         * @param value The enum numeric value on the wire for annotation to set.
         * @return This builder for chaining.
         */
        public Builder setAnnotation(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.Annotation value) {
          copyOnWrite();
          instance.setAnnotation(value);
          return this;
        }
        /**
         * <code>required .mozc.commands.Preedit.Segment.Annotation annotation = 3;</code>
         * @return This builder for chaining.
         */
        public Builder clearAnnotation() {
          copyOnWrite();
          instance.clearAnnotation();
          return this;
        }

        /**
         * <code>required string value = 4;</code>
         * @return Whether the value field is set.
         */
        @java.lang.Override
        public boolean hasValue() {
          return instance.hasValue();
        }
        /**
         * <code>required string value = 4;</code>
         * @return The value.
         */
        @java.lang.Override
        public java.lang.String getValue() {
          return instance.getValue();
        }
        /**
         * <code>required string value = 4;</code>
         * @return The bytes for value.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
            getValueBytes() {
          return instance.getValueBytes();
        }
        /**
         * <code>required string value = 4;</code>
         * @param value The value to set.
         * @return This builder for chaining.
         */
        public Builder setValue(
            java.lang.String value) {
          copyOnWrite();
          instance.setValue(value);
          return this;
        }
        /**
         * <code>required string value = 4;</code>
         * @return This builder for chaining.
         */
        public Builder clearValue() {
          copyOnWrite();
          instance.clearValue();
          return this;
        }
        /**
         * <code>required string value = 4;</code>
         * @param value The bytes for value to set.
         * @return This builder for chaining.
         */
        public Builder setValueBytes(
            com.google.protobuf.ByteString value) {
          copyOnWrite();
          instance.setValueBytes(value);
          return this;
        }

        /**
         * <pre>
         * The length of value in characters.  This is NOT a number in
         * bytes or logical character units.  So, the length of "abc" and
         * "あいう" should be 3, "ヴ" should be 1 and "ｳﾞ" and "う゛"
         * should be 2.
         * </pre>
         *
         * <code>required uint32 value_length = 5;</code>
         * @return Whether the valueLength field is set.
         */
        @java.lang.Override
        public boolean hasValueLength() {
          return instance.hasValueLength();
        }
        /**
         * <pre>
         * The length of value in characters.  This is NOT a number in
         * bytes or logical character units.  So, the length of "abc" and
         * "あいう" should be 3, "ヴ" should be 1 and "ｳﾞ" and "う゛"
         * should be 2.
         * </pre>
         *
         * <code>required uint32 value_length = 5;</code>
         * @return The valueLength.
         */
        @java.lang.Override
        public int getValueLength() {
          return instance.getValueLength();
        }
        /**
         * <pre>
         * The length of value in characters.  This is NOT a number in
         * bytes or logical character units.  So, the length of "abc" and
         * "あいう" should be 3, "ヴ" should be 1 and "ｳﾞ" and "う゛"
         * should be 2.
         * </pre>
         *
         * <code>required uint32 value_length = 5;</code>
         * @param value The valueLength to set.
         * @return This builder for chaining.
         */
        public Builder setValueLength(int value) {
          copyOnWrite();
          instance.setValueLength(value);
          return this;
        }
        /**
         * <pre>
         * The length of value in characters.  This is NOT a number in
         * bytes or logical character units.  So, the length of "abc" and
         * "あいう" should be 3, "ヴ" should be 1 and "ｳﾞ" and "う゛"
         * should be 2.
         * </pre>
         *
         * <code>required uint32 value_length = 5;</code>
         * @return This builder for chaining.
         */
        public Builder clearValueLength() {
          copyOnWrite();
          instance.clearValueLength();
          return this;
        }

        /**
         * <pre>
         * Source of the value.  It is almost always the reading of the value.
         * </pre>
         *
         * <code>optional string key = 6;</code>
         * @return Whether the key field is set.
         */
        @java.lang.Override
        public boolean hasKey() {
          return instance.hasKey();
        }
        /**
         * <pre>
         * Source of the value.  It is almost always the reading of the value.
         * </pre>
         *
         * <code>optional string key = 6;</code>
         * @return The key.
         */
        @java.lang.Override
        public java.lang.String getKey() {
          return instance.getKey();
        }
        /**
         * <pre>
         * Source of the value.  It is almost always the reading of the value.
         * </pre>
         *
         * <code>optional string key = 6;</code>
         * @return The bytes for key.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
            getKeyBytes() {
          return instance.getKeyBytes();
        }
        /**
         * <pre>
         * Source of the value.  It is almost always the reading of the value.
         * </pre>
         *
         * <code>optional string key = 6;</code>
         * @param value The key to set.
         * @return This builder for chaining.
         */
        public Builder setKey(
            java.lang.String value) {
          copyOnWrite();
          instance.setKey(value);
          return this;
        }
        /**
         * <pre>
         * Source of the value.  It is almost always the reading of the value.
         * </pre>
         *
         * <code>optional string key = 6;</code>
         * @return This builder for chaining.
         */
        public Builder clearKey() {
          copyOnWrite();
          instance.clearKey();
          return this;
        }
        /**
         * <pre>
         * Source of the value.  It is almost always the reading of the value.
         * </pre>
         *
         * <code>optional string key = 6;</code>
         * @param value The bytes for key to set.
         * @return This builder for chaining.
         */
        public Builder setKeyBytes(
            com.google.protobuf.ByteString value) {
          copyOnWrite();
          instance.setKeyBytes(value);
          return this;
        }

        // @@protoc_insertion_point(builder_scope:mozc.commands.Preedit.Segment)
      }
      private byte memoizedIsInitialized = 2;
      @java.lang.Override
      @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
      protected final java.lang.Object dynamicMethod(
          com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
          java.lang.Object arg0, java.lang.Object arg1) {
        switch (method) {
          case NEW_MUTABLE_INSTANCE: {
            return new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment();
          }
          case NEW_BUILDER: {
            return new Builder();
          }
          case BUILD_MESSAGE_INFO: {
              java.lang.Object[] objects = new java.lang.Object[] {
                "bitField0_",
                "annotation_",
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.Annotation.internalGetVerifier(),
                "value_",
                "valueLength_",
                "key_",
              };
              java.lang.String info =
                  "\u0001\u0004\u0000\u0001\u0003\u0006\u0004\u0000\u0000\u0003\u0003\u150c\u0000\u0004" +
                  "\u1508\u0001\u0005\u150b\u0002\u0006\u1008\u0003";
              return newMessageInfo(DEFAULT_INSTANCE, info, objects);
          }
          // fall through
          case GET_DEFAULT_INSTANCE: {
            return DEFAULT_INSTANCE;
          }
          case GET_PARSER: {
            com.google.protobuf.Parser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment> parser = PARSER;
            if (parser == null) {
              synchronized (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.class) {
                parser = PARSER;
                if (parser == null) {
                  parser =
                      new DefaultInstanceBasedParser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment>(
                          DEFAULT_INSTANCE);
                  PARSER = parser;
                }
              }
            }
            return parser;
        }
        case GET_MEMOIZED_IS_INITIALIZED: {
          return memoizedIsInitialized;
        }
        case SET_MEMOIZED_IS_INITIALIZED: {
          memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
          return null;
        }
        }
        throw new UnsupportedOperationException();
      }


      // @@protoc_insertion_point(class_scope:mozc.commands.Preedit.Segment)
      private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment DEFAULT_INSTANCE;
      static {
        Segment defaultInstance = new Segment();
        // New instances are implicitly immutable so no need to make
        // immutable.
        DEFAULT_INSTANCE = defaultInstance;
        com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
          Segment.class, defaultInstance);
      }

      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static volatile com.google.protobuf.Parser<Segment> PARSER;

      public static com.google.protobuf.Parser<Segment> parser() {
        return DEFAULT_INSTANCE.getParserForType();
      }
    }

    private int bitField0_;
    public static final int CURSOR_FIELD_NUMBER = 1;
    private int cursor_;
    /**
     * <code>required uint32 cursor = 1;</code>
     * @return Whether the cursor field is set.
     */
    @java.lang.Override
    public boolean hasCursor() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>required uint32 cursor = 1;</code>
     * @return The cursor.
     */
    @java.lang.Override
    public int getCursor() {
      return cursor_;
    }
    /**
     * <code>required uint32 cursor = 1;</code>
     * @param value The cursor to set.
     */
    private void setCursor(int value) {
      bitField0_ |= 0x00000001;
      cursor_ = value;
    }
    /**
     * <code>required uint32 cursor = 1;</code>
     */
    private void clearCursor() {
      bitField0_ = (bitField0_ & ~0x00000001);
      cursor_ = 0;
    }

    public static final int SEGMENT_FIELD_NUMBER = 2;
    private com.google.protobuf.Internal.ProtobufList<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment> segment_;
    /**
     * <code>repeated group Segment = 2 { ... }</code>
     */
    @java.lang.Override
    public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment> getSegmentList() {
      return segment_;
    }
    /**
     * <code>repeated group Segment = 2 { ... }</code>
     */
    public java.util.List<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.SegmentOrBuilder> 
        getSegmentOrBuilderList() {
      return segment_;
    }
    /**
     * <code>repeated group Segment = 2 { ... }</code>
     */
    @java.lang.Override
    public int getSegmentCount() {
      return segment_.size();
    }
    /**
     * <code>repeated group Segment = 2 { ... }</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment getSegment(int index) {
      return segment_.get(index);
    }
    /**
     * <code>repeated group Segment = 2 { ... }</code>
     */
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.SegmentOrBuilder getSegmentOrBuilder(
        int index) {
      return segment_.get(index);
    }
    private void ensureSegmentIsMutable() {
      com.google.protobuf.Internal.ProtobufList<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment> tmp = segment_;
      if (!tmp.isModifiable()) {
        segment_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <code>repeated group Segment = 2 { ... }</code>
     */
    private void setSegment(
        int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment value) {
      value.getClass();
  ensureSegmentIsMutable();
      segment_.set(index, value);
    }
    /**
     * <code>repeated group Segment = 2 { ... }</code>
     */
    private void addSegment(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment value) {
      value.getClass();
  ensureSegmentIsMutable();
      segment_.add(value);
    }
    /**
     * <code>repeated group Segment = 2 { ... }</code>
     */
    private void addSegment(
        int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment value) {
      value.getClass();
  ensureSegmentIsMutable();
      segment_.add(index, value);
    }
    /**
     * <code>repeated group Segment = 2 { ... }</code>
     */
    private void addAllSegment(
        java.lang.Iterable<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment> values) {
      ensureSegmentIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, segment_);
    }
    /**
     * <code>repeated group Segment = 2 { ... }</code>
     */
    private void clearSegment() {
      segment_ = emptyProtobufList();
    }
    /**
     * <code>repeated group Segment = 2 { ... }</code>
     */
    private void removeSegment(int index) {
      ensureSegmentIsMutable();
      segment_.remove(index);
    }

    public static final int HIGHLIGHTED_POSITION_FIELD_NUMBER = 3;
    private int highlightedPosition_;
    /**
     * <pre>
     * The position of the first segment whose annotation is 'HIGHLIGHT'. Not set
     * if there are no such segments.
     * </pre>
     *
     * <code>optional uint32 highlighted_position = 3;</code>
     * @return Whether the highlightedPosition field is set.
     */
    @java.lang.Override
    public boolean hasHighlightedPosition() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * The position of the first segment whose annotation is 'HIGHLIGHT'. Not set
     * if there are no such segments.
     * </pre>
     *
     * <code>optional uint32 highlighted_position = 3;</code>
     * @return The highlightedPosition.
     */
    @java.lang.Override
    public int getHighlightedPosition() {
      return highlightedPosition_;
    }
    /**
     * <pre>
     * The position of the first segment whose annotation is 'HIGHLIGHT'. Not set
     * if there are no such segments.
     * </pre>
     *
     * <code>optional uint32 highlighted_position = 3;</code>
     * @param value The highlightedPosition to set.
     */
    private void setHighlightedPosition(int value) {
      bitField0_ |= 0x00000002;
      highlightedPosition_ = value;
    }
    /**
     * <pre>
     * The position of the first segment whose annotation is 'HIGHLIGHT'. Not set
     * if there are no such segments.
     * </pre>
     *
     * <code>optional uint32 highlighted_position = 3;</code>
     */
    private void clearHighlightedPosition() {
      bitField0_ = (bitField0_ & ~0x00000002);
      highlightedPosition_ = 0;
    }

    public static final int IS_TOGGLEABLE_FIELD_NUMBER = 4;
    private boolean isToggleable_;
    /**
     * <pre>
     * This flag is set to true if the character at the cursor position
     * is in toggleable state.  For example, when the table is
     * TOGGLE_FLICK_TO_HIRAGANA and key event '1' is received
     * repeatedly, the preedit toggles like あ -&gt; い -&gt; う -&gt; ....  This
     * flag is true during this cycle.  This state is reset when user
     * types another key or SessionCommand::STOP_KEY_TOGGLING is
     * received.
     * </pre>
     *
     * <code>optional bool is_toggleable = 4 [default = false];</code>
     * @return Whether the isToggleable field is set.
     */
    @java.lang.Override
    public boolean hasIsToggleable() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * This flag is set to true if the character at the cursor position
     * is in toggleable state.  For example, when the table is
     * TOGGLE_FLICK_TO_HIRAGANA and key event '1' is received
     * repeatedly, the preedit toggles like あ -&gt; い -&gt; う -&gt; ....  This
     * flag is true during this cycle.  This state is reset when user
     * types another key or SessionCommand::STOP_KEY_TOGGLING is
     * received.
     * </pre>
     *
     * <code>optional bool is_toggleable = 4 [default = false];</code>
     * @return The isToggleable.
     */
    @java.lang.Override
    public boolean getIsToggleable() {
      return isToggleable_;
    }
    /**
     * <pre>
     * This flag is set to true if the character at the cursor position
     * is in toggleable state.  For example, when the table is
     * TOGGLE_FLICK_TO_HIRAGANA and key event '1' is received
     * repeatedly, the preedit toggles like あ -&gt; い -&gt; う -&gt; ....  This
     * flag is true during this cycle.  This state is reset when user
     * types another key or SessionCommand::STOP_KEY_TOGGLING is
     * received.
     * </pre>
     *
     * <code>optional bool is_toggleable = 4 [default = false];</code>
     * @param value The isToggleable to set.
     */
    private void setIsToggleable(boolean value) {
      bitField0_ |= 0x00000004;
      isToggleable_ = value;
    }
    /**
     * <pre>
     * This flag is set to true if the character at the cursor position
     * is in toggleable state.  For example, when the table is
     * TOGGLE_FLICK_TO_HIRAGANA and key event '1' is received
     * repeatedly, the preedit toggles like あ -&gt; い -&gt; う -&gt; ....  This
     * flag is true during this cycle.  This state is reset when user
     * types another key or SessionCommand::STOP_KEY_TOGGLING is
     * received.
     * </pre>
     *
     * <code>optional bool is_toggleable = 4 [default = false];</code>
     */
    private void clearIsToggleable() {
      bitField0_ = (bitField0_ & ~0x00000004);
      isToggleable_ = false;
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Preedit represents a composition data, which is rendered on the
     * host application by the ime client.  On Japanese IME, the both
     * Preedit and Conversion statuses are represented by this message.
     * </pre>
     *
     * Protobuf type {@code mozc.commands.Preedit}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit, Builder> implements
        // @@protoc_insertion_point(builder_implements:mozc.commands.Preedit)
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.PreeditOrBuilder {
      // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>required uint32 cursor = 1;</code>
       * @return Whether the cursor field is set.
       */
      @java.lang.Override
      public boolean hasCursor() {
        return instance.hasCursor();
      }
      /**
       * <code>required uint32 cursor = 1;</code>
       * @return The cursor.
       */
      @java.lang.Override
      public int getCursor() {
        return instance.getCursor();
      }
      /**
       * <code>required uint32 cursor = 1;</code>
       * @param value The cursor to set.
       * @return This builder for chaining.
       */
      public Builder setCursor(int value) {
        copyOnWrite();
        instance.setCursor(value);
        return this;
      }
      /**
       * <code>required uint32 cursor = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearCursor() {
        copyOnWrite();
        instance.clearCursor();
        return this;
      }

      /**
       * <code>repeated group Segment = 2 { ... }</code>
       */
      @java.lang.Override
      public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment> getSegmentList() {
        return java.util.Collections.unmodifiableList(
            instance.getSegmentList());
      }
      /**
       * <code>repeated group Segment = 2 { ... }</code>
       */
      @java.lang.Override
      public int getSegmentCount() {
        return instance.getSegmentCount();
      }/**
       * <code>repeated group Segment = 2 { ... }</code>
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment getSegment(int index) {
        return instance.getSegment(index);
      }
      /**
       * <code>repeated group Segment = 2 { ... }</code>
       */
      public Builder setSegment(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment value) {
        copyOnWrite();
        instance.setSegment(index, value);
        return this;
      }
      /**
       * <code>repeated group Segment = 2 { ... }</code>
       */
      public Builder setSegment(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.Builder builderForValue) {
        copyOnWrite();
        instance.setSegment(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated group Segment = 2 { ... }</code>
       */
      public Builder addSegment(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment value) {
        copyOnWrite();
        instance.addSegment(value);
        return this;
      }
      /**
       * <code>repeated group Segment = 2 { ... }</code>
       */
      public Builder addSegment(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment value) {
        copyOnWrite();
        instance.addSegment(index, value);
        return this;
      }
      /**
       * <code>repeated group Segment = 2 { ... }</code>
       */
      public Builder addSegment(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.Builder builderForValue) {
        copyOnWrite();
        instance.addSegment(builderForValue.build());
        return this;
      }
      /**
       * <code>repeated group Segment = 2 { ... }</code>
       */
      public Builder addSegment(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.Builder builderForValue) {
        copyOnWrite();
        instance.addSegment(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated group Segment = 2 { ... }</code>
       */
      public Builder addAllSegment(
          java.lang.Iterable<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment> values) {
        copyOnWrite();
        instance.addAllSegment(values);
        return this;
      }
      /**
       * <code>repeated group Segment = 2 { ... }</code>
       */
      public Builder clearSegment() {
        copyOnWrite();
        instance.clearSegment();
        return this;
      }
      /**
       * <code>repeated group Segment = 2 { ... }</code>
       */
      public Builder removeSegment(int index) {
        copyOnWrite();
        instance.removeSegment(index);
        return this;
      }

      /**
       * <pre>
       * The position of the first segment whose annotation is 'HIGHLIGHT'. Not set
       * if there are no such segments.
       * </pre>
       *
       * <code>optional uint32 highlighted_position = 3;</code>
       * @return Whether the highlightedPosition field is set.
       */
      @java.lang.Override
      public boolean hasHighlightedPosition() {
        return instance.hasHighlightedPosition();
      }
      /**
       * <pre>
       * The position of the first segment whose annotation is 'HIGHLIGHT'. Not set
       * if there are no such segments.
       * </pre>
       *
       * <code>optional uint32 highlighted_position = 3;</code>
       * @return The highlightedPosition.
       */
      @java.lang.Override
      public int getHighlightedPosition() {
        return instance.getHighlightedPosition();
      }
      /**
       * <pre>
       * The position of the first segment whose annotation is 'HIGHLIGHT'. Not set
       * if there are no such segments.
       * </pre>
       *
       * <code>optional uint32 highlighted_position = 3;</code>
       * @param value The highlightedPosition to set.
       * @return This builder for chaining.
       */
      public Builder setHighlightedPosition(int value) {
        copyOnWrite();
        instance.setHighlightedPosition(value);
        return this;
      }
      /**
       * <pre>
       * The position of the first segment whose annotation is 'HIGHLIGHT'. Not set
       * if there are no such segments.
       * </pre>
       *
       * <code>optional uint32 highlighted_position = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearHighlightedPosition() {
        copyOnWrite();
        instance.clearHighlightedPosition();
        return this;
      }

      /**
       * <pre>
       * This flag is set to true if the character at the cursor position
       * is in toggleable state.  For example, when the table is
       * TOGGLE_FLICK_TO_HIRAGANA and key event '1' is received
       * repeatedly, the preedit toggles like あ -&gt; い -&gt; う -&gt; ....  This
       * flag is true during this cycle.  This state is reset when user
       * types another key or SessionCommand::STOP_KEY_TOGGLING is
       * received.
       * </pre>
       *
       * <code>optional bool is_toggleable = 4 [default = false];</code>
       * @return Whether the isToggleable field is set.
       */
      @java.lang.Override
      public boolean hasIsToggleable() {
        return instance.hasIsToggleable();
      }
      /**
       * <pre>
       * This flag is set to true if the character at the cursor position
       * is in toggleable state.  For example, when the table is
       * TOGGLE_FLICK_TO_HIRAGANA and key event '1' is received
       * repeatedly, the preedit toggles like あ -&gt; い -&gt; う -&gt; ....  This
       * flag is true during this cycle.  This state is reset when user
       * types another key or SessionCommand::STOP_KEY_TOGGLING is
       * received.
       * </pre>
       *
       * <code>optional bool is_toggleable = 4 [default = false];</code>
       * @return The isToggleable.
       */
      @java.lang.Override
      public boolean getIsToggleable() {
        return instance.getIsToggleable();
      }
      /**
       * <pre>
       * This flag is set to true if the character at the cursor position
       * is in toggleable state.  For example, when the table is
       * TOGGLE_FLICK_TO_HIRAGANA and key event '1' is received
       * repeatedly, the preedit toggles like あ -&gt; い -&gt; う -&gt; ....  This
       * flag is true during this cycle.  This state is reset when user
       * types another key or SessionCommand::STOP_KEY_TOGGLING is
       * received.
       * </pre>
       *
       * <code>optional bool is_toggleable = 4 [default = false];</code>
       * @param value The isToggleable to set.
       * @return This builder for chaining.
       */
      public Builder setIsToggleable(boolean value) {
        copyOnWrite();
        instance.setIsToggleable(value);
        return this;
      }
      /**
       * <pre>
       * This flag is set to true if the character at the cursor position
       * is in toggleable state.  For example, when the table is
       * TOGGLE_FLICK_TO_HIRAGANA and key event '1' is received
       * repeatedly, the preedit toggles like あ -&gt; い -&gt; う -&gt; ....  This
       * flag is true during this cycle.  This state is reset when user
       * types another key or SessionCommand::STOP_KEY_TOGGLING is
       * received.
       * </pre>
       *
       * <code>optional bool is_toggleable = 4 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearIsToggleable() {
        copyOnWrite();
        instance.clearIsToggleable();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:mozc.commands.Preedit)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "cursor_",
              "segment_",
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.class,
              "highlightedPosition_",
              "isToggleable_",
            };
            java.lang.String info =
                "\u0001\u0004\u0000\u0001\u0001\u0004\u0004\u0000\u0001\u0002\u0001\u150b\u0000\u0002" +
                "\u0431\u0003\u100b\u0001\u0004\u1007\u0002";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit> parser = PARSER;
          if (parser == null) {
            synchronized (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:mozc.commands.Preedit)
    private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit DEFAULT_INSTANCE;
    static {
      Preedit defaultInstance = new Preedit();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Preedit.class, defaultInstance);
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Preedit> PARSER;

    public static com.google.protobuf.Parser<Preedit> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface StatusOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mozc.commands.Status)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Whether IME is ON or OFF
     * </pre>
     *
     * <code>optional bool activated = 1;</code>
     * @return Whether the activated field is set.
     */
    boolean hasActivated();
    /**
     * <pre>
     * Whether IME is ON or OFF
     * </pre>
     *
     * <code>optional bool activated = 1;</code>
     * @return The activated.
     */
    boolean getActivated();

    /**
     * <pre>
     * Visible composition mode when IME is activated. This mode may come from a
     * temporary composition mode. See |comeback_mode|.
     * TODO(yukawa): Rename this field to "visible_mode".
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode mode = 2;</code>
     * @return Whether the mode field is set.
     */
    boolean hasMode();
    /**
     * <pre>
     * Visible composition mode when IME is activated. This mode may come from a
     * temporary composition mode. See |comeback_mode|.
     * TODO(yukawa): Rename this field to "visible_mode".
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode mode = 2;</code>
     * @return The mode.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode getMode();

    /**
     * <pre>
     * True composition mode that is suitable for system global and permanent
     * composition mode. When a temporary composition mode exists,
     * |comeback_mode| can be different from |mode|.
     * TODO(yukawa): Use more appropriate name.
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode comeback_mode = 3;</code>
     * @return Whether the comebackMode field is set.
     */
    boolean hasComebackMode();
    /**
     * <pre>
     * True composition mode that is suitable for system global and permanent
     * composition mode. When a temporary composition mode exists,
     * |comeback_mode| can be different from |mode|.
     * TODO(yukawa): Use more appropriate name.
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode comeback_mode = 3;</code>
     * @return The comebackMode.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode getComebackMode();

    /**
     * <pre>
     * Whether Undo operation is available.
     * The client may enable/disable the Undo key based on this value.
     * </pre>
     *
     * <code>optional bool undo_available = 26;</code>
     * @return Whether the undoAvailable field is set.
     */
    boolean hasUndoAvailable();
    /**
     * <pre>
     * Whether Undo operation is available.
     * The client may enable/disable the Undo key based on this value.
     * </pre>
     *
     * <code>optional bool undo_available = 26;</code>
     * @return The undoAvailable.
     */
    boolean getUndoAvailable();
  }
  /**
   * Protobuf type {@code mozc.commands.Status}
   */
  public  static final class Status extends
      com.google.protobuf.GeneratedMessageLite<
          Status, Status.Builder> implements
      // @@protoc_insertion_point(message_implements:mozc.commands.Status)
      StatusOrBuilder {
    private Status() {
    }
    private int bitField0_;
    public static final int ACTIVATED_FIELD_NUMBER = 1;
    private boolean activated_;
    /**
     * <pre>
     * Whether IME is ON or OFF
     * </pre>
     *
     * <code>optional bool activated = 1;</code>
     * @return Whether the activated field is set.
     */
    @java.lang.Override
    public boolean hasActivated() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Whether IME is ON or OFF
     * </pre>
     *
     * <code>optional bool activated = 1;</code>
     * @return The activated.
     */
    @java.lang.Override
    public boolean getActivated() {
      return activated_;
    }
    /**
     * <pre>
     * Whether IME is ON or OFF
     * </pre>
     *
     * <code>optional bool activated = 1;</code>
     * @param value The activated to set.
     */
    private void setActivated(boolean value) {
      bitField0_ |= 0x00000001;
      activated_ = value;
    }
    /**
     * <pre>
     * Whether IME is ON or OFF
     * </pre>
     *
     * <code>optional bool activated = 1;</code>
     */
    private void clearActivated() {
      bitField0_ = (bitField0_ & ~0x00000001);
      activated_ = false;
    }

    public static final int MODE_FIELD_NUMBER = 2;
    private int mode_;
    /**
     * <pre>
     * Visible composition mode when IME is activated. This mode may come from a
     * temporary composition mode. See |comeback_mode|.
     * TODO(yukawa): Rename this field to "visible_mode".
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode mode = 2;</code>
     * @return Whether the mode field is set.
     */
    @java.lang.Override
    public boolean hasMode() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Visible composition mode when IME is activated. This mode may come from a
     * temporary composition mode. See |comeback_mode|.
     * TODO(yukawa): Rename this field to "visible_mode".
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode mode = 2;</code>
     * @return The mode.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode getMode() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode.forNumber(mode_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode.DIRECT : result;
    }
    /**
     * <pre>
     * Visible composition mode when IME is activated. This mode may come from a
     * temporary composition mode. See |comeback_mode|.
     * TODO(yukawa): Rename this field to "visible_mode".
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode mode = 2;</code>
     * @param value The mode to set.
     */
    private void setMode(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode value) {
      mode_ = value.getNumber();
      bitField0_ |= 0x00000002;
    }
    /**
     * <pre>
     * Visible composition mode when IME is activated. This mode may come from a
     * temporary composition mode. See |comeback_mode|.
     * TODO(yukawa): Rename this field to "visible_mode".
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode mode = 2;</code>
     */
    private void clearMode() {
      bitField0_ = (bitField0_ & ~0x00000002);
      mode_ = 0;
    }

    public static final int COMEBACK_MODE_FIELD_NUMBER = 3;
    private int comebackMode_;
    /**
     * <pre>
     * True composition mode that is suitable for system global and permanent
     * composition mode. When a temporary composition mode exists,
     * |comeback_mode| can be different from |mode|.
     * TODO(yukawa): Use more appropriate name.
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode comeback_mode = 3;</code>
     * @return Whether the comebackMode field is set.
     */
    @java.lang.Override
    public boolean hasComebackMode() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * True composition mode that is suitable for system global and permanent
     * composition mode. When a temporary composition mode exists,
     * |comeback_mode| can be different from |mode|.
     * TODO(yukawa): Use more appropriate name.
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode comeback_mode = 3;</code>
     * @return The comebackMode.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode getComebackMode() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode.forNumber(comebackMode_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode.DIRECT : result;
    }
    /**
     * <pre>
     * True composition mode that is suitable for system global and permanent
     * composition mode. When a temporary composition mode exists,
     * |comeback_mode| can be different from |mode|.
     * TODO(yukawa): Use more appropriate name.
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode comeback_mode = 3;</code>
     * @param value The comebackMode to set.
     */
    private void setComebackMode(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode value) {
      comebackMode_ = value.getNumber();
      bitField0_ |= 0x00000004;
    }
    /**
     * <pre>
     * True composition mode that is suitable for system global and permanent
     * composition mode. When a temporary composition mode exists,
     * |comeback_mode| can be different from |mode|.
     * TODO(yukawa): Use more appropriate name.
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode comeback_mode = 3;</code>
     */
    private void clearComebackMode() {
      bitField0_ = (bitField0_ & ~0x00000004);
      comebackMode_ = 0;
    }

    public static final int UNDO_AVAILABLE_FIELD_NUMBER = 26;
    private boolean undoAvailable_;
    /**
     * <pre>
     * Whether Undo operation is available.
     * The client may enable/disable the Undo key based on this value.
     * </pre>
     *
     * <code>optional bool undo_available = 26;</code>
     * @return Whether the undoAvailable field is set.
     */
    @java.lang.Override
    public boolean hasUndoAvailable() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Whether Undo operation is available.
     * The client may enable/disable the Undo key based on this value.
     * </pre>
     *
     * <code>optional bool undo_available = 26;</code>
     * @return The undoAvailable.
     */
    @java.lang.Override
    public boolean getUndoAvailable() {
      return undoAvailable_;
    }
    /**
     * <pre>
     * Whether Undo operation is available.
     * The client may enable/disable the Undo key based on this value.
     * </pre>
     *
     * <code>optional bool undo_available = 26;</code>
     * @param value The undoAvailable to set.
     */
    private void setUndoAvailable(boolean value) {
      bitField0_ |= 0x00000008;
      undoAvailable_ = value;
    }
    /**
     * <pre>
     * Whether Undo operation is available.
     * The client may enable/disable the Undo key based on this value.
     * </pre>
     *
     * <code>optional bool undo_available = 26;</code>
     */
    private void clearUndoAvailable() {
      bitField0_ = (bitField0_ & ~0x00000008);
      undoAvailable_ = false;
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code mozc.commands.Status}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status, Builder> implements
        // @@protoc_insertion_point(builder_implements:mozc.commands.Status)
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.StatusOrBuilder {
      // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Whether IME is ON or OFF
       * </pre>
       *
       * <code>optional bool activated = 1;</code>
       * @return Whether the activated field is set.
       */
      @java.lang.Override
      public boolean hasActivated() {
        return instance.hasActivated();
      }
      /**
       * <pre>
       * Whether IME is ON or OFF
       * </pre>
       *
       * <code>optional bool activated = 1;</code>
       * @return The activated.
       */
      @java.lang.Override
      public boolean getActivated() {
        return instance.getActivated();
      }
      /**
       * <pre>
       * Whether IME is ON or OFF
       * </pre>
       *
       * <code>optional bool activated = 1;</code>
       * @param value The activated to set.
       * @return This builder for chaining.
       */
      public Builder setActivated(boolean value) {
        copyOnWrite();
        instance.setActivated(value);
        return this;
      }
      /**
       * <pre>
       * Whether IME is ON or OFF
       * </pre>
       *
       * <code>optional bool activated = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearActivated() {
        copyOnWrite();
        instance.clearActivated();
        return this;
      }

      /**
       * <pre>
       * Visible composition mode when IME is activated. This mode may come from a
       * temporary composition mode. See |comeback_mode|.
       * TODO(yukawa): Rename this field to "visible_mode".
       * </pre>
       *
       * <code>optional .mozc.commands.CompositionMode mode = 2;</code>
       * @return Whether the mode field is set.
       */
      @java.lang.Override
      public boolean hasMode() {
        return instance.hasMode();
      }
      /**
       * <pre>
       * Visible composition mode when IME is activated. This mode may come from a
       * temporary composition mode. See |comeback_mode|.
       * TODO(yukawa): Rename this field to "visible_mode".
       * </pre>
       *
       * <code>optional .mozc.commands.CompositionMode mode = 2;</code>
       * @return The mode.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode getMode() {
        return instance.getMode();
      }
      /**
       * <pre>
       * Visible composition mode when IME is activated. This mode may come from a
       * temporary composition mode. See |comeback_mode|.
       * TODO(yukawa): Rename this field to "visible_mode".
       * </pre>
       *
       * <code>optional .mozc.commands.CompositionMode mode = 2;</code>
       * @param value The enum numeric value on the wire for mode to set.
       * @return This builder for chaining.
       */
      public Builder setMode(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode value) {
        copyOnWrite();
        instance.setMode(value);
        return this;
      }
      /**
       * <pre>
       * Visible composition mode when IME is activated. This mode may come from a
       * temporary composition mode. See |comeback_mode|.
       * TODO(yukawa): Rename this field to "visible_mode".
       * </pre>
       *
       * <code>optional .mozc.commands.CompositionMode mode = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearMode() {
        copyOnWrite();
        instance.clearMode();
        return this;
      }

      /**
       * <pre>
       * True composition mode that is suitable for system global and permanent
       * composition mode. When a temporary composition mode exists,
       * |comeback_mode| can be different from |mode|.
       * TODO(yukawa): Use more appropriate name.
       * </pre>
       *
       * <code>optional .mozc.commands.CompositionMode comeback_mode = 3;</code>
       * @return Whether the comebackMode field is set.
       */
      @java.lang.Override
      public boolean hasComebackMode() {
        return instance.hasComebackMode();
      }
      /**
       * <pre>
       * True composition mode that is suitable for system global and permanent
       * composition mode. When a temporary composition mode exists,
       * |comeback_mode| can be different from |mode|.
       * TODO(yukawa): Use more appropriate name.
       * </pre>
       *
       * <code>optional .mozc.commands.CompositionMode comeback_mode = 3;</code>
       * @return The comebackMode.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode getComebackMode() {
        return instance.getComebackMode();
      }
      /**
       * <pre>
       * True composition mode that is suitable for system global and permanent
       * composition mode. When a temporary composition mode exists,
       * |comeback_mode| can be different from |mode|.
       * TODO(yukawa): Use more appropriate name.
       * </pre>
       *
       * <code>optional .mozc.commands.CompositionMode comeback_mode = 3;</code>
       * @param value The enum numeric value on the wire for comebackMode to set.
       * @return This builder for chaining.
       */
      public Builder setComebackMode(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode value) {
        copyOnWrite();
        instance.setComebackMode(value);
        return this;
      }
      /**
       * <pre>
       * True composition mode that is suitable for system global and permanent
       * composition mode. When a temporary composition mode exists,
       * |comeback_mode| can be different from |mode|.
       * TODO(yukawa): Use more appropriate name.
       * </pre>
       *
       * <code>optional .mozc.commands.CompositionMode comeback_mode = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearComebackMode() {
        copyOnWrite();
        instance.clearComebackMode();
        return this;
      }

      /**
       * <pre>
       * Whether Undo operation is available.
       * The client may enable/disable the Undo key based on this value.
       * </pre>
       *
       * <code>optional bool undo_available = 26;</code>
       * @return Whether the undoAvailable field is set.
       */
      @java.lang.Override
      public boolean hasUndoAvailable() {
        return instance.hasUndoAvailable();
      }
      /**
       * <pre>
       * Whether Undo operation is available.
       * The client may enable/disable the Undo key based on this value.
       * </pre>
       *
       * <code>optional bool undo_available = 26;</code>
       * @return The undoAvailable.
       */
      @java.lang.Override
      public boolean getUndoAvailable() {
        return instance.getUndoAvailable();
      }
      /**
       * <pre>
       * Whether Undo operation is available.
       * The client may enable/disable the Undo key based on this value.
       * </pre>
       *
       * <code>optional bool undo_available = 26;</code>
       * @param value The undoAvailable to set.
       * @return This builder for chaining.
       */
      public Builder setUndoAvailable(boolean value) {
        copyOnWrite();
        instance.setUndoAvailable(value);
        return this;
      }
      /**
       * <pre>
       * Whether Undo operation is available.
       * The client may enable/disable the Undo key based on this value.
       * </pre>
       *
       * <code>optional bool undo_available = 26;</code>
       * @return This builder for chaining.
       */
      public Builder clearUndoAvailable() {
        copyOnWrite();
        instance.clearUndoAvailable();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:mozc.commands.Status)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "activated_",
              "mode_",
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode.internalGetVerifier(),
              "comebackMode_",
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode.internalGetVerifier(),
              "undoAvailable_",
            };
            java.lang.String info =
                "\u0001\u0004\u0000\u0001\u0001\u001a\u0004\u0000\u0000\u0000\u0001\u1007\u0000\u0002" +
                "\u100c\u0001\u0003\u100c\u0002\u001a\u1007\u0003";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status> parser = PARSER;
          if (parser == null) {
            synchronized (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:mozc.commands.Status)
    private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status DEFAULT_INSTANCE;
    static {
      Status defaultInstance = new Status();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Status.class, defaultInstance);
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Status> PARSER;

    public static com.google.protobuf.Parser<Status> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface DeletionRangeOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mozc.commands.DeletionRange)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Offset of start of the deletion range.
     * Right now,
     * - Only nagative value is expected.
     *     In this case, the offset is counted from the beginning of the
     *     composition (see the message comment right above).
     * - Positive or 0 value is not sent.
     *     But not forbidden.
     *     Though its expectation is not decided yet,
     *     the client implementation should be prepared (at least, don't crash).
     * </pre>
     *
     * <code>optional int32 offset = 1;</code>
     * @return Whether the offset field is set.
     */
    boolean hasOffset();
    /**
     * <pre>
     * Offset of start of the deletion range.
     * Right now,
     * - Only nagative value is expected.
     *     In this case, the offset is counted from the beginning of the
     *     composition (see the message comment right above).
     * - Positive or 0 value is not sent.
     *     But not forbidden.
     *     Though its expectation is not decided yet,
     *     the client implementation should be prepared (at least, don't crash).
     * </pre>
     *
     * <code>optional int32 offset = 1;</code>
     * @return The offset.
     */
    int getOffset();

    /**
     * <pre>
     * Length of the range.
     * Right now offset==abs(length) is expected.
     * The expectation where the above condition doesn't meet
     * is not defined yet.
     * This may be defined in future (when positive offset becomes
     * supported?).
     * </pre>
     *
     * <code>optional int32 length = 2;</code>
     * @return Whether the length field is set.
     */
    boolean hasLength();
    /**
     * <pre>
     * Length of the range.
     * Right now offset==abs(length) is expected.
     * The expectation where the above condition doesn't meet
     * is not defined yet.
     * This may be defined in future (when positive offset becomes
     * supported?).
     * </pre>
     *
     * <code>optional int32 length = 2;</code>
     * @return The length.
     */
    int getLength();
  }
  /**
   * <pre>
   * This message contains which characters are to be deleted by client.
   * E.g. if current composition and surrounding text are
   *     "この感じは[漢字は]" ("漢字は" is the composition)
   * and we send DeletionRange with offset == -3 and length == 3, then they will
   * be rendered like:
   *     "この[漢字は]"
   * </pre>
   *
   * Protobuf type {@code mozc.commands.DeletionRange}
   */
  public  static final class DeletionRange extends
      com.google.protobuf.GeneratedMessageLite<
          DeletionRange, DeletionRange.Builder> implements
      // @@protoc_insertion_point(message_implements:mozc.commands.DeletionRange)
      DeletionRangeOrBuilder {
    private DeletionRange() {
    }
    private int bitField0_;
    public static final int OFFSET_FIELD_NUMBER = 1;
    private int offset_;
    /**
     * <pre>
     * Offset of start of the deletion range.
     * Right now,
     * - Only nagative value is expected.
     *     In this case, the offset is counted from the beginning of the
     *     composition (see the message comment right above).
     * - Positive or 0 value is not sent.
     *     But not forbidden.
     *     Though its expectation is not decided yet,
     *     the client implementation should be prepared (at least, don't crash).
     * </pre>
     *
     * <code>optional int32 offset = 1;</code>
     * @return Whether the offset field is set.
     */
    @java.lang.Override
    public boolean hasOffset() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Offset of start of the deletion range.
     * Right now,
     * - Only nagative value is expected.
     *     In this case, the offset is counted from the beginning of the
     *     composition (see the message comment right above).
     * - Positive or 0 value is not sent.
     *     But not forbidden.
     *     Though its expectation is not decided yet,
     *     the client implementation should be prepared (at least, don't crash).
     * </pre>
     *
     * <code>optional int32 offset = 1;</code>
     * @return The offset.
     */
    @java.lang.Override
    public int getOffset() {
      return offset_;
    }
    /**
     * <pre>
     * Offset of start of the deletion range.
     * Right now,
     * - Only nagative value is expected.
     *     In this case, the offset is counted from the beginning of the
     *     composition (see the message comment right above).
     * - Positive or 0 value is not sent.
     *     But not forbidden.
     *     Though its expectation is not decided yet,
     *     the client implementation should be prepared (at least, don't crash).
     * </pre>
     *
     * <code>optional int32 offset = 1;</code>
     * @param value The offset to set.
     */
    private void setOffset(int value) {
      bitField0_ |= 0x00000001;
      offset_ = value;
    }
    /**
     * <pre>
     * Offset of start of the deletion range.
     * Right now,
     * - Only nagative value is expected.
     *     In this case, the offset is counted from the beginning of the
     *     composition (see the message comment right above).
     * - Positive or 0 value is not sent.
     *     But not forbidden.
     *     Though its expectation is not decided yet,
     *     the client implementation should be prepared (at least, don't crash).
     * </pre>
     *
     * <code>optional int32 offset = 1;</code>
     */
    private void clearOffset() {
      bitField0_ = (bitField0_ & ~0x00000001);
      offset_ = 0;
    }

    public static final int LENGTH_FIELD_NUMBER = 2;
    private int length_;
    /**
     * <pre>
     * Length of the range.
     * Right now offset==abs(length) is expected.
     * The expectation where the above condition doesn't meet
     * is not defined yet.
     * This may be defined in future (when positive offset becomes
     * supported?).
     * </pre>
     *
     * <code>optional int32 length = 2;</code>
     * @return Whether the length field is set.
     */
    @java.lang.Override
    public boolean hasLength() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Length of the range.
     * Right now offset==abs(length) is expected.
     * The expectation where the above condition doesn't meet
     * is not defined yet.
     * This may be defined in future (when positive offset becomes
     * supported?).
     * </pre>
     *
     * <code>optional int32 length = 2;</code>
     * @return The length.
     */
    @java.lang.Override
    public int getLength() {
      return length_;
    }
    /**
     * <pre>
     * Length of the range.
     * Right now offset==abs(length) is expected.
     * The expectation where the above condition doesn't meet
     * is not defined yet.
     * This may be defined in future (when positive offset becomes
     * supported?).
     * </pre>
     *
     * <code>optional int32 length = 2;</code>
     * @param value The length to set.
     */
    private void setLength(int value) {
      bitField0_ |= 0x00000002;
      length_ = value;
    }
    /**
     * <pre>
     * Length of the range.
     * Right now offset==abs(length) is expected.
     * The expectation where the above condition doesn't meet
     * is not defined yet.
     * This may be defined in future (when positive offset becomes
     * supported?).
     * </pre>
     *
     * <code>optional int32 length = 2;</code>
     */
    private void clearLength() {
      bitField0_ = (bitField0_ & ~0x00000002);
      length_ = 0;
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * This message contains which characters are to be deleted by client.
     * E.g. if current composition and surrounding text are
     *     "この感じは[漢字は]" ("漢字は" is the composition)
     * and we send DeletionRange with offset == -3 and length == 3, then they will
     * be rendered like:
     *     "この[漢字は]"
     * </pre>
     *
     * Protobuf type {@code mozc.commands.DeletionRange}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange, Builder> implements
        // @@protoc_insertion_point(builder_implements:mozc.commands.DeletionRange)
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRangeOrBuilder {
      // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Offset of start of the deletion range.
       * Right now,
       * - Only nagative value is expected.
       *     In this case, the offset is counted from the beginning of the
       *     composition (see the message comment right above).
       * - Positive or 0 value is not sent.
       *     But not forbidden.
       *     Though its expectation is not decided yet,
       *     the client implementation should be prepared (at least, don't crash).
       * </pre>
       *
       * <code>optional int32 offset = 1;</code>
       * @return Whether the offset field is set.
       */
      @java.lang.Override
      public boolean hasOffset() {
        return instance.hasOffset();
      }
      /**
       * <pre>
       * Offset of start of the deletion range.
       * Right now,
       * - Only nagative value is expected.
       *     In this case, the offset is counted from the beginning of the
       *     composition (see the message comment right above).
       * - Positive or 0 value is not sent.
       *     But not forbidden.
       *     Though its expectation is not decided yet,
       *     the client implementation should be prepared (at least, don't crash).
       * </pre>
       *
       * <code>optional int32 offset = 1;</code>
       * @return The offset.
       */
      @java.lang.Override
      public int getOffset() {
        return instance.getOffset();
      }
      /**
       * <pre>
       * Offset of start of the deletion range.
       * Right now,
       * - Only nagative value is expected.
       *     In this case, the offset is counted from the beginning of the
       *     composition (see the message comment right above).
       * - Positive or 0 value is not sent.
       *     But not forbidden.
       *     Though its expectation is not decided yet,
       *     the client implementation should be prepared (at least, don't crash).
       * </pre>
       *
       * <code>optional int32 offset = 1;</code>
       * @param value The offset to set.
       * @return This builder for chaining.
       */
      public Builder setOffset(int value) {
        copyOnWrite();
        instance.setOffset(value);
        return this;
      }
      /**
       * <pre>
       * Offset of start of the deletion range.
       * Right now,
       * - Only nagative value is expected.
       *     In this case, the offset is counted from the beginning of the
       *     composition (see the message comment right above).
       * - Positive or 0 value is not sent.
       *     But not forbidden.
       *     Though its expectation is not decided yet,
       *     the client implementation should be prepared (at least, don't crash).
       * </pre>
       *
       * <code>optional int32 offset = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearOffset() {
        copyOnWrite();
        instance.clearOffset();
        return this;
      }

      /**
       * <pre>
       * Length of the range.
       * Right now offset==abs(length) is expected.
       * The expectation where the above condition doesn't meet
       * is not defined yet.
       * This may be defined in future (when positive offset becomes
       * supported?).
       * </pre>
       *
       * <code>optional int32 length = 2;</code>
       * @return Whether the length field is set.
       */
      @java.lang.Override
      public boolean hasLength() {
        return instance.hasLength();
      }
      /**
       * <pre>
       * Length of the range.
       * Right now offset==abs(length) is expected.
       * The expectation where the above condition doesn't meet
       * is not defined yet.
       * This may be defined in future (when positive offset becomes
       * supported?).
       * </pre>
       *
       * <code>optional int32 length = 2;</code>
       * @return The length.
       */
      @java.lang.Override
      public int getLength() {
        return instance.getLength();
      }
      /**
       * <pre>
       * Length of the range.
       * Right now offset==abs(length) is expected.
       * The expectation where the above condition doesn't meet
       * is not defined yet.
       * This may be defined in future (when positive offset becomes
       * supported?).
       * </pre>
       *
       * <code>optional int32 length = 2;</code>
       * @param value The length to set.
       * @return This builder for chaining.
       */
      public Builder setLength(int value) {
        copyOnWrite();
        instance.setLength(value);
        return this;
      }
      /**
       * <pre>
       * Length of the range.
       * Right now offset==abs(length) is expected.
       * The expectation where the above condition doesn't meet
       * is not defined yet.
       * This may be defined in future (when positive offset becomes
       * supported?).
       * </pre>
       *
       * <code>optional int32 length = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearLength() {
        copyOnWrite();
        instance.clearLength();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:mozc.commands.DeletionRange)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "offset_",
              "length_",
            };
            java.lang.String info =
                "\u0001\u0002\u0000\u0001\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u1004\u0000\u0002" +
                "\u1004\u0001";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange> parser = PARSER;
          if (parser == null) {
            synchronized (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:mozc.commands.DeletionRange)
    private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange DEFAULT_INSTANCE;
    static {
      DeletionRange defaultInstance = new DeletionRange();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        DeletionRange.class, defaultInstance);
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<DeletionRange> PARSER;

    public static com.google.protobuf.Parser<DeletionRange> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface OutputOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mozc.commands.Output)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>optional uint64 id = 1 [jstype = JS_STRING];</code>
     * @return Whether the id field is set.
     */
    boolean hasId();
    /**
     * <code>optional uint64 id = 1 [jstype = JS_STRING];</code>
     * @return The id.
     */
    long getId();

    /**
     * <pre>
     * This variable is going to be obsolete. Please use status(13) instead.
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode mode = 2;</code>
     * @return Whether the mode field is set.
     */
    boolean hasMode();
    /**
     * <pre>
     * This variable is going to be obsolete. Please use status(13) instead.
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode mode = 2;</code>
     * @return The mode.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode getMode();

    /**
     * <code>optional bool consumed = 3;</code>
     * @return Whether the consumed field is set.
     */
    boolean hasConsumed();
    /**
     * <code>optional bool consumed = 3;</code>
     * @return The consumed.
     */
    boolean getConsumed();

    /**
     * <code>optional .mozc.commands.Result result = 4;</code>
     * @return Whether the result field is set.
     */
    boolean hasResult();
    /**
     * <code>optional .mozc.commands.Result result = 4;</code>
     * @return The result.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result getResult();

    /**
     * <code>optional .mozc.commands.Preedit preedit = 5;</code>
     * @return Whether the preedit field is set.
     */
    boolean hasPreedit();
    /**
     * <code>optional .mozc.commands.Preedit preedit = 5;</code>
     * @return The preedit.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit getPreedit();

    /**
     * <code>optional .mozc.commands.CandidateWindow candidate_window = 6;</code>
     * @return Whether the candidateWindow field is set.
     */
    boolean hasCandidateWindow();
    /**
     * <code>optional .mozc.commands.CandidateWindow candidate_window = 6;</code>
     * @return The candidateWindow.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateWindow getCandidateWindow();

    /**
     * <code>optional .mozc.commands.KeyEvent key = 7;</code>
     * @return Whether the key field is set.
     */
    boolean hasKey();
    /**
     * <code>optional .mozc.commands.KeyEvent key = 7;</code>
     * @return The key.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent getKey();

    /**
     * <pre>
     * when URL is non empty, UI can open the page with a browser,
     * after finishing the all rendering part.
     * We are using this feature for bug-report system.
     * </pre>
     *
     * <code>optional string url = 8;</code>
     * @return Whether the url field is set.
     */
    boolean hasUrl();
    /**
     * <pre>
     * when URL is non empty, UI can open the page with a browser,
     * after finishing the all rendering part.
     * We are using this feature for bug-report system.
     * </pre>
     *
     * <code>optional string url = 8;</code>
     * @return The url.
     */
    java.lang.String getUrl();
    /**
     * <pre>
     * when URL is non empty, UI can open the page with a browser,
     * after finishing the all rendering part.
     * We are using this feature for bug-report system.
     * </pre>
     *
     * <code>optional string url = 8;</code>
     * @return The bytes for url.
     */
    com.google.protobuf.ByteString
        getUrlBytes();

    /**
     * <pre>
     * Output config
     * </pre>
     *
     * <code>optional .mozc.config.Config config = 9;</code>
     * @return Whether the config field is set.
     */
    boolean hasConfig();
    /**
     * <pre>
     * Output config
     * </pre>
     *
     * <code>optional .mozc.config.Config config = 9;</code>
     * @return The config.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config getConfig();

    /**
     * <code>optional .mozc.commands.Output.PreeditMethod preedit_method = 10 [default = ASCII];</code>
     * @return Whether the preeditMethod field is set.
     */
    boolean hasPreeditMethod();
    /**
     * <code>optional .mozc.commands.Output.PreeditMethod preedit_method = 10 [default = ASCII];</code>
     * @return The preeditMethod.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.PreeditMethod getPreeditMethod();

    /**
     * <code>optional .mozc.commands.Output.ErrorCode error_code = 11 [default = SESSION_SUCCESS];</code>
     * @return Whether the errorCode field is set.
     */
    boolean hasErrorCode();
    /**
     * <code>optional .mozc.commands.Output.ErrorCode error_code = 11 [default = SESSION_SUCCESS];</code>
     * @return The errorCode.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.ErrorCode getErrorCode();

    /**
     * <pre>
     * The current IME status.
     * </pre>
     *
     * <code>optional .mozc.commands.Status status = 13;</code>
     * @return Whether the status field is set.
     */
    boolean hasStatus();
    /**
     * <pre>
     * The current IME status.
     * </pre>
     *
     * <code>optional .mozc.commands.Status status = 13;</code>
     * @return The status.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status getStatus();

    /**
     * <pre>
     * All flatten candidate words stored in 1D array.  This value is
     * filled only when the content is changed.
     * </pre>
     *
     * <code>optional .mozc.commands.CandidateList all_candidate_words = 14;</code>
     * @return Whether the allCandidateWords field is set.
     */
    boolean hasAllCandidateWords();
    /**
     * <pre>
     * All flatten candidate words stored in 1D array.  This value is
     * filled only when the content is changed.
     * </pre>
     *
     * <code>optional .mozc.commands.CandidateList all_candidate_words = 14;</code>
     * @return The allCandidateWords.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList getAllCandidateWords();

    /**
     * <pre>
     * Range of characters to be deleted by client.
     * </pre>
     *
     * <code>optional .mozc.commands.DeletionRange deletion_range = 16;</code>
     * @return Whether the deletionRange field is set.
     */
    boolean hasDeletionRange();
    /**
     * <pre>
     * Range of characters to be deleted by client.
     * </pre>
     *
     * <code>optional .mozc.commands.DeletionRange deletion_range = 16;</code>
     * @return The deletionRange.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange getDeletionRange();

    /**
     * <code>optional .mozc.commands.Output.ToolMode launch_tool_mode = 17 [default = NO_TOOL];</code>
     * @return Whether the launchToolMode field is set.
     */
    boolean hasLaunchToolMode();
    /**
     * <code>optional .mozc.commands.Output.ToolMode launch_tool_mode = 17 [default = NO_TOOL];</code>
     * @return The launchToolMode.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.ToolMode getLaunchToolMode();

    /**
     * <code>optional .mozc.commands.Output.Callback callback = 18;</code>
     * @return Whether the callback field is set.
     */
    boolean hasCallback();
    /**
     * <code>optional .mozc.commands.Output.Callback callback = 18;</code>
     * @return The callback.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback getCallback();

    /**
     * <code>optional .mozc.EngineReloadResponse engine_reload_response = 22;</code>
     * @return Whether the engineReloadResponse field is set.
     */
    boolean hasEngineReloadResponse();
    /**
     * <code>optional .mozc.EngineReloadResponse engine_reload_response = 22;</code>
     * @return The engineReloadResponse.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadResponse getEngineReloadResponse();

    /**
     * <pre>
     * For debug. Candidate words removed throuth the conversion process.
     * </pre>
     *
     * <code>optional .mozc.commands.CandidateList removed_candidate_words_for_debug = 23;</code>
     * @return Whether the removedCandidateWordsForDebug field is set.
     */
    boolean hasRemovedCandidateWordsForDebug();
    /**
     * <pre>
     * For debug. Candidate words removed throuth the conversion process.
     * </pre>
     *
     * <code>optional .mozc.commands.CandidateList removed_candidate_words_for_debug = 23;</code>
     * @return The removedCandidateWordsForDebug.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList getRemovedCandidateWordsForDebug();

    /**
     * <pre>
     * Candidate words stored in 1D array. The field should be filled without
     * using any personal data.
     * </pre>
     *
     * <code>optional .mozc.commands.CandidateList incognito_candidate_words = 25;</code>
     * @return Whether the incognitoCandidateWords field is set.
     */
    boolean hasIncognitoCandidateWords();
    /**
     * <pre>
     * Candidate words stored in 1D array. The field should be filled without
     * using any personal data.
     * </pre>
     *
     * <code>optional .mozc.commands.CandidateList incognito_candidate_words = 25;</code>
     * @return The incognitoCandidateWords.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList getIncognitoCandidateWords();

    /**
     * <code>optional .mozc.commands.Output.VersionInfo server_version = 26;</code>
     * @return Whether the serverVersion field is set.
     */
    boolean hasServerVersion();
    /**
     * <code>optional .mozc.commands.Output.VersionInfo server_version = 26;</code>
     * @return The serverVersion.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo getServerVersion();
  }
  /**
   * <pre>
   * Next ID: 27
   * </pre>
   *
   * Protobuf type {@code mozc.commands.Output}
   */
  public  static final class Output extends
      com.google.protobuf.GeneratedMessageLite<
          Output, Output.Builder> implements
      // @@protoc_insertion_point(message_implements:mozc.commands.Output)
      OutputOrBuilder {
    private Output() {
      url_ = "";
    }
    /**
     * <pre>
     * PreeditMethod: this is the default input mode of the session.
     * If the user's config is "kana-input", it returns KANA.  Only
     * CreateSession response will have this field.
     * </pre>
     *
     * Protobuf enum {@code mozc.commands.Output.PreeditMethod}
     */
    public enum PreeditMethod
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>ASCII = 0;</code>
       */
      ASCII(0),
      /**
       * <code>KANA = 1;</code>
       */
      KANA(1),
      ;

      /**
       * <code>ASCII = 0;</code>
       */
      public static final int ASCII_VALUE = 0;
      /**
       * <code>KANA = 1;</code>
       */
      public static final int KANA_VALUE = 1;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static PreeditMethod valueOf(int value) {
        return forNumber(value);
      }

      public static PreeditMethod forNumber(int value) {
        switch (value) {
          case 0: return ASCII;
          case 1: return KANA;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<PreeditMethod>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          PreeditMethod> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<PreeditMethod>() {
              @java.lang.Override
              public PreeditMethod findValueByNumber(int number) {
                return PreeditMethod.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return PreeditMethodVerifier.INSTANCE;
      }

      private static final class PreeditMethodVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new PreeditMethodVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return PreeditMethod.forNumber(number) != null;
              }
            };

      private final int value;

      private PreeditMethod(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.commands.Output.PreeditMethod)
    }

    /**
     * <pre>
     * ErrorCode:
     * if SessionHandler::EvalCommand() returns false,
     * return output with error_code = SESSION_FAILURE;
     * </pre>
     *
     * Protobuf enum {@code mozc.commands.Output.ErrorCode}
     */
    public enum ErrorCode
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>SESSION_SUCCESS = 0;</code>
       */
      SESSION_SUCCESS(0),
      /**
       * <code>SESSION_FAILURE = 1;</code>
       */
      SESSION_FAILURE(1),
      ;

      /**
       * <code>SESSION_SUCCESS = 0;</code>
       */
      public static final int SESSION_SUCCESS_VALUE = 0;
      /**
       * <code>SESSION_FAILURE = 1;</code>
       */
      public static final int SESSION_FAILURE_VALUE = 1;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static ErrorCode valueOf(int value) {
        return forNumber(value);
      }

      public static ErrorCode forNumber(int value) {
        switch (value) {
          case 0: return SESSION_SUCCESS;
          case 1: return SESSION_FAILURE;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<ErrorCode>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          ErrorCode> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<ErrorCode>() {
              @java.lang.Override
              public ErrorCode findValueByNumber(int number) {
                return ErrorCode.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return ErrorCodeVerifier.INSTANCE;
      }

      private static final class ErrorCodeVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new ErrorCodeVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return ErrorCode.forNumber(number) != null;
              }
            };

      private final int value;

      private ErrorCode(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.commands.Output.ErrorCode)
    }

    /**
     * <pre>
     * if launch_tool_mode is set, MozcTool is supposed to be launched
     * by client.
     * </pre>
     *
     * Protobuf enum {@code mozc.commands.Output.ToolMode}
     */
    public enum ToolMode
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <pre>
       * no need to launch tool
       * </pre>
       *
       * <code>NO_TOOL = 0;</code>
       */
      NO_TOOL(0),
      /**
       * <code>CONFIG_DIALOG = 1;</code>
       */
      CONFIG_DIALOG(1),
      /**
       * <code>DICTIONARY_TOOL = 2;</code>
       */
      DICTIONARY_TOOL(2),
      /**
       * <code>WORD_REGISTER_DIALOG = 3;</code>
       */
      WORD_REGISTER_DIALOG(3),
      ;

      /**
       * <pre>
       * no need to launch tool
       * </pre>
       *
       * <code>NO_TOOL = 0;</code>
       */
      public static final int NO_TOOL_VALUE = 0;
      /**
       * <code>CONFIG_DIALOG = 1;</code>
       */
      public static final int CONFIG_DIALOG_VALUE = 1;
      /**
       * <code>DICTIONARY_TOOL = 2;</code>
       */
      public static final int DICTIONARY_TOOL_VALUE = 2;
      /**
       * <code>WORD_REGISTER_DIALOG = 3;</code>
       */
      public static final int WORD_REGISTER_DIALOG_VALUE = 3;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static ToolMode valueOf(int value) {
        return forNumber(value);
      }

      public static ToolMode forNumber(int value) {
        switch (value) {
          case 0: return NO_TOOL;
          case 1: return CONFIG_DIALOG;
          case 2: return DICTIONARY_TOOL;
          case 3: return WORD_REGISTER_DIALOG;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<ToolMode>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          ToolMode> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<ToolMode>() {
              @java.lang.Override
              public ToolMode findValueByNumber(int number) {
                return ToolMode.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return ToolModeVerifier.INSTANCE;
      }

      private static final class ToolModeVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new ToolModeVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return ToolMode.forNumber(number) != null;
              }
            };

      private final int value;

      private ToolMode(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.commands.Output.ToolMode)
    }

    public interface CallbackOrBuilder extends
        // @@protoc_insertion_point(interface_extends:mozc.commands.Output.Callback)
        com.google.protobuf.MessageLiteOrBuilder {

      /**
       * <pre>
       * Callback command to be sent from the client to the server.  The
       * optional values such as id and composition_mode can be modified
       * or added by the client.
       * </pre>
       *
       * <code>optional .mozc.commands.SessionCommand session_command = 1;</code>
       * @return Whether the sessionCommand field is set.
       */
      boolean hasSessionCommand();
      /**
       * <pre>
       * Callback command to be sent from the client to the server.  The
       * optional values such as id and composition_mode can be modified
       * or added by the client.
       * </pre>
       *
       * <code>optional .mozc.commands.SessionCommand session_command = 1;</code>
       * @return The sessionCommand.
       */
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand getSessionCommand();

      /**
       * <pre>
       * Callback command should be sent after this delay.
       * </pre>
       *
       * <code>optional uint32 delay_millisec = 2;</code>
       * @return Whether the delayMillisec field is set.
       */
      boolean hasDelayMillisec();
      /**
       * <pre>
       * Callback command should be sent after this delay.
       * </pre>
       *
       * <code>optional uint32 delay_millisec = 2;</code>
       * @return The delayMillisec.
       */
      int getDelayMillisec();
    }
    /**
     * <pre>
     * Callback request to the client.
     * </pre>
     *
     * Protobuf type {@code mozc.commands.Output.Callback}
     */
    public  static final class Callback extends
        com.google.protobuf.GeneratedMessageLite<
            Callback, Callback.Builder> implements
        // @@protoc_insertion_point(message_implements:mozc.commands.Output.Callback)
        CallbackOrBuilder {
      private Callback() {
      }
      private int bitField0_;
      public static final int SESSION_COMMAND_FIELD_NUMBER = 1;
      private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand sessionCommand_;
      /**
       * <pre>
       * Callback command to be sent from the client to the server.  The
       * optional values such as id and composition_mode can be modified
       * or added by the client.
       * </pre>
       *
       * <code>optional .mozc.commands.SessionCommand session_command = 1;</code>
       */
      @java.lang.Override
      public boolean hasSessionCommand() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Callback command to be sent from the client to the server.  The
       * optional values such as id and composition_mode can be modified
       * or added by the client.
       * </pre>
       *
       * <code>optional .mozc.commands.SessionCommand session_command = 1;</code>
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand getSessionCommand() {
        return sessionCommand_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.getDefaultInstance() : sessionCommand_;
      }
      /**
       * <pre>
       * Callback command to be sent from the client to the server.  The
       * optional values such as id and composition_mode can be modified
       * or added by the client.
       * </pre>
       *
       * <code>optional .mozc.commands.SessionCommand session_command = 1;</code>
       */
      private void setSessionCommand(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand value) {
        value.getClass();
  sessionCommand_ = value;
        bitField0_ |= 0x00000001;
        }
      /**
       * <pre>
       * Callback command to be sent from the client to the server.  The
       * optional values such as id and composition_mode can be modified
       * or added by the client.
       * </pre>
       *
       * <code>optional .mozc.commands.SessionCommand session_command = 1;</code>
       */
      @java.lang.SuppressWarnings({"ReferenceEquality"})
      private void mergeSessionCommand(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand value) {
        value.getClass();
  if (sessionCommand_ != null &&
            sessionCommand_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.getDefaultInstance()) {
          sessionCommand_ =
            org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.newBuilder(sessionCommand_).mergeFrom(value).buildPartial();
        } else {
          sessionCommand_ = value;
        }
        bitField0_ |= 0x00000001;
      }
      /**
       * <pre>
       * Callback command to be sent from the client to the server.  The
       * optional values such as id and composition_mode can be modified
       * or added by the client.
       * </pre>
       *
       * <code>optional .mozc.commands.SessionCommand session_command = 1;</code>
       */
      private void clearSessionCommand() {  sessionCommand_ = null;
        bitField0_ = (bitField0_ & ~0x00000001);
      }

      public static final int DELAY_MILLISEC_FIELD_NUMBER = 2;
      private int delayMillisec_;
      /**
       * <pre>
       * Callback command should be sent after this delay.
       * </pre>
       *
       * <code>optional uint32 delay_millisec = 2;</code>
       * @return Whether the delayMillisec field is set.
       */
      @java.lang.Override
      public boolean hasDelayMillisec() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Callback command should be sent after this delay.
       * </pre>
       *
       * <code>optional uint32 delay_millisec = 2;</code>
       * @return The delayMillisec.
       */
      @java.lang.Override
      public int getDelayMillisec() {
        return delayMillisec_;
      }
      /**
       * <pre>
       * Callback command should be sent after this delay.
       * </pre>
       *
       * <code>optional uint32 delay_millisec = 2;</code>
       * @param value The delayMillisec to set.
       */
      private void setDelayMillisec(int value) {
        bitField0_ |= 0x00000002;
        delayMillisec_ = value;
      }
      /**
       * <pre>
       * Callback command should be sent after this delay.
       * </pre>
       *
       * <code>optional uint32 delay_millisec = 2;</code>
       */
      private void clearDelayMillisec() {
        bitField0_ = (bitField0_ & ~0x00000002);
        delayMillisec_ = 0;
      }

      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }

      public static Builder newBuilder() {
        return (Builder) DEFAULT_INSTANCE.createBuilder();
      }
      public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback prototype) {
        return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
      }

      /**
       * <pre>
       * Callback request to the client.
       * </pre>
       *
       * Protobuf type {@code mozc.commands.Output.Callback}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageLite.Builder<
            org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback, Builder> implements
          // @@protoc_insertion_point(builder_implements:mozc.commands.Output.Callback)
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.CallbackOrBuilder {
        // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback.newBuilder()
        private Builder() {
          super(DEFAULT_INSTANCE);
        }


        /**
         * <pre>
         * Callback command to be sent from the client to the server.  The
         * optional values such as id and composition_mode can be modified
         * or added by the client.
         * </pre>
         *
         * <code>optional .mozc.commands.SessionCommand session_command = 1;</code>
         */
        @java.lang.Override
        public boolean hasSessionCommand() {
          return instance.hasSessionCommand();
        }
        /**
         * <pre>
         * Callback command to be sent from the client to the server.  The
         * optional values such as id and composition_mode can be modified
         * or added by the client.
         * </pre>
         *
         * <code>optional .mozc.commands.SessionCommand session_command = 1;</code>
         */
        @java.lang.Override
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand getSessionCommand() {
          return instance.getSessionCommand();
        }
        /**
         * <pre>
         * Callback command to be sent from the client to the server.  The
         * optional values such as id and composition_mode can be modified
         * or added by the client.
         * </pre>
         *
         * <code>optional .mozc.commands.SessionCommand session_command = 1;</code>
         */
        public Builder setSessionCommand(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand value) {
          copyOnWrite();
          instance.setSessionCommand(value);
          return this;
          }
        /**
         * <pre>
         * Callback command to be sent from the client to the server.  The
         * optional values such as id and composition_mode can be modified
         * or added by the client.
         * </pre>
         *
         * <code>optional .mozc.commands.SessionCommand session_command = 1;</code>
         */
        public Builder setSessionCommand(
            org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.Builder builderForValue) {
          copyOnWrite();
          instance.setSessionCommand(builderForValue.build());
          return this;
        }
        /**
         * <pre>
         * Callback command to be sent from the client to the server.  The
         * optional values such as id and composition_mode can be modified
         * or added by the client.
         * </pre>
         *
         * <code>optional .mozc.commands.SessionCommand session_command = 1;</code>
         */
        public Builder mergeSessionCommand(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand value) {
          copyOnWrite();
          instance.mergeSessionCommand(value);
          return this;
        }
        /**
         * <pre>
         * Callback command to be sent from the client to the server.  The
         * optional values such as id and composition_mode can be modified
         * or added by the client.
         * </pre>
         *
         * <code>optional .mozc.commands.SessionCommand session_command = 1;</code>
         */
        public Builder clearSessionCommand() {  copyOnWrite();
          instance.clearSessionCommand();
          return this;
        }

        /**
         * <pre>
         * Callback command should be sent after this delay.
         * </pre>
         *
         * <code>optional uint32 delay_millisec = 2;</code>
         * @return Whether the delayMillisec field is set.
         */
        @java.lang.Override
        public boolean hasDelayMillisec() {
          return instance.hasDelayMillisec();
        }
        /**
         * <pre>
         * Callback command should be sent after this delay.
         * </pre>
         *
         * <code>optional uint32 delay_millisec = 2;</code>
         * @return The delayMillisec.
         */
        @java.lang.Override
        public int getDelayMillisec() {
          return instance.getDelayMillisec();
        }
        /**
         * <pre>
         * Callback command should be sent after this delay.
         * </pre>
         *
         * <code>optional uint32 delay_millisec = 2;</code>
         * @param value The delayMillisec to set.
         * @return This builder for chaining.
         */
        public Builder setDelayMillisec(int value) {
          copyOnWrite();
          instance.setDelayMillisec(value);
          return this;
        }
        /**
         * <pre>
         * Callback command should be sent after this delay.
         * </pre>
         *
         * <code>optional uint32 delay_millisec = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearDelayMillisec() {
          copyOnWrite();
          instance.clearDelayMillisec();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:mozc.commands.Output.Callback)
      }
      private byte memoizedIsInitialized = 2;
      @java.lang.Override
      @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
      protected final java.lang.Object dynamicMethod(
          com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
          java.lang.Object arg0, java.lang.Object arg1) {
        switch (method) {
          case NEW_MUTABLE_INSTANCE: {
            return new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback();
          }
          case NEW_BUILDER: {
            return new Builder();
          }
          case BUILD_MESSAGE_INFO: {
              java.lang.Object[] objects = new java.lang.Object[] {
                "bitField0_",
                "sessionCommand_",
                "delayMillisec_",
              };
              java.lang.String info =
                  "\u0001\u0002\u0000\u0001\u0001\u0002\u0002\u0000\u0000\u0001\u0001\u1409\u0000\u0002" +
                  "\u100b\u0001";
              return newMessageInfo(DEFAULT_INSTANCE, info, objects);
          }
          // fall through
          case GET_DEFAULT_INSTANCE: {
            return DEFAULT_INSTANCE;
          }
          case GET_PARSER: {
            com.google.protobuf.Parser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback> parser = PARSER;
            if (parser == null) {
              synchronized (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback.class) {
                parser = PARSER;
                if (parser == null) {
                  parser =
                      new DefaultInstanceBasedParser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback>(
                          DEFAULT_INSTANCE);
                  PARSER = parser;
                }
              }
            }
            return parser;
        }
        case GET_MEMOIZED_IS_INITIALIZED: {
          return memoizedIsInitialized;
        }
        case SET_MEMOIZED_IS_INITIALIZED: {
          memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
          return null;
        }
        }
        throw new UnsupportedOperationException();
      }


      // @@protoc_insertion_point(class_scope:mozc.commands.Output.Callback)
      private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback DEFAULT_INSTANCE;
      static {
        Callback defaultInstance = new Callback();
        // New instances are implicitly immutable so no need to make
        // immutable.
        DEFAULT_INSTANCE = defaultInstance;
        com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
          Callback.class, defaultInstance);
      }

      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static volatile com.google.protobuf.Parser<Callback> PARSER;

      public static com.google.protobuf.Parser<Callback> parser() {
        return DEFAULT_INSTANCE.getParserForType();
      }
    }

    public interface VersionInfoOrBuilder extends
        // @@protoc_insertion_point(interface_extends:mozc.commands.Output.VersionInfo)
        com.google.protobuf.MessageLiteOrBuilder {

      /**
       * <code>optional string mozc_version = 1;</code>
       * @return Whether the mozcVersion field is set.
       */
      boolean hasMozcVersion();
      /**
       * <code>optional string mozc_version = 1;</code>
       * @return The mozcVersion.
       */
      java.lang.String getMozcVersion();
      /**
       * <code>optional string mozc_version = 1;</code>
       * @return The bytes for mozcVersion.
       */
      com.google.protobuf.ByteString
          getMozcVersionBytes();

      /**
       * <code>optional string data_version = 2;</code>
       * @return Whether the dataVersion field is set.
       */
      boolean hasDataVersion();
      /**
       * <code>optional string data_version = 2;</code>
       * @return The dataVersion.
       */
      java.lang.String getDataVersion();
      /**
       * <code>optional string data_version = 2;</code>
       * @return The bytes for dataVersion.
       */
      com.google.protobuf.ByteString
          getDataVersionBytes();
    }
    /**
     * Protobuf type {@code mozc.commands.Output.VersionInfo}
     */
    public  static final class VersionInfo extends
        com.google.protobuf.GeneratedMessageLite<
            VersionInfo, VersionInfo.Builder> implements
        // @@protoc_insertion_point(message_implements:mozc.commands.Output.VersionInfo)
        VersionInfoOrBuilder {
      private VersionInfo() {
        mozcVersion_ = "";
        dataVersion_ = "";
      }
      private int bitField0_;
      public static final int MOZC_VERSION_FIELD_NUMBER = 1;
      private java.lang.String mozcVersion_;
      /**
       * <code>optional string mozc_version = 1;</code>
       * @return Whether the mozcVersion field is set.
       */
      @java.lang.Override
      public boolean hasMozcVersion() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional string mozc_version = 1;</code>
       * @return The mozcVersion.
       */
      @java.lang.Override
      public java.lang.String getMozcVersion() {
        return mozcVersion_;
      }
      /**
       * <code>optional string mozc_version = 1;</code>
       * @return The bytes for mozcVersion.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getMozcVersionBytes() {
        return com.google.protobuf.ByteString.copyFromUtf8(mozcVersion_);
      }
      /**
       * <code>optional string mozc_version = 1;</code>
       * @param value The mozcVersion to set.
       */
      private void setMozcVersion(
          java.lang.String value) {
        java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000001;
        mozcVersion_ = value;
      }
      /**
       * <code>optional string mozc_version = 1;</code>
       */
      private void clearMozcVersion() {
        bitField0_ = (bitField0_ & ~0x00000001);
        mozcVersion_ = getDefaultInstance().getMozcVersion();
      }
      /**
       * <code>optional string mozc_version = 1;</code>
       * @param value The bytes for mozcVersion to set.
       */
      private void setMozcVersionBytes(
          com.google.protobuf.ByteString value) {
        mozcVersion_ = value.toStringUtf8();
        bitField0_ |= 0x00000001;
      }

      public static final int DATA_VERSION_FIELD_NUMBER = 2;
      private java.lang.String dataVersion_;
      /**
       * <code>optional string data_version = 2;</code>
       * @return Whether the dataVersion field is set.
       */
      @java.lang.Override
      public boolean hasDataVersion() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional string data_version = 2;</code>
       * @return The dataVersion.
       */
      @java.lang.Override
      public java.lang.String getDataVersion() {
        return dataVersion_;
      }
      /**
       * <code>optional string data_version = 2;</code>
       * @return The bytes for dataVersion.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getDataVersionBytes() {
        return com.google.protobuf.ByteString.copyFromUtf8(dataVersion_);
      }
      /**
       * <code>optional string data_version = 2;</code>
       * @param value The dataVersion to set.
       */
      private void setDataVersion(
          java.lang.String value) {
        java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000002;
        dataVersion_ = value;
      }
      /**
       * <code>optional string data_version = 2;</code>
       */
      private void clearDataVersion() {
        bitField0_ = (bitField0_ & ~0x00000002);
        dataVersion_ = getDefaultInstance().getDataVersion();
      }
      /**
       * <code>optional string data_version = 2;</code>
       * @param value The bytes for dataVersion to set.
       */
      private void setDataVersionBytes(
          com.google.protobuf.ByteString value) {
        dataVersion_ = value.toStringUtf8();
        bitField0_ |= 0x00000002;
      }

      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }

      public static Builder newBuilder() {
        return (Builder) DEFAULT_INSTANCE.createBuilder();
      }
      public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo prototype) {
        return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
      }

      /**
       * Protobuf type {@code mozc.commands.Output.VersionInfo}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageLite.Builder<
            org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo, Builder> implements
          // @@protoc_insertion_point(builder_implements:mozc.commands.Output.VersionInfo)
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfoOrBuilder {
        // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo.newBuilder()
        private Builder() {
          super(DEFAULT_INSTANCE);
        }


        /**
         * <code>optional string mozc_version = 1;</code>
         * @return Whether the mozcVersion field is set.
         */
        @java.lang.Override
        public boolean hasMozcVersion() {
          return instance.hasMozcVersion();
        }
        /**
         * <code>optional string mozc_version = 1;</code>
         * @return The mozcVersion.
         */
        @java.lang.Override
        public java.lang.String getMozcVersion() {
          return instance.getMozcVersion();
        }
        /**
         * <code>optional string mozc_version = 1;</code>
         * @return The bytes for mozcVersion.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
            getMozcVersionBytes() {
          return instance.getMozcVersionBytes();
        }
        /**
         * <code>optional string mozc_version = 1;</code>
         * @param value The mozcVersion to set.
         * @return This builder for chaining.
         */
        public Builder setMozcVersion(
            java.lang.String value) {
          copyOnWrite();
          instance.setMozcVersion(value);
          return this;
        }
        /**
         * <code>optional string mozc_version = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearMozcVersion() {
          copyOnWrite();
          instance.clearMozcVersion();
          return this;
        }
        /**
         * <code>optional string mozc_version = 1;</code>
         * @param value The bytes for mozcVersion to set.
         * @return This builder for chaining.
         */
        public Builder setMozcVersionBytes(
            com.google.protobuf.ByteString value) {
          copyOnWrite();
          instance.setMozcVersionBytes(value);
          return this;
        }

        /**
         * <code>optional string data_version = 2;</code>
         * @return Whether the dataVersion field is set.
         */
        @java.lang.Override
        public boolean hasDataVersion() {
          return instance.hasDataVersion();
        }
        /**
         * <code>optional string data_version = 2;</code>
         * @return The dataVersion.
         */
        @java.lang.Override
        public java.lang.String getDataVersion() {
          return instance.getDataVersion();
        }
        /**
         * <code>optional string data_version = 2;</code>
         * @return The bytes for dataVersion.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
            getDataVersionBytes() {
          return instance.getDataVersionBytes();
        }
        /**
         * <code>optional string data_version = 2;</code>
         * @param value The dataVersion to set.
         * @return This builder for chaining.
         */
        public Builder setDataVersion(
            java.lang.String value) {
          copyOnWrite();
          instance.setDataVersion(value);
          return this;
        }
        /**
         * <code>optional string data_version = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearDataVersion() {
          copyOnWrite();
          instance.clearDataVersion();
          return this;
        }
        /**
         * <code>optional string data_version = 2;</code>
         * @param value The bytes for dataVersion to set.
         * @return This builder for chaining.
         */
        public Builder setDataVersionBytes(
            com.google.protobuf.ByteString value) {
          copyOnWrite();
          instance.setDataVersionBytes(value);
          return this;
        }

        // @@protoc_insertion_point(builder_scope:mozc.commands.Output.VersionInfo)
      }
      @java.lang.Override
      @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
      protected final java.lang.Object dynamicMethod(
          com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
          java.lang.Object arg0, java.lang.Object arg1) {
        switch (method) {
          case NEW_MUTABLE_INSTANCE: {
            return new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo();
          }
          case NEW_BUILDER: {
            return new Builder();
          }
          case BUILD_MESSAGE_INFO: {
              java.lang.Object[] objects = new java.lang.Object[] {
                "bitField0_",
                "mozcVersion_",
                "dataVersion_",
              };
              java.lang.String info =
                  "\u0001\u0002\u0000\u0001\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u1008\u0000\u0002" +
                  "\u1008\u0001";
              return newMessageInfo(DEFAULT_INSTANCE, info, objects);
          }
          // fall through
          case GET_DEFAULT_INSTANCE: {
            return DEFAULT_INSTANCE;
          }
          case GET_PARSER: {
            com.google.protobuf.Parser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo> parser = PARSER;
            if (parser == null) {
              synchronized (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo.class) {
                parser = PARSER;
                if (parser == null) {
                  parser =
                      new DefaultInstanceBasedParser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo>(
                          DEFAULT_INSTANCE);
                  PARSER = parser;
                }
              }
            }
            return parser;
        }
        case GET_MEMOIZED_IS_INITIALIZED: {
          return (byte) 1;
        }
        case SET_MEMOIZED_IS_INITIALIZED: {
          return null;
        }
        }
        throw new UnsupportedOperationException();
      }


      // @@protoc_insertion_point(class_scope:mozc.commands.Output.VersionInfo)
      private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo DEFAULT_INSTANCE;
      static {
        VersionInfo defaultInstance = new VersionInfo();
        // New instances are implicitly immutable so no need to make
        // immutable.
        DEFAULT_INSTANCE = defaultInstance;
        com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
          VersionInfo.class, defaultInstance);
      }

      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static volatile com.google.protobuf.Parser<VersionInfo> PARSER;

      public static com.google.protobuf.Parser<VersionInfo> parser() {
        return DEFAULT_INSTANCE.getParserForType();
      }
    }

    private int bitField0_;
    public static final int ID_FIELD_NUMBER = 1;
    private long id_;
    /**
     * <code>optional uint64 id = 1 [jstype = JS_STRING];</code>
     * @return Whether the id field is set.
     */
    @java.lang.Override
    public boolean hasId() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional uint64 id = 1 [jstype = JS_STRING];</code>
     * @return The id.
     */
    @java.lang.Override
    public long getId() {
      return id_;
    }
    /**
     * <code>optional uint64 id = 1 [jstype = JS_STRING];</code>
     * @param value The id to set.
     */
    private void setId(long value) {
      bitField0_ |= 0x00000001;
      id_ = value;
    }
    /**
     * <code>optional uint64 id = 1 [jstype = JS_STRING];</code>
     */
    private void clearId() {
      bitField0_ = (bitField0_ & ~0x00000001);
      id_ = 0L;
    }

    public static final int MODE_FIELD_NUMBER = 2;
    private int mode_;
    /**
     * <pre>
     * This variable is going to be obsolete. Please use status(13) instead.
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode mode = 2;</code>
     * @return Whether the mode field is set.
     */
    @java.lang.Override
    public boolean hasMode() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * This variable is going to be obsolete. Please use status(13) instead.
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode mode = 2;</code>
     * @return The mode.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode getMode() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode.forNumber(mode_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode.DIRECT : result;
    }
    /**
     * <pre>
     * This variable is going to be obsolete. Please use status(13) instead.
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode mode = 2;</code>
     * @param value The mode to set.
     */
    private void setMode(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode value) {
      mode_ = value.getNumber();
      bitField0_ |= 0x00000002;
    }
    /**
     * <pre>
     * This variable is going to be obsolete. Please use status(13) instead.
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode mode = 2;</code>
     */
    private void clearMode() {
      bitField0_ = (bitField0_ & ~0x00000002);
      mode_ = 0;
    }

    public static final int CONSUMED_FIELD_NUMBER = 3;
    private boolean consumed_;
    /**
     * <code>optional bool consumed = 3;</code>
     * @return Whether the consumed field is set.
     */
    @java.lang.Override
    public boolean hasConsumed() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <code>optional bool consumed = 3;</code>
     * @return The consumed.
     */
    @java.lang.Override
    public boolean getConsumed() {
      return consumed_;
    }
    /**
     * <code>optional bool consumed = 3;</code>
     * @param value The consumed to set.
     */
    private void setConsumed(boolean value) {
      bitField0_ |= 0x00000004;
      consumed_ = value;
    }
    /**
     * <code>optional bool consumed = 3;</code>
     */
    private void clearConsumed() {
      bitField0_ = (bitField0_ & ~0x00000004);
      consumed_ = false;
    }

    public static final int RESULT_FIELD_NUMBER = 4;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result result_;
    /**
     * <code>optional .mozc.commands.Result result = 4;</code>
     */
    @java.lang.Override
    public boolean hasResult() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <code>optional .mozc.commands.Result result = 4;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result getResult() {
      return result_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.getDefaultInstance() : result_;
    }
    /**
     * <code>optional .mozc.commands.Result result = 4;</code>
     */
    private void setResult(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result value) {
      value.getClass();
  result_ = value;
      bitField0_ |= 0x00000008;
      }
    /**
     * <code>optional .mozc.commands.Result result = 4;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeResult(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result value) {
      value.getClass();
  if (result_ != null &&
          result_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.getDefaultInstance()) {
        result_ =
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.newBuilder(result_).mergeFrom(value).buildPartial();
      } else {
        result_ = value;
      }
      bitField0_ |= 0x00000008;
    }
    /**
     * <code>optional .mozc.commands.Result result = 4;</code>
     */
    private void clearResult() {  result_ = null;
      bitField0_ = (bitField0_ & ~0x00000008);
    }

    public static final int PREEDIT_FIELD_NUMBER = 5;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit preedit_;
    /**
     * <code>optional .mozc.commands.Preedit preedit = 5;</code>
     */
    @java.lang.Override
    public boolean hasPreedit() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <code>optional .mozc.commands.Preedit preedit = 5;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit getPreedit() {
      return preedit_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.getDefaultInstance() : preedit_;
    }
    /**
     * <code>optional .mozc.commands.Preedit preedit = 5;</code>
     */
    private void setPreedit(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit value) {
      value.getClass();
  preedit_ = value;
      bitField0_ |= 0x00000010;
      }
    /**
     * <code>optional .mozc.commands.Preedit preedit = 5;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergePreedit(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit value) {
      value.getClass();
  if (preedit_ != null &&
          preedit_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.getDefaultInstance()) {
        preedit_ =
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.newBuilder(preedit_).mergeFrom(value).buildPartial();
      } else {
        preedit_ = value;
      }
      bitField0_ |= 0x00000010;
    }
    /**
     * <code>optional .mozc.commands.Preedit preedit = 5;</code>
     */
    private void clearPreedit() {  preedit_ = null;
      bitField0_ = (bitField0_ & ~0x00000010);
    }

    public static final int CANDIDATE_WINDOW_FIELD_NUMBER = 6;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateWindow candidateWindow_;
    /**
     * <code>optional .mozc.commands.CandidateWindow candidate_window = 6;</code>
     */
    @java.lang.Override
    public boolean hasCandidateWindow() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <code>optional .mozc.commands.CandidateWindow candidate_window = 6;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateWindow getCandidateWindow() {
      return candidateWindow_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateWindow.getDefaultInstance() : candidateWindow_;
    }
    /**
     * <code>optional .mozc.commands.CandidateWindow candidate_window = 6;</code>
     */
    private void setCandidateWindow(org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateWindow value) {
      value.getClass();
  candidateWindow_ = value;
      bitField0_ |= 0x00000020;
      }
    /**
     * <code>optional .mozc.commands.CandidateWindow candidate_window = 6;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeCandidateWindow(org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateWindow value) {
      value.getClass();
  if (candidateWindow_ != null &&
          candidateWindow_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateWindow.getDefaultInstance()) {
        candidateWindow_ =
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateWindow.newBuilder(candidateWindow_).mergeFrom(value).buildPartial();
      } else {
        candidateWindow_ = value;
      }
      bitField0_ |= 0x00000020;
    }
    /**
     * <code>optional .mozc.commands.CandidateWindow candidate_window = 6;</code>
     */
    private void clearCandidateWindow() {  candidateWindow_ = null;
      bitField0_ = (bitField0_ & ~0x00000020);
    }

    public static final int KEY_FIELD_NUMBER = 7;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent key_;
    /**
     * <code>optional .mozc.commands.KeyEvent key = 7;</code>
     */
    @java.lang.Override
    public boolean hasKey() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <code>optional .mozc.commands.KeyEvent key = 7;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent getKey() {
      return key_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.getDefaultInstance() : key_;
    }
    /**
     * <code>optional .mozc.commands.KeyEvent key = 7;</code>
     */
    private void setKey(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent value) {
      value.getClass();
  key_ = value;
      bitField0_ |= 0x00000040;
      }
    /**
     * <code>optional .mozc.commands.KeyEvent key = 7;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeKey(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent value) {
      value.getClass();
  if (key_ != null &&
          key_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.getDefaultInstance()) {
        key_ =
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.newBuilder(key_).mergeFrom(value).buildPartial();
      } else {
        key_ = value;
      }
      bitField0_ |= 0x00000040;
    }
    /**
     * <code>optional .mozc.commands.KeyEvent key = 7;</code>
     */
    private void clearKey() {  key_ = null;
      bitField0_ = (bitField0_ & ~0x00000040);
    }

    public static final int URL_FIELD_NUMBER = 8;
    private java.lang.String url_;
    /**
     * <pre>
     * when URL is non empty, UI can open the page with a browser,
     * after finishing the all rendering part.
     * We are using this feature for bug-report system.
     * </pre>
     *
     * <code>optional string url = 8;</code>
     * @return Whether the url field is set.
     */
    @java.lang.Override
    public boolean hasUrl() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * when URL is non empty, UI can open the page with a browser,
     * after finishing the all rendering part.
     * We are using this feature for bug-report system.
     * </pre>
     *
     * <code>optional string url = 8;</code>
     * @return The url.
     */
    @java.lang.Override
    public java.lang.String getUrl() {
      return url_;
    }
    /**
     * <pre>
     * when URL is non empty, UI can open the page with a browser,
     * after finishing the all rendering part.
     * We are using this feature for bug-report system.
     * </pre>
     *
     * <code>optional string url = 8;</code>
     * @return The bytes for url.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getUrlBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(url_);
    }
    /**
     * <pre>
     * when URL is non empty, UI can open the page with a browser,
     * after finishing the all rendering part.
     * We are using this feature for bug-report system.
     * </pre>
     *
     * <code>optional string url = 8;</code>
     * @param value The url to set.
     */
    private void setUrl(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000080;
      url_ = value;
    }
    /**
     * <pre>
     * when URL is non empty, UI can open the page with a browser,
     * after finishing the all rendering part.
     * We are using this feature for bug-report system.
     * </pre>
     *
     * <code>optional string url = 8;</code>
     */
    private void clearUrl() {
      bitField0_ = (bitField0_ & ~0x00000080);
      url_ = getDefaultInstance().getUrl();
    }
    /**
     * <pre>
     * when URL is non empty, UI can open the page with a browser,
     * after finishing the all rendering part.
     * We are using this feature for bug-report system.
     * </pre>
     *
     * <code>optional string url = 8;</code>
     * @param value The bytes for url to set.
     */
    private void setUrlBytes(
        com.google.protobuf.ByteString value) {
      url_ = value.toStringUtf8();
      bitField0_ |= 0x00000080;
    }

    public static final int CONFIG_FIELD_NUMBER = 9;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config config_;
    /**
     * <pre>
     * Output config
     * </pre>
     *
     * <code>optional .mozc.config.Config config = 9;</code>
     */
    @java.lang.Override
    public boolean hasConfig() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * Output config
     * </pre>
     *
     * <code>optional .mozc.config.Config config = 9;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config getConfig() {
      return config_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDefaultInstance() : config_;
    }
    /**
     * <pre>
     * Output config
     * </pre>
     *
     * <code>optional .mozc.config.Config config = 9;</code>
     */
    private void setConfig(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config value) {
      value.getClass();
  config_ = value;
      bitField0_ |= 0x00000100;
      }
    /**
     * <pre>
     * Output config
     * </pre>
     *
     * <code>optional .mozc.config.Config config = 9;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeConfig(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config value) {
      value.getClass();
  if (config_ != null &&
          config_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDefaultInstance()) {
        config_ =
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.newBuilder(config_).mergeFrom(value).buildPartial();
      } else {
        config_ = value;
      }
      bitField0_ |= 0x00000100;
    }
    /**
     * <pre>
     * Output config
     * </pre>
     *
     * <code>optional .mozc.config.Config config = 9;</code>
     */
    private void clearConfig() {  config_ = null;
      bitField0_ = (bitField0_ & ~0x00000100);
    }

    public static final int PREEDIT_METHOD_FIELD_NUMBER = 10;
    private int preeditMethod_;
    /**
     * <code>optional .mozc.commands.Output.PreeditMethod preedit_method = 10 [default = ASCII];</code>
     * @return Whether the preeditMethod field is set.
     */
    @java.lang.Override
    public boolean hasPreeditMethod() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <code>optional .mozc.commands.Output.PreeditMethod preedit_method = 10 [default = ASCII];</code>
     * @return The preeditMethod.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.PreeditMethod getPreeditMethod() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.PreeditMethod result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.PreeditMethod.forNumber(preeditMethod_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.PreeditMethod.ASCII : result;
    }
    /**
     * <code>optional .mozc.commands.Output.PreeditMethod preedit_method = 10 [default = ASCII];</code>
     * @param value The preeditMethod to set.
     */
    private void setPreeditMethod(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.PreeditMethod value) {
      preeditMethod_ = value.getNumber();
      bitField0_ |= 0x00000200;
    }
    /**
     * <code>optional .mozc.commands.Output.PreeditMethod preedit_method = 10 [default = ASCII];</code>
     */
    private void clearPreeditMethod() {
      bitField0_ = (bitField0_ & ~0x00000200);
      preeditMethod_ = 0;
    }

    public static final int ERROR_CODE_FIELD_NUMBER = 11;
    private int errorCode_;
    /**
     * <code>optional .mozc.commands.Output.ErrorCode error_code = 11 [default = SESSION_SUCCESS];</code>
     * @return Whether the errorCode field is set.
     */
    @java.lang.Override
    public boolean hasErrorCode() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     * <code>optional .mozc.commands.Output.ErrorCode error_code = 11 [default = SESSION_SUCCESS];</code>
     * @return The errorCode.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.ErrorCode getErrorCode() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.ErrorCode result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.ErrorCode.forNumber(errorCode_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.ErrorCode.SESSION_SUCCESS : result;
    }
    /**
     * <code>optional .mozc.commands.Output.ErrorCode error_code = 11 [default = SESSION_SUCCESS];</code>
     * @param value The errorCode to set.
     */
    private void setErrorCode(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.ErrorCode value) {
      errorCode_ = value.getNumber();
      bitField0_ |= 0x00000400;
    }
    /**
     * <code>optional .mozc.commands.Output.ErrorCode error_code = 11 [default = SESSION_SUCCESS];</code>
     */
    private void clearErrorCode() {
      bitField0_ = (bitField0_ & ~0x00000400);
      errorCode_ = 0;
    }

    public static final int STATUS_FIELD_NUMBER = 13;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status status_;
    /**
     * <pre>
     * The current IME status.
     * </pre>
     *
     * <code>optional .mozc.commands.Status status = 13;</code>
     */
    @java.lang.Override
    public boolean hasStatus() {
      return ((bitField0_ & 0x00000800) != 0);
    }
    /**
     * <pre>
     * The current IME status.
     * </pre>
     *
     * <code>optional .mozc.commands.Status status = 13;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status getStatus() {
      return status_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status.getDefaultInstance() : status_;
    }
    /**
     * <pre>
     * The current IME status.
     * </pre>
     *
     * <code>optional .mozc.commands.Status status = 13;</code>
     */
    private void setStatus(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status value) {
      value.getClass();
  status_ = value;
      bitField0_ |= 0x00000800;
      }
    /**
     * <pre>
     * The current IME status.
     * </pre>
     *
     * <code>optional .mozc.commands.Status status = 13;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeStatus(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status value) {
      value.getClass();
  if (status_ != null &&
          status_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status.getDefaultInstance()) {
        status_ =
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status.newBuilder(status_).mergeFrom(value).buildPartial();
      } else {
        status_ = value;
      }
      bitField0_ |= 0x00000800;
    }
    /**
     * <pre>
     * The current IME status.
     * </pre>
     *
     * <code>optional .mozc.commands.Status status = 13;</code>
     */
    private void clearStatus() {  status_ = null;
      bitField0_ = (bitField0_ & ~0x00000800);
    }

    public static final int ALL_CANDIDATE_WORDS_FIELD_NUMBER = 14;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList allCandidateWords_;
    /**
     * <pre>
     * All flatten candidate words stored in 1D array.  This value is
     * filled only when the content is changed.
     * </pre>
     *
     * <code>optional .mozc.commands.CandidateList all_candidate_words = 14;</code>
     */
    @java.lang.Override
    public boolean hasAllCandidateWords() {
      return ((bitField0_ & 0x00001000) != 0);
    }
    /**
     * <pre>
     * All flatten candidate words stored in 1D array.  This value is
     * filled only when the content is changed.
     * </pre>
     *
     * <code>optional .mozc.commands.CandidateList all_candidate_words = 14;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList getAllCandidateWords() {
      return allCandidateWords_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList.getDefaultInstance() : allCandidateWords_;
    }
    /**
     * <pre>
     * All flatten candidate words stored in 1D array.  This value is
     * filled only when the content is changed.
     * </pre>
     *
     * <code>optional .mozc.commands.CandidateList all_candidate_words = 14;</code>
     */
    private void setAllCandidateWords(org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList value) {
      value.getClass();
  allCandidateWords_ = value;
      bitField0_ |= 0x00001000;
      }
    /**
     * <pre>
     * All flatten candidate words stored in 1D array.  This value is
     * filled only when the content is changed.
     * </pre>
     *
     * <code>optional .mozc.commands.CandidateList all_candidate_words = 14;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeAllCandidateWords(org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList value) {
      value.getClass();
  if (allCandidateWords_ != null &&
          allCandidateWords_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList.getDefaultInstance()) {
        allCandidateWords_ =
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList.newBuilder(allCandidateWords_).mergeFrom(value).buildPartial();
      } else {
        allCandidateWords_ = value;
      }
      bitField0_ |= 0x00001000;
    }
    /**
     * <pre>
     * All flatten candidate words stored in 1D array.  This value is
     * filled only when the content is changed.
     * </pre>
     *
     * <code>optional .mozc.commands.CandidateList all_candidate_words = 14;</code>
     */
    private void clearAllCandidateWords() {  allCandidateWords_ = null;
      bitField0_ = (bitField0_ & ~0x00001000);
    }

    public static final int DELETION_RANGE_FIELD_NUMBER = 16;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange deletionRange_;
    /**
     * <pre>
     * Range of characters to be deleted by client.
     * </pre>
     *
     * <code>optional .mozc.commands.DeletionRange deletion_range = 16;</code>
     */
    @java.lang.Override
    public boolean hasDeletionRange() {
      return ((bitField0_ & 0x00002000) != 0);
    }
    /**
     * <pre>
     * Range of characters to be deleted by client.
     * </pre>
     *
     * <code>optional .mozc.commands.DeletionRange deletion_range = 16;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange getDeletionRange() {
      return deletionRange_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange.getDefaultInstance() : deletionRange_;
    }
    /**
     * <pre>
     * Range of characters to be deleted by client.
     * </pre>
     *
     * <code>optional .mozc.commands.DeletionRange deletion_range = 16;</code>
     */
    private void setDeletionRange(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange value) {
      value.getClass();
  deletionRange_ = value;
      bitField0_ |= 0x00002000;
      }
    /**
     * <pre>
     * Range of characters to be deleted by client.
     * </pre>
     *
     * <code>optional .mozc.commands.DeletionRange deletion_range = 16;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeDeletionRange(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange value) {
      value.getClass();
  if (deletionRange_ != null &&
          deletionRange_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange.getDefaultInstance()) {
        deletionRange_ =
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange.newBuilder(deletionRange_).mergeFrom(value).buildPartial();
      } else {
        deletionRange_ = value;
      }
      bitField0_ |= 0x00002000;
    }
    /**
     * <pre>
     * Range of characters to be deleted by client.
     * </pre>
     *
     * <code>optional .mozc.commands.DeletionRange deletion_range = 16;</code>
     */
    private void clearDeletionRange() {  deletionRange_ = null;
      bitField0_ = (bitField0_ & ~0x00002000);
    }

    public static final int LAUNCH_TOOL_MODE_FIELD_NUMBER = 17;
    private int launchToolMode_;
    /**
     * <code>optional .mozc.commands.Output.ToolMode launch_tool_mode = 17 [default = NO_TOOL];</code>
     * @return Whether the launchToolMode field is set.
     */
    @java.lang.Override
    public boolean hasLaunchToolMode() {
      return ((bitField0_ & 0x00004000) != 0);
    }
    /**
     * <code>optional .mozc.commands.Output.ToolMode launch_tool_mode = 17 [default = NO_TOOL];</code>
     * @return The launchToolMode.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.ToolMode getLaunchToolMode() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.ToolMode result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.ToolMode.forNumber(launchToolMode_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.ToolMode.NO_TOOL : result;
    }
    /**
     * <code>optional .mozc.commands.Output.ToolMode launch_tool_mode = 17 [default = NO_TOOL];</code>
     * @param value The launchToolMode to set.
     */
    private void setLaunchToolMode(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.ToolMode value) {
      launchToolMode_ = value.getNumber();
      bitField0_ |= 0x00004000;
    }
    /**
     * <code>optional .mozc.commands.Output.ToolMode launch_tool_mode = 17 [default = NO_TOOL];</code>
     */
    private void clearLaunchToolMode() {
      bitField0_ = (bitField0_ & ~0x00004000);
      launchToolMode_ = 0;
    }

    public static final int CALLBACK_FIELD_NUMBER = 18;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback callback_;
    /**
     * <code>optional .mozc.commands.Output.Callback callback = 18;</code>
     */
    @java.lang.Override
    public boolean hasCallback() {
      return ((bitField0_ & 0x00008000) != 0);
    }
    /**
     * <code>optional .mozc.commands.Output.Callback callback = 18;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback getCallback() {
      return callback_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback.getDefaultInstance() : callback_;
    }
    /**
     * <code>optional .mozc.commands.Output.Callback callback = 18;</code>
     */
    private void setCallback(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback value) {
      value.getClass();
  callback_ = value;
      bitField0_ |= 0x00008000;
      }
    /**
     * <code>optional .mozc.commands.Output.Callback callback = 18;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeCallback(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback value) {
      value.getClass();
  if (callback_ != null &&
          callback_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback.getDefaultInstance()) {
        callback_ =
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback.newBuilder(callback_).mergeFrom(value).buildPartial();
      } else {
        callback_ = value;
      }
      bitField0_ |= 0x00008000;
    }
    /**
     * <code>optional .mozc.commands.Output.Callback callback = 18;</code>
     */
    private void clearCallback() {  callback_ = null;
      bitField0_ = (bitField0_ & ~0x00008000);
    }

    public static final int ENGINE_RELOAD_RESPONSE_FIELD_NUMBER = 22;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadResponse engineReloadResponse_;
    /**
     * <code>optional .mozc.EngineReloadResponse engine_reload_response = 22;</code>
     */
    @java.lang.Override
    public boolean hasEngineReloadResponse() {
      return ((bitField0_ & 0x00010000) != 0);
    }
    /**
     * <code>optional .mozc.EngineReloadResponse engine_reload_response = 22;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadResponse getEngineReloadResponse() {
      return engineReloadResponse_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadResponse.getDefaultInstance() : engineReloadResponse_;
    }
    /**
     * <code>optional .mozc.EngineReloadResponse engine_reload_response = 22;</code>
     */
    private void setEngineReloadResponse(org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadResponse value) {
      value.getClass();
  engineReloadResponse_ = value;
      bitField0_ |= 0x00010000;
      }
    /**
     * <code>optional .mozc.EngineReloadResponse engine_reload_response = 22;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeEngineReloadResponse(org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadResponse value) {
      value.getClass();
  if (engineReloadResponse_ != null &&
          engineReloadResponse_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadResponse.getDefaultInstance()) {
        engineReloadResponse_ =
          org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadResponse.newBuilder(engineReloadResponse_).mergeFrom(value).buildPartial();
      } else {
        engineReloadResponse_ = value;
      }
      bitField0_ |= 0x00010000;
    }
    /**
     * <code>optional .mozc.EngineReloadResponse engine_reload_response = 22;</code>
     */
    private void clearEngineReloadResponse() {  engineReloadResponse_ = null;
      bitField0_ = (bitField0_ & ~0x00010000);
    }

    public static final int REMOVED_CANDIDATE_WORDS_FOR_DEBUG_FIELD_NUMBER = 23;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList removedCandidateWordsForDebug_;
    /**
     * <pre>
     * For debug. Candidate words removed throuth the conversion process.
     * </pre>
     *
     * <code>optional .mozc.commands.CandidateList removed_candidate_words_for_debug = 23;</code>
     */
    @java.lang.Override
    public boolean hasRemovedCandidateWordsForDebug() {
      return ((bitField0_ & 0x00020000) != 0);
    }
    /**
     * <pre>
     * For debug. Candidate words removed throuth the conversion process.
     * </pre>
     *
     * <code>optional .mozc.commands.CandidateList removed_candidate_words_for_debug = 23;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList getRemovedCandidateWordsForDebug() {
      return removedCandidateWordsForDebug_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList.getDefaultInstance() : removedCandidateWordsForDebug_;
    }
    /**
     * <pre>
     * For debug. Candidate words removed throuth the conversion process.
     * </pre>
     *
     * <code>optional .mozc.commands.CandidateList removed_candidate_words_for_debug = 23;</code>
     */
    private void setRemovedCandidateWordsForDebug(org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList value) {
      value.getClass();
  removedCandidateWordsForDebug_ = value;
      bitField0_ |= 0x00020000;
      }
    /**
     * <pre>
     * For debug. Candidate words removed throuth the conversion process.
     * </pre>
     *
     * <code>optional .mozc.commands.CandidateList removed_candidate_words_for_debug = 23;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeRemovedCandidateWordsForDebug(org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList value) {
      value.getClass();
  if (removedCandidateWordsForDebug_ != null &&
          removedCandidateWordsForDebug_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList.getDefaultInstance()) {
        removedCandidateWordsForDebug_ =
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList.newBuilder(removedCandidateWordsForDebug_).mergeFrom(value).buildPartial();
      } else {
        removedCandidateWordsForDebug_ = value;
      }
      bitField0_ |= 0x00020000;
    }
    /**
     * <pre>
     * For debug. Candidate words removed throuth the conversion process.
     * </pre>
     *
     * <code>optional .mozc.commands.CandidateList removed_candidate_words_for_debug = 23;</code>
     */
    private void clearRemovedCandidateWordsForDebug() {  removedCandidateWordsForDebug_ = null;
      bitField0_ = (bitField0_ & ~0x00020000);
    }

    public static final int INCOGNITO_CANDIDATE_WORDS_FIELD_NUMBER = 25;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList incognitoCandidateWords_;
    /**
     * <pre>
     * Candidate words stored in 1D array. The field should be filled without
     * using any personal data.
     * </pre>
     *
     * <code>optional .mozc.commands.CandidateList incognito_candidate_words = 25;</code>
     */
    @java.lang.Override
    public boolean hasIncognitoCandidateWords() {
      return ((bitField0_ & 0x00040000) != 0);
    }
    /**
     * <pre>
     * Candidate words stored in 1D array. The field should be filled without
     * using any personal data.
     * </pre>
     *
     * <code>optional .mozc.commands.CandidateList incognito_candidate_words = 25;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList getIncognitoCandidateWords() {
      return incognitoCandidateWords_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList.getDefaultInstance() : incognitoCandidateWords_;
    }
    /**
     * <pre>
     * Candidate words stored in 1D array. The field should be filled without
     * using any personal data.
     * </pre>
     *
     * <code>optional .mozc.commands.CandidateList incognito_candidate_words = 25;</code>
     */
    private void setIncognitoCandidateWords(org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList value) {
      value.getClass();
  incognitoCandidateWords_ = value;
      bitField0_ |= 0x00040000;
      }
    /**
     * <pre>
     * Candidate words stored in 1D array. The field should be filled without
     * using any personal data.
     * </pre>
     *
     * <code>optional .mozc.commands.CandidateList incognito_candidate_words = 25;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeIncognitoCandidateWords(org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList value) {
      value.getClass();
  if (incognitoCandidateWords_ != null &&
          incognitoCandidateWords_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList.getDefaultInstance()) {
        incognitoCandidateWords_ =
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList.newBuilder(incognitoCandidateWords_).mergeFrom(value).buildPartial();
      } else {
        incognitoCandidateWords_ = value;
      }
      bitField0_ |= 0x00040000;
    }
    /**
     * <pre>
     * Candidate words stored in 1D array. The field should be filled without
     * using any personal data.
     * </pre>
     *
     * <code>optional .mozc.commands.CandidateList incognito_candidate_words = 25;</code>
     */
    private void clearIncognitoCandidateWords() {  incognitoCandidateWords_ = null;
      bitField0_ = (bitField0_ & ~0x00040000);
    }

    public static final int SERVER_VERSION_FIELD_NUMBER = 26;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo serverVersion_;
    /**
     * <code>optional .mozc.commands.Output.VersionInfo server_version = 26;</code>
     */
    @java.lang.Override
    public boolean hasServerVersion() {
      return ((bitField0_ & 0x00080000) != 0);
    }
    /**
     * <code>optional .mozc.commands.Output.VersionInfo server_version = 26;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo getServerVersion() {
      return serverVersion_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo.getDefaultInstance() : serverVersion_;
    }
    /**
     * <code>optional .mozc.commands.Output.VersionInfo server_version = 26;</code>
     */
    private void setServerVersion(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo value) {
      value.getClass();
  serverVersion_ = value;
      bitField0_ |= 0x00080000;
      }
    /**
     * <code>optional .mozc.commands.Output.VersionInfo server_version = 26;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeServerVersion(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo value) {
      value.getClass();
  if (serverVersion_ != null &&
          serverVersion_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo.getDefaultInstance()) {
        serverVersion_ =
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo.newBuilder(serverVersion_).mergeFrom(value).buildPartial();
      } else {
        serverVersion_ = value;
      }
      bitField0_ |= 0x00080000;
    }
    /**
     * <code>optional .mozc.commands.Output.VersionInfo server_version = 26;</code>
     */
    private void clearServerVersion() {  serverVersion_ = null;
      bitField0_ = (bitField0_ & ~0x00080000);
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Next ID: 27
     * </pre>
     *
     * Protobuf type {@code mozc.commands.Output}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output, Builder> implements
        // @@protoc_insertion_point(builder_implements:mozc.commands.Output)
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.OutputOrBuilder {
      // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>optional uint64 id = 1 [jstype = JS_STRING];</code>
       * @return Whether the id field is set.
       */
      @java.lang.Override
      public boolean hasId() {
        return instance.hasId();
      }
      /**
       * <code>optional uint64 id = 1 [jstype = JS_STRING];</code>
       * @return The id.
       */
      @java.lang.Override
      public long getId() {
        return instance.getId();
      }
      /**
       * <code>optional uint64 id = 1 [jstype = JS_STRING];</code>
       * @param value The id to set.
       * @return This builder for chaining.
       */
      public Builder setId(long value) {
        copyOnWrite();
        instance.setId(value);
        return this;
      }
      /**
       * <code>optional uint64 id = 1 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearId() {
        copyOnWrite();
        instance.clearId();
        return this;
      }

      /**
       * <pre>
       * This variable is going to be obsolete. Please use status(13) instead.
       * </pre>
       *
       * <code>optional .mozc.commands.CompositionMode mode = 2;</code>
       * @return Whether the mode field is set.
       */
      @java.lang.Override
      public boolean hasMode() {
        return instance.hasMode();
      }
      /**
       * <pre>
       * This variable is going to be obsolete. Please use status(13) instead.
       * </pre>
       *
       * <code>optional .mozc.commands.CompositionMode mode = 2;</code>
       * @return The mode.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode getMode() {
        return instance.getMode();
      }
      /**
       * <pre>
       * This variable is going to be obsolete. Please use status(13) instead.
       * </pre>
       *
       * <code>optional .mozc.commands.CompositionMode mode = 2;</code>
       * @param value The enum numeric value on the wire for mode to set.
       * @return This builder for chaining.
       */
      public Builder setMode(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode value) {
        copyOnWrite();
        instance.setMode(value);
        return this;
      }
      /**
       * <pre>
       * This variable is going to be obsolete. Please use status(13) instead.
       * </pre>
       *
       * <code>optional .mozc.commands.CompositionMode mode = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearMode() {
        copyOnWrite();
        instance.clearMode();
        return this;
      }

      /**
       * <code>optional bool consumed = 3;</code>
       * @return Whether the consumed field is set.
       */
      @java.lang.Override
      public boolean hasConsumed() {
        return instance.hasConsumed();
      }
      /**
       * <code>optional bool consumed = 3;</code>
       * @return The consumed.
       */
      @java.lang.Override
      public boolean getConsumed() {
        return instance.getConsumed();
      }
      /**
       * <code>optional bool consumed = 3;</code>
       * @param value The consumed to set.
       * @return This builder for chaining.
       */
      public Builder setConsumed(boolean value) {
        copyOnWrite();
        instance.setConsumed(value);
        return this;
      }
      /**
       * <code>optional bool consumed = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearConsumed() {
        copyOnWrite();
        instance.clearConsumed();
        return this;
      }

      /**
       * <code>optional .mozc.commands.Result result = 4;</code>
       */
      @java.lang.Override
      public boolean hasResult() {
        return instance.hasResult();
      }
      /**
       * <code>optional .mozc.commands.Result result = 4;</code>
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result getResult() {
        return instance.getResult();
      }
      /**
       * <code>optional .mozc.commands.Result result = 4;</code>
       */
      public Builder setResult(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result value) {
        copyOnWrite();
        instance.setResult(value);
        return this;
        }
      /**
       * <code>optional .mozc.commands.Result result = 4;</code>
       */
      public Builder setResult(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.Builder builderForValue) {
        copyOnWrite();
        instance.setResult(builderForValue.build());
        return this;
      }
      /**
       * <code>optional .mozc.commands.Result result = 4;</code>
       */
      public Builder mergeResult(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result value) {
        copyOnWrite();
        instance.mergeResult(value);
        return this;
      }
      /**
       * <code>optional .mozc.commands.Result result = 4;</code>
       */
      public Builder clearResult() {  copyOnWrite();
        instance.clearResult();
        return this;
      }

      /**
       * <code>optional .mozc.commands.Preedit preedit = 5;</code>
       */
      @java.lang.Override
      public boolean hasPreedit() {
        return instance.hasPreedit();
      }
      /**
       * <code>optional .mozc.commands.Preedit preedit = 5;</code>
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit getPreedit() {
        return instance.getPreedit();
      }
      /**
       * <code>optional .mozc.commands.Preedit preedit = 5;</code>
       */
      public Builder setPreedit(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit value) {
        copyOnWrite();
        instance.setPreedit(value);
        return this;
        }
      /**
       * <code>optional .mozc.commands.Preedit preedit = 5;</code>
       */
      public Builder setPreedit(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Builder builderForValue) {
        copyOnWrite();
        instance.setPreedit(builderForValue.build());
        return this;
      }
      /**
       * <code>optional .mozc.commands.Preedit preedit = 5;</code>
       */
      public Builder mergePreedit(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit value) {
        copyOnWrite();
        instance.mergePreedit(value);
        return this;
      }
      /**
       * <code>optional .mozc.commands.Preedit preedit = 5;</code>
       */
      public Builder clearPreedit() {  copyOnWrite();
        instance.clearPreedit();
        return this;
      }

      /**
       * <code>optional .mozc.commands.CandidateWindow candidate_window = 6;</code>
       */
      @java.lang.Override
      public boolean hasCandidateWindow() {
        return instance.hasCandidateWindow();
      }
      /**
       * <code>optional .mozc.commands.CandidateWindow candidate_window = 6;</code>
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateWindow getCandidateWindow() {
        return instance.getCandidateWindow();
      }
      /**
       * <code>optional .mozc.commands.CandidateWindow candidate_window = 6;</code>
       */
      public Builder setCandidateWindow(org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateWindow value) {
        copyOnWrite();
        instance.setCandidateWindow(value);
        return this;
        }
      /**
       * <code>optional .mozc.commands.CandidateWindow candidate_window = 6;</code>
       */
      public Builder setCandidateWindow(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateWindow.Builder builderForValue) {
        copyOnWrite();
        instance.setCandidateWindow(builderForValue.build());
        return this;
      }
      /**
       * <code>optional .mozc.commands.CandidateWindow candidate_window = 6;</code>
       */
      public Builder mergeCandidateWindow(org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateWindow value) {
        copyOnWrite();
        instance.mergeCandidateWindow(value);
        return this;
      }
      /**
       * <code>optional .mozc.commands.CandidateWindow candidate_window = 6;</code>
       */
      public Builder clearCandidateWindow() {  copyOnWrite();
        instance.clearCandidateWindow();
        return this;
      }

      /**
       * <code>optional .mozc.commands.KeyEvent key = 7;</code>
       */
      @java.lang.Override
      public boolean hasKey() {
        return instance.hasKey();
      }
      /**
       * <code>optional .mozc.commands.KeyEvent key = 7;</code>
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent getKey() {
        return instance.getKey();
      }
      /**
       * <code>optional .mozc.commands.KeyEvent key = 7;</code>
       */
      public Builder setKey(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent value) {
        copyOnWrite();
        instance.setKey(value);
        return this;
        }
      /**
       * <code>optional .mozc.commands.KeyEvent key = 7;</code>
       */
      public Builder setKey(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.Builder builderForValue) {
        copyOnWrite();
        instance.setKey(builderForValue.build());
        return this;
      }
      /**
       * <code>optional .mozc.commands.KeyEvent key = 7;</code>
       */
      public Builder mergeKey(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent value) {
        copyOnWrite();
        instance.mergeKey(value);
        return this;
      }
      /**
       * <code>optional .mozc.commands.KeyEvent key = 7;</code>
       */
      public Builder clearKey() {  copyOnWrite();
        instance.clearKey();
        return this;
      }

      /**
       * <pre>
       * when URL is non empty, UI can open the page with a browser,
       * after finishing the all rendering part.
       * We are using this feature for bug-report system.
       * </pre>
       *
       * <code>optional string url = 8;</code>
       * @return Whether the url field is set.
       */
      @java.lang.Override
      public boolean hasUrl() {
        return instance.hasUrl();
      }
      /**
       * <pre>
       * when URL is non empty, UI can open the page with a browser,
       * after finishing the all rendering part.
       * We are using this feature for bug-report system.
       * </pre>
       *
       * <code>optional string url = 8;</code>
       * @return The url.
       */
      @java.lang.Override
      public java.lang.String getUrl() {
        return instance.getUrl();
      }
      /**
       * <pre>
       * when URL is non empty, UI can open the page with a browser,
       * after finishing the all rendering part.
       * We are using this feature for bug-report system.
       * </pre>
       *
       * <code>optional string url = 8;</code>
       * @return The bytes for url.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getUrlBytes() {
        return instance.getUrlBytes();
      }
      /**
       * <pre>
       * when URL is non empty, UI can open the page with a browser,
       * after finishing the all rendering part.
       * We are using this feature for bug-report system.
       * </pre>
       *
       * <code>optional string url = 8;</code>
       * @param value The url to set.
       * @return This builder for chaining.
       */
      public Builder setUrl(
          java.lang.String value) {
        copyOnWrite();
        instance.setUrl(value);
        return this;
      }
      /**
       * <pre>
       * when URL is non empty, UI can open the page with a browser,
       * after finishing the all rendering part.
       * We are using this feature for bug-report system.
       * </pre>
       *
       * <code>optional string url = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearUrl() {
        copyOnWrite();
        instance.clearUrl();
        return this;
      }
      /**
       * <pre>
       * when URL is non empty, UI can open the page with a browser,
       * after finishing the all rendering part.
       * We are using this feature for bug-report system.
       * </pre>
       *
       * <code>optional string url = 8;</code>
       * @param value The bytes for url to set.
       * @return This builder for chaining.
       */
      public Builder setUrlBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setUrlBytes(value);
        return this;
      }

      /**
       * <pre>
       * Output config
       * </pre>
       *
       * <code>optional .mozc.config.Config config = 9;</code>
       */
      @java.lang.Override
      public boolean hasConfig() {
        return instance.hasConfig();
      }
      /**
       * <pre>
       * Output config
       * </pre>
       *
       * <code>optional .mozc.config.Config config = 9;</code>
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config getConfig() {
        return instance.getConfig();
      }
      /**
       * <pre>
       * Output config
       * </pre>
       *
       * <code>optional .mozc.config.Config config = 9;</code>
       */
      public Builder setConfig(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config value) {
        copyOnWrite();
        instance.setConfig(value);
        return this;
        }
      /**
       * <pre>
       * Output config
       * </pre>
       *
       * <code>optional .mozc.config.Config config = 9;</code>
       */
      public Builder setConfig(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.Builder builderForValue) {
        copyOnWrite();
        instance.setConfig(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Output config
       * </pre>
       *
       * <code>optional .mozc.config.Config config = 9;</code>
       */
      public Builder mergeConfig(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config value) {
        copyOnWrite();
        instance.mergeConfig(value);
        return this;
      }
      /**
       * <pre>
       * Output config
       * </pre>
       *
       * <code>optional .mozc.config.Config config = 9;</code>
       */
      public Builder clearConfig() {  copyOnWrite();
        instance.clearConfig();
        return this;
      }

      /**
       * <code>optional .mozc.commands.Output.PreeditMethod preedit_method = 10 [default = ASCII];</code>
       * @return Whether the preeditMethod field is set.
       */
      @java.lang.Override
      public boolean hasPreeditMethod() {
        return instance.hasPreeditMethod();
      }
      /**
       * <code>optional .mozc.commands.Output.PreeditMethod preedit_method = 10 [default = ASCII];</code>
       * @return The preeditMethod.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.PreeditMethod getPreeditMethod() {
        return instance.getPreeditMethod();
      }
      /**
       * <code>optional .mozc.commands.Output.PreeditMethod preedit_method = 10 [default = ASCII];</code>
       * @param value The enum numeric value on the wire for preeditMethod to set.
       * @return This builder for chaining.
       */
      public Builder setPreeditMethod(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.PreeditMethod value) {
        copyOnWrite();
        instance.setPreeditMethod(value);
        return this;
      }
      /**
       * <code>optional .mozc.commands.Output.PreeditMethod preedit_method = 10 [default = ASCII];</code>
       * @return This builder for chaining.
       */
      public Builder clearPreeditMethod() {
        copyOnWrite();
        instance.clearPreeditMethod();
        return this;
      }

      /**
       * <code>optional .mozc.commands.Output.ErrorCode error_code = 11 [default = SESSION_SUCCESS];</code>
       * @return Whether the errorCode field is set.
       */
      @java.lang.Override
      public boolean hasErrorCode() {
        return instance.hasErrorCode();
      }
      /**
       * <code>optional .mozc.commands.Output.ErrorCode error_code = 11 [default = SESSION_SUCCESS];</code>
       * @return The errorCode.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.ErrorCode getErrorCode() {
        return instance.getErrorCode();
      }
      /**
       * <code>optional .mozc.commands.Output.ErrorCode error_code = 11 [default = SESSION_SUCCESS];</code>
       * @param value The enum numeric value on the wire for errorCode to set.
       * @return This builder for chaining.
       */
      public Builder setErrorCode(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.ErrorCode value) {
        copyOnWrite();
        instance.setErrorCode(value);
        return this;
      }
      /**
       * <code>optional .mozc.commands.Output.ErrorCode error_code = 11 [default = SESSION_SUCCESS];</code>
       * @return This builder for chaining.
       */
      public Builder clearErrorCode() {
        copyOnWrite();
        instance.clearErrorCode();
        return this;
      }

      /**
       * <pre>
       * The current IME status.
       * </pre>
       *
       * <code>optional .mozc.commands.Status status = 13;</code>
       */
      @java.lang.Override
      public boolean hasStatus() {
        return instance.hasStatus();
      }
      /**
       * <pre>
       * The current IME status.
       * </pre>
       *
       * <code>optional .mozc.commands.Status status = 13;</code>
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status getStatus() {
        return instance.getStatus();
      }
      /**
       * <pre>
       * The current IME status.
       * </pre>
       *
       * <code>optional .mozc.commands.Status status = 13;</code>
       */
      public Builder setStatus(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status value) {
        copyOnWrite();
        instance.setStatus(value);
        return this;
        }
      /**
       * <pre>
       * The current IME status.
       * </pre>
       *
       * <code>optional .mozc.commands.Status status = 13;</code>
       */
      public Builder setStatus(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status.Builder builderForValue) {
        copyOnWrite();
        instance.setStatus(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The current IME status.
       * </pre>
       *
       * <code>optional .mozc.commands.Status status = 13;</code>
       */
      public Builder mergeStatus(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status value) {
        copyOnWrite();
        instance.mergeStatus(value);
        return this;
      }
      /**
       * <pre>
       * The current IME status.
       * </pre>
       *
       * <code>optional .mozc.commands.Status status = 13;</code>
       */
      public Builder clearStatus() {  copyOnWrite();
        instance.clearStatus();
        return this;
      }

      /**
       * <pre>
       * All flatten candidate words stored in 1D array.  This value is
       * filled only when the content is changed.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList all_candidate_words = 14;</code>
       */
      @java.lang.Override
      public boolean hasAllCandidateWords() {
        return instance.hasAllCandidateWords();
      }
      /**
       * <pre>
       * All flatten candidate words stored in 1D array.  This value is
       * filled only when the content is changed.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList all_candidate_words = 14;</code>
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList getAllCandidateWords() {
        return instance.getAllCandidateWords();
      }
      /**
       * <pre>
       * All flatten candidate words stored in 1D array.  This value is
       * filled only when the content is changed.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList all_candidate_words = 14;</code>
       */
      public Builder setAllCandidateWords(org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList value) {
        copyOnWrite();
        instance.setAllCandidateWords(value);
        return this;
        }
      /**
       * <pre>
       * All flatten candidate words stored in 1D array.  This value is
       * filled only when the content is changed.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList all_candidate_words = 14;</code>
       */
      public Builder setAllCandidateWords(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList.Builder builderForValue) {
        copyOnWrite();
        instance.setAllCandidateWords(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * All flatten candidate words stored in 1D array.  This value is
       * filled only when the content is changed.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList all_candidate_words = 14;</code>
       */
      public Builder mergeAllCandidateWords(org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList value) {
        copyOnWrite();
        instance.mergeAllCandidateWords(value);
        return this;
      }
      /**
       * <pre>
       * All flatten candidate words stored in 1D array.  This value is
       * filled only when the content is changed.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList all_candidate_words = 14;</code>
       */
      public Builder clearAllCandidateWords() {  copyOnWrite();
        instance.clearAllCandidateWords();
        return this;
      }

      /**
       * <pre>
       * Range of characters to be deleted by client.
       * </pre>
       *
       * <code>optional .mozc.commands.DeletionRange deletion_range = 16;</code>
       */
      @java.lang.Override
      public boolean hasDeletionRange() {
        return instance.hasDeletionRange();
      }
      /**
       * <pre>
       * Range of characters to be deleted by client.
       * </pre>
       *
       * <code>optional .mozc.commands.DeletionRange deletion_range = 16;</code>
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange getDeletionRange() {
        return instance.getDeletionRange();
      }
      /**
       * <pre>
       * Range of characters to be deleted by client.
       * </pre>
       *
       * <code>optional .mozc.commands.DeletionRange deletion_range = 16;</code>
       */
      public Builder setDeletionRange(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange value) {
        copyOnWrite();
        instance.setDeletionRange(value);
        return this;
        }
      /**
       * <pre>
       * Range of characters to be deleted by client.
       * </pre>
       *
       * <code>optional .mozc.commands.DeletionRange deletion_range = 16;</code>
       */
      public Builder setDeletionRange(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange.Builder builderForValue) {
        copyOnWrite();
        instance.setDeletionRange(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Range of characters to be deleted by client.
       * </pre>
       *
       * <code>optional .mozc.commands.DeletionRange deletion_range = 16;</code>
       */
      public Builder mergeDeletionRange(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange value) {
        copyOnWrite();
        instance.mergeDeletionRange(value);
        return this;
      }
      /**
       * <pre>
       * Range of characters to be deleted by client.
       * </pre>
       *
       * <code>optional .mozc.commands.DeletionRange deletion_range = 16;</code>
       */
      public Builder clearDeletionRange() {  copyOnWrite();
        instance.clearDeletionRange();
        return this;
      }

      /**
       * <code>optional .mozc.commands.Output.ToolMode launch_tool_mode = 17 [default = NO_TOOL];</code>
       * @return Whether the launchToolMode field is set.
       */
      @java.lang.Override
      public boolean hasLaunchToolMode() {
        return instance.hasLaunchToolMode();
      }
      /**
       * <code>optional .mozc.commands.Output.ToolMode launch_tool_mode = 17 [default = NO_TOOL];</code>
       * @return The launchToolMode.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.ToolMode getLaunchToolMode() {
        return instance.getLaunchToolMode();
      }
      /**
       * <code>optional .mozc.commands.Output.ToolMode launch_tool_mode = 17 [default = NO_TOOL];</code>
       * @param value The enum numeric value on the wire for launchToolMode to set.
       * @return This builder for chaining.
       */
      public Builder setLaunchToolMode(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.ToolMode value) {
        copyOnWrite();
        instance.setLaunchToolMode(value);
        return this;
      }
      /**
       * <code>optional .mozc.commands.Output.ToolMode launch_tool_mode = 17 [default = NO_TOOL];</code>
       * @return This builder for chaining.
       */
      public Builder clearLaunchToolMode() {
        copyOnWrite();
        instance.clearLaunchToolMode();
        return this;
      }

      /**
       * <code>optional .mozc.commands.Output.Callback callback = 18;</code>
       */
      @java.lang.Override
      public boolean hasCallback() {
        return instance.hasCallback();
      }
      /**
       * <code>optional .mozc.commands.Output.Callback callback = 18;</code>
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback getCallback() {
        return instance.getCallback();
      }
      /**
       * <code>optional .mozc.commands.Output.Callback callback = 18;</code>
       */
      public Builder setCallback(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback value) {
        copyOnWrite();
        instance.setCallback(value);
        return this;
        }
      /**
       * <code>optional .mozc.commands.Output.Callback callback = 18;</code>
       */
      public Builder setCallback(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback.Builder builderForValue) {
        copyOnWrite();
        instance.setCallback(builderForValue.build());
        return this;
      }
      /**
       * <code>optional .mozc.commands.Output.Callback callback = 18;</code>
       */
      public Builder mergeCallback(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback value) {
        copyOnWrite();
        instance.mergeCallback(value);
        return this;
      }
      /**
       * <code>optional .mozc.commands.Output.Callback callback = 18;</code>
       */
      public Builder clearCallback() {  copyOnWrite();
        instance.clearCallback();
        return this;
      }

      /**
       * <code>optional .mozc.EngineReloadResponse engine_reload_response = 22;</code>
       */
      @java.lang.Override
      public boolean hasEngineReloadResponse() {
        return instance.hasEngineReloadResponse();
      }
      /**
       * <code>optional .mozc.EngineReloadResponse engine_reload_response = 22;</code>
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadResponse getEngineReloadResponse() {
        return instance.getEngineReloadResponse();
      }
      /**
       * <code>optional .mozc.EngineReloadResponse engine_reload_response = 22;</code>
       */
      public Builder setEngineReloadResponse(org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadResponse value) {
        copyOnWrite();
        instance.setEngineReloadResponse(value);
        return this;
        }
      /**
       * <code>optional .mozc.EngineReloadResponse engine_reload_response = 22;</code>
       */
      public Builder setEngineReloadResponse(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadResponse.Builder builderForValue) {
        copyOnWrite();
        instance.setEngineReloadResponse(builderForValue.build());
        return this;
      }
      /**
       * <code>optional .mozc.EngineReloadResponse engine_reload_response = 22;</code>
       */
      public Builder mergeEngineReloadResponse(org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadResponse value) {
        copyOnWrite();
        instance.mergeEngineReloadResponse(value);
        return this;
      }
      /**
       * <code>optional .mozc.EngineReloadResponse engine_reload_response = 22;</code>
       */
      public Builder clearEngineReloadResponse() {  copyOnWrite();
        instance.clearEngineReloadResponse();
        return this;
      }

      /**
       * <pre>
       * For debug. Candidate words removed throuth the conversion process.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList removed_candidate_words_for_debug = 23;</code>
       */
      @java.lang.Override
      public boolean hasRemovedCandidateWordsForDebug() {
        return instance.hasRemovedCandidateWordsForDebug();
      }
      /**
       * <pre>
       * For debug. Candidate words removed throuth the conversion process.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList removed_candidate_words_for_debug = 23;</code>
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList getRemovedCandidateWordsForDebug() {
        return instance.getRemovedCandidateWordsForDebug();
      }
      /**
       * <pre>
       * For debug. Candidate words removed throuth the conversion process.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList removed_candidate_words_for_debug = 23;</code>
       */
      public Builder setRemovedCandidateWordsForDebug(org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList value) {
        copyOnWrite();
        instance.setRemovedCandidateWordsForDebug(value);
        return this;
        }
      /**
       * <pre>
       * For debug. Candidate words removed throuth the conversion process.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList removed_candidate_words_for_debug = 23;</code>
       */
      public Builder setRemovedCandidateWordsForDebug(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList.Builder builderForValue) {
        copyOnWrite();
        instance.setRemovedCandidateWordsForDebug(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * For debug. Candidate words removed throuth the conversion process.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList removed_candidate_words_for_debug = 23;</code>
       */
      public Builder mergeRemovedCandidateWordsForDebug(org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList value) {
        copyOnWrite();
        instance.mergeRemovedCandidateWordsForDebug(value);
        return this;
      }
      /**
       * <pre>
       * For debug. Candidate words removed throuth the conversion process.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList removed_candidate_words_for_debug = 23;</code>
       */
      public Builder clearRemovedCandidateWordsForDebug() {  copyOnWrite();
        instance.clearRemovedCandidateWordsForDebug();
        return this;
      }

      /**
       * <pre>
       * Candidate words stored in 1D array. The field should be filled without
       * using any personal data.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList incognito_candidate_words = 25;</code>
       */
      @java.lang.Override
      public boolean hasIncognitoCandidateWords() {
        return instance.hasIncognitoCandidateWords();
      }
      /**
       * <pre>
       * Candidate words stored in 1D array. The field should be filled without
       * using any personal data.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList incognito_candidate_words = 25;</code>
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList getIncognitoCandidateWords() {
        return instance.getIncognitoCandidateWords();
      }
      /**
       * <pre>
       * Candidate words stored in 1D array. The field should be filled without
       * using any personal data.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList incognito_candidate_words = 25;</code>
       */
      public Builder setIncognitoCandidateWords(org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList value) {
        copyOnWrite();
        instance.setIncognitoCandidateWords(value);
        return this;
        }
      /**
       * <pre>
       * Candidate words stored in 1D array. The field should be filled without
       * using any personal data.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList incognito_candidate_words = 25;</code>
       */
      public Builder setIncognitoCandidateWords(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList.Builder builderForValue) {
        copyOnWrite();
        instance.setIncognitoCandidateWords(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Candidate words stored in 1D array. The field should be filled without
       * using any personal data.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList incognito_candidate_words = 25;</code>
       */
      public Builder mergeIncognitoCandidateWords(org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList value) {
        copyOnWrite();
        instance.mergeIncognitoCandidateWords(value);
        return this;
      }
      /**
       * <pre>
       * Candidate words stored in 1D array. The field should be filled without
       * using any personal data.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList incognito_candidate_words = 25;</code>
       */
      public Builder clearIncognitoCandidateWords() {  copyOnWrite();
        instance.clearIncognitoCandidateWords();
        return this;
      }

      /**
       * <code>optional .mozc.commands.Output.VersionInfo server_version = 26;</code>
       */
      @java.lang.Override
      public boolean hasServerVersion() {
        return instance.hasServerVersion();
      }
      /**
       * <code>optional .mozc.commands.Output.VersionInfo server_version = 26;</code>
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo getServerVersion() {
        return instance.getServerVersion();
      }
      /**
       * <code>optional .mozc.commands.Output.VersionInfo server_version = 26;</code>
       */
      public Builder setServerVersion(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo value) {
        copyOnWrite();
        instance.setServerVersion(value);
        return this;
        }
      /**
       * <code>optional .mozc.commands.Output.VersionInfo server_version = 26;</code>
       */
      public Builder setServerVersion(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo.Builder builderForValue) {
        copyOnWrite();
        instance.setServerVersion(builderForValue.build());
        return this;
      }
      /**
       * <code>optional .mozc.commands.Output.VersionInfo server_version = 26;</code>
       */
      public Builder mergeServerVersion(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo value) {
        copyOnWrite();
        instance.mergeServerVersion(value);
        return this;
      }
      /**
       * <code>optional .mozc.commands.Output.VersionInfo server_version = 26;</code>
       */
      public Builder clearServerVersion() {  copyOnWrite();
        instance.clearServerVersion();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:mozc.commands.Output)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "id_",
              "mode_",
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode.internalGetVerifier(),
              "consumed_",
              "result_",
              "preedit_",
              "candidateWindow_",
              "key_",
              "url_",
              "config_",
              "preeditMethod_",
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.PreeditMethod.internalGetVerifier(),
              "errorCode_",
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.ErrorCode.internalGetVerifier(),
              "status_",
              "allCandidateWords_",
              "deletionRange_",
              "launchToolMode_",
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.ToolMode.internalGetVerifier(),
              "callback_",
              "engineReloadResponse_",
              "removedCandidateWordsForDebug_",
              "incognitoCandidateWords_",
              "serverVersion_",
            };
            java.lang.String info =
                "\u0001\u0014\u0000\u0001\u0001\u001a\u0014\u0000\u0000\u0005\u0001\u1003\u0000\u0002" +
                "\u100c\u0001\u0003\u1007\u0002\u0004\u1409\u0003\u0005\u1409\u0004\u0006\u1409\u0005" +
                "\u0007\u1009\u0006\b\u1008\u0007\t\u1009\b\n\u100c\t\u000b\u100c\n\r\u1009\u000b" +
                "\u000e\u1009\f\u0010\u1009\r\u0011\u100c\u000e\u0012\u1409\u000f\u0016\u1409\u0010" +
                "\u0017\u1009\u0011\u0019\u1009\u0012\u001a\u1009\u0013";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output> parser = PARSER;
          if (parser == null) {
            synchronized (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:mozc.commands.Output)
    private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output DEFAULT_INSTANCE;
    static {
      Output defaultInstance = new Output();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Output.class, defaultInstance);
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Output> PARSER;

    public static com.google.protobuf.Parser<Output> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface CommandOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mozc.commands.Command)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>required .mozc.commands.Input input = 1;</code>
     * @return Whether the input field is set.
     */
    boolean hasInput();
    /**
     * <code>required .mozc.commands.Input input = 1;</code>
     * @return The input.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input getInput();

    /**
     * <code>optional .mozc.commands.Output output = 2;</code>
     * @return Whether the output field is set.
     */
    boolean hasOutput();
    /**
     * <code>optional .mozc.commands.Output output = 2;</code>
     * @return The output.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output getOutput();
  }
  /**
   * Protobuf type {@code mozc.commands.Command}
   */
  public  static final class Command extends
      com.google.protobuf.GeneratedMessageLite<
          Command, Command.Builder> implements
      // @@protoc_insertion_point(message_implements:mozc.commands.Command)
      CommandOrBuilder {
    private Command() {
    }
    private int bitField0_;
    public static final int INPUT_FIELD_NUMBER = 1;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input input_;
    /**
     * <code>required .mozc.commands.Input input = 1;</code>
     */
    @java.lang.Override
    public boolean hasInput() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>required .mozc.commands.Input input = 1;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input getInput() {
      return input_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.getDefaultInstance() : input_;
    }
    /**
     * <code>required .mozc.commands.Input input = 1;</code>
     */
    private void setInput(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input value) {
      value.getClass();
  input_ = value;
      bitField0_ |= 0x00000001;
      }
    /**
     * <code>required .mozc.commands.Input input = 1;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeInput(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input value) {
      value.getClass();
  if (input_ != null &&
          input_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.getDefaultInstance()) {
        input_ =
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.newBuilder(input_).mergeFrom(value).buildPartial();
      } else {
        input_ = value;
      }
      bitField0_ |= 0x00000001;
    }
    /**
     * <code>required .mozc.commands.Input input = 1;</code>
     */
    private void clearInput() {  input_ = null;
      bitField0_ = (bitField0_ & ~0x00000001);
    }

    public static final int OUTPUT_FIELD_NUMBER = 2;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output output_;
    /**
     * <code>optional .mozc.commands.Output output = 2;</code>
     */
    @java.lang.Override
    public boolean hasOutput() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional .mozc.commands.Output output = 2;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output getOutput() {
      return output_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.getDefaultInstance() : output_;
    }
    /**
     * <code>optional .mozc.commands.Output output = 2;</code>
     */
    private void setOutput(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output value) {
      value.getClass();
  output_ = value;
      bitField0_ |= 0x00000002;
      }
    /**
     * <code>optional .mozc.commands.Output output = 2;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeOutput(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output value) {
      value.getClass();
  if (output_ != null &&
          output_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.getDefaultInstance()) {
        output_ =
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.newBuilder(output_).mergeFrom(value).buildPartial();
      } else {
        output_ = value;
      }
      bitField0_ |= 0x00000002;
    }
    /**
     * <code>optional .mozc.commands.Output output = 2;</code>
     */
    private void clearOutput() {  output_ = null;
      bitField0_ = (bitField0_ & ~0x00000002);
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code mozc.commands.Command}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command, Builder> implements
        // @@protoc_insertion_point(builder_implements:mozc.commands.Command)
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandOrBuilder {
      // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>required .mozc.commands.Input input = 1;</code>
       */
      @java.lang.Override
      public boolean hasInput() {
        return instance.hasInput();
      }
      /**
       * <code>required .mozc.commands.Input input = 1;</code>
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input getInput() {
        return instance.getInput();
      }
      /**
       * <code>required .mozc.commands.Input input = 1;</code>
       */
      public Builder setInput(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input value) {
        copyOnWrite();
        instance.setInput(value);
        return this;
        }
      /**
       * <code>required .mozc.commands.Input input = 1;</code>
       */
      public Builder setInput(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.Builder builderForValue) {
        copyOnWrite();
        instance.setInput(builderForValue.build());
        return this;
      }
      /**
       * <code>required .mozc.commands.Input input = 1;</code>
       */
      public Builder mergeInput(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input value) {
        copyOnWrite();
        instance.mergeInput(value);
        return this;
      }
      /**
       * <code>required .mozc.commands.Input input = 1;</code>
       */
      public Builder clearInput() {  copyOnWrite();
        instance.clearInput();
        return this;
      }

      /**
       * <code>optional .mozc.commands.Output output = 2;</code>
       */
      @java.lang.Override
      public boolean hasOutput() {
        return instance.hasOutput();
      }
      /**
       * <code>optional .mozc.commands.Output output = 2;</code>
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output getOutput() {
        return instance.getOutput();
      }
      /**
       * <code>optional .mozc.commands.Output output = 2;</code>
       */
      public Builder setOutput(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output value) {
        copyOnWrite();
        instance.setOutput(value);
        return this;
        }
      /**
       * <code>optional .mozc.commands.Output output = 2;</code>
       */
      public Builder setOutput(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Builder builderForValue) {
        copyOnWrite();
        instance.setOutput(builderForValue.build());
        return this;
      }
      /**
       * <code>optional .mozc.commands.Output output = 2;</code>
       */
      public Builder mergeOutput(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output value) {
        copyOnWrite();
        instance.mergeOutput(value);
        return this;
      }
      /**
       * <code>optional .mozc.commands.Output output = 2;</code>
       */
      public Builder clearOutput() {  copyOnWrite();
        instance.clearOutput();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:mozc.commands.Command)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "input_",
              "output_",
            };
            java.lang.String info =
                "\u0001\u0002\u0000\u0001\u0001\u0002\u0002\u0000\u0000\u0002\u0001\u1509\u0000\u0002" +
                "\u1409\u0001";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command> parser = PARSER;
          if (parser == null) {
            synchronized (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:mozc.commands.Command)
    private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command DEFAULT_INSTANCE;
    static {
      Command defaultInstance = new Command();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Command.class, defaultInstance);
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Command> PARSER;

    public static com.google.protobuf.Parser<Command> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface MozcCommandsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mozc.commands.MozcCommands)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command> 
        getCommandsList();
    /**
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command getCommands(int index);
    /**
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    int getCommandsCount();
  }
  /**
   * <pre>
   * Message used by ProtoXDB as "mozc_commands".
   * </pre>
   *
   * Protobuf type {@code mozc.commands.MozcCommands}
   */
  public  static final class MozcCommands extends
      com.google.protobuf.GeneratedMessageLite<
          MozcCommands, MozcCommands.Builder> implements
      // @@protoc_insertion_point(message_implements:mozc.commands.MozcCommands)
      MozcCommandsOrBuilder {
    private MozcCommands() {
      commands_ = emptyProtobufList();
    }
    public static final int COMMANDS_FIELD_NUMBER = 1;
    private com.google.protobuf.Internal.ProtobufList<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command> commands_;
    /**
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    @java.lang.Override
    public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command> getCommandsList() {
      return commands_;
    }
    /**
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    public java.util.List<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandOrBuilder> 
        getCommandsOrBuilderList() {
      return commands_;
    }
    /**
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    @java.lang.Override
    public int getCommandsCount() {
      return commands_.size();
    }
    /**
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command getCommands(int index) {
      return commands_.get(index);
    }
    /**
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandOrBuilder getCommandsOrBuilder(
        int index) {
      return commands_.get(index);
    }
    private void ensureCommandsIsMutable() {
      com.google.protobuf.Internal.ProtobufList<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command> tmp = commands_;
      if (!tmp.isModifiable()) {
        commands_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    private void setCommands(
        int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command value) {
      value.getClass();
  ensureCommandsIsMutable();
      commands_.set(index, value);
    }
    /**
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    private void addCommands(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command value) {
      value.getClass();
  ensureCommandsIsMutable();
      commands_.add(value);
    }
    /**
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    private void addCommands(
        int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command value) {
      value.getClass();
  ensureCommandsIsMutable();
      commands_.add(index, value);
    }
    /**
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    private void addAllCommands(
        java.lang.Iterable<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command> values) {
      ensureCommandsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, commands_);
    }
    /**
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    private void clearCommands() {
      commands_ = emptyProtobufList();
    }
    /**
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    private void removeCommands(int index) {
      ensureCommandsIsMutable();
      commands_.remove(index);
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Message used by ProtoXDB as "mozc_commands".
     * </pre>
     *
     * Protobuf type {@code mozc.commands.MozcCommands}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands, Builder> implements
        // @@protoc_insertion_point(builder_implements:mozc.commands.MozcCommands)
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommandsOrBuilder {
      // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      @java.lang.Override
      public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command> getCommandsList() {
        return java.util.Collections.unmodifiableList(
            instance.getCommandsList());
      }
      /**
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      @java.lang.Override
      public int getCommandsCount() {
        return instance.getCommandsCount();
      }/**
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command getCommands(int index) {
        return instance.getCommands(index);
      }
      /**
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public Builder setCommands(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command value) {
        copyOnWrite();
        instance.setCommands(index, value);
        return this;
      }
      /**
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public Builder setCommands(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command.Builder builderForValue) {
        copyOnWrite();
        instance.setCommands(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public Builder addCommands(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command value) {
        copyOnWrite();
        instance.addCommands(value);
        return this;
      }
      /**
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public Builder addCommands(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command value) {
        copyOnWrite();
        instance.addCommands(index, value);
        return this;
      }
      /**
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public Builder addCommands(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command.Builder builderForValue) {
        copyOnWrite();
        instance.addCommands(builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public Builder addCommands(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command.Builder builderForValue) {
        copyOnWrite();
        instance.addCommands(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public Builder addAllCommands(
          java.lang.Iterable<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command> values) {
        copyOnWrite();
        instance.addAllCommands(values);
        return this;
      }
      /**
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public Builder clearCommands() {
        copyOnWrite();
        instance.clearCommands();
        return this;
      }
      /**
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public Builder removeCommands(int index) {
        copyOnWrite();
        instance.removeCommands(index);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:mozc.commands.MozcCommands)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "commands_",
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command.class,
            };
            java.lang.String info =
                "\u0001\u0001\u0000\u0000\u0001\u0001\u0001\u0000\u0001\u0001\u0001\u041b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands> parser = PARSER;
          if (parser == null) {
            synchronized (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:mozc.commands.MozcCommands)
    private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands DEFAULT_INSTANCE;
    static {
      MozcCommands defaultInstance = new MozcCommands();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        MozcCommands.class, defaultInstance);
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<MozcCommands> PARSER;

    public static com.google.protobuf.Parser<MozcCommands> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface CommandListOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mozc.commands.CommandList)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * This message is used for unittest.
     * </pre>
     *
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command> 
        getCommandsList();
    /**
     * <pre>
     * This message is used for unittest.
     * </pre>
     *
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command getCommands(int index);
    /**
     * <pre>
     * This message is used for unittest.
     * </pre>
     *
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    int getCommandsCount();
  }
  /**
   * Protobuf type {@code mozc.commands.CommandList}
   */
  public  static final class CommandList extends
      com.google.protobuf.GeneratedMessageLite<
          CommandList, CommandList.Builder> implements
      // @@protoc_insertion_point(message_implements:mozc.commands.CommandList)
      CommandListOrBuilder {
    private CommandList() {
      commands_ = emptyProtobufList();
    }
    public static final int COMMANDS_FIELD_NUMBER = 1;
    private com.google.protobuf.Internal.ProtobufList<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command> commands_;
    /**
     * <pre>
     * This message is used for unittest.
     * </pre>
     *
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    @java.lang.Override
    public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command> getCommandsList() {
      return commands_;
    }
    /**
     * <pre>
     * This message is used for unittest.
     * </pre>
     *
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    public java.util.List<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandOrBuilder> 
        getCommandsOrBuilderList() {
      return commands_;
    }
    /**
     * <pre>
     * This message is used for unittest.
     * </pre>
     *
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    @java.lang.Override
    public int getCommandsCount() {
      return commands_.size();
    }
    /**
     * <pre>
     * This message is used for unittest.
     * </pre>
     *
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command getCommands(int index) {
      return commands_.get(index);
    }
    /**
     * <pre>
     * This message is used for unittest.
     * </pre>
     *
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandOrBuilder getCommandsOrBuilder(
        int index) {
      return commands_.get(index);
    }
    private void ensureCommandsIsMutable() {
      com.google.protobuf.Internal.ProtobufList<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command> tmp = commands_;
      if (!tmp.isModifiable()) {
        commands_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * This message is used for unittest.
     * </pre>
     *
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    private void setCommands(
        int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command value) {
      value.getClass();
  ensureCommandsIsMutable();
      commands_.set(index, value);
    }
    /**
     * <pre>
     * This message is used for unittest.
     * </pre>
     *
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    private void addCommands(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command value) {
      value.getClass();
  ensureCommandsIsMutable();
      commands_.add(value);
    }
    /**
     * <pre>
     * This message is used for unittest.
     * </pre>
     *
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    private void addCommands(
        int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command value) {
      value.getClass();
  ensureCommandsIsMutable();
      commands_.add(index, value);
    }
    /**
     * <pre>
     * This message is used for unittest.
     * </pre>
     *
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    private void addAllCommands(
        java.lang.Iterable<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command> values) {
      ensureCommandsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, commands_);
    }
    /**
     * <pre>
     * This message is used for unittest.
     * </pre>
     *
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    private void clearCommands() {
      commands_ = emptyProtobufList();
    }
    /**
     * <pre>
     * This message is used for unittest.
     * </pre>
     *
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    private void removeCommands(int index) {
      ensureCommandsIsMutable();
      commands_.remove(index);
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code mozc.commands.CommandList}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList, Builder> implements
        // @@protoc_insertion_point(builder_implements:mozc.commands.CommandList)
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandListOrBuilder {
      // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * This message is used for unittest.
       * </pre>
       *
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      @java.lang.Override
      public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command> getCommandsList() {
        return java.util.Collections.unmodifiableList(
            instance.getCommandsList());
      }
      /**
       * <pre>
       * This message is used for unittest.
       * </pre>
       *
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      @java.lang.Override
      public int getCommandsCount() {
        return instance.getCommandsCount();
      }/**
       * <pre>
       * This message is used for unittest.
       * </pre>
       *
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command getCommands(int index) {
        return instance.getCommands(index);
      }
      /**
       * <pre>
       * This message is used for unittest.
       * </pre>
       *
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public Builder setCommands(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command value) {
        copyOnWrite();
        instance.setCommands(index, value);
        return this;
      }
      /**
       * <pre>
       * This message is used for unittest.
       * </pre>
       *
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public Builder setCommands(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command.Builder builderForValue) {
        copyOnWrite();
        instance.setCommands(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * This message is used for unittest.
       * </pre>
       *
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public Builder addCommands(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command value) {
        copyOnWrite();
        instance.addCommands(value);
        return this;
      }
      /**
       * <pre>
       * This message is used for unittest.
       * </pre>
       *
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public Builder addCommands(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command value) {
        copyOnWrite();
        instance.addCommands(index, value);
        return this;
      }
      /**
       * <pre>
       * This message is used for unittest.
       * </pre>
       *
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public Builder addCommands(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command.Builder builderForValue) {
        copyOnWrite();
        instance.addCommands(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * This message is used for unittest.
       * </pre>
       *
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public Builder addCommands(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command.Builder builderForValue) {
        copyOnWrite();
        instance.addCommands(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * This message is used for unittest.
       * </pre>
       *
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public Builder addAllCommands(
          java.lang.Iterable<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command> values) {
        copyOnWrite();
        instance.addAllCommands(values);
        return this;
      }
      /**
       * <pre>
       * This message is used for unittest.
       * </pre>
       *
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public Builder clearCommands() {
        copyOnWrite();
        instance.clearCommands();
        return this;
      }
      /**
       * <pre>
       * This message is used for unittest.
       * </pre>
       *
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public Builder removeCommands(int index) {
        copyOnWrite();
        instance.removeCommands(index);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:mozc.commands.CommandList)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "commands_",
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command.class,
            };
            java.lang.String info =
                "\u0001\u0001\u0000\u0000\u0001\u0001\u0001\u0000\u0001\u0001\u0001\u041b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList> parser = PARSER;
          if (parser == null) {
            synchronized (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:mozc.commands.CommandList)
    private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList DEFAULT_INSTANCE;
    static {
      CommandList defaultInstance = new CommandList();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        CommandList.class, defaultInstance);
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<CommandList> PARSER;

    public static com.google.protobuf.Parser<CommandList> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }


  static {
  }

  // @@protoc_insertion_point(outer_class_scope)
}
