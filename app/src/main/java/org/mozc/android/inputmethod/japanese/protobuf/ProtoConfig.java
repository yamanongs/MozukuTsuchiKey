// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protocol/config.proto

package org.mozc.android.inputmethod.japanese.protobuf;

public final class ProtoConfig {
  private ProtoConfig() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }
  public interface GeneralConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mozc.config.GeneralConfig)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * config version, corresponding to the suffix of config file
     * </pre>
     *
     * <code>optional uint32 config_version = 1 [default = 0];</code>
     * @return Whether the configVersion field is set.
     */
    boolean hasConfigVersion();
    /**
     * <pre>
     * config version, corresponding to the suffix of config file
     * </pre>
     *
     * <code>optional uint32 config_version = 1 [default = 0];</code>
     * @return The configVersion.
     */
    int getConfigVersion();

    /**
     * <pre>
     * The product version that wrote this config
     * </pre>
     *
     * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
     * @return Whether the lastModifiedProductVersion field is set.
     */
    boolean hasLastModifiedProductVersion();
    /**
     * <pre>
     * The product version that wrote this config
     * </pre>
     *
     * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
     * @return The lastModifiedProductVersion.
     */
    java.lang.String getLastModifiedProductVersion();
    /**
     * <pre>
     * The product version that wrote this config
     * </pre>
     *
     * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
     * @return The bytes for lastModifiedProductVersion.
     */
    com.google.protobuf.ByteString
        getLastModifiedProductVersionBytes();

    /**
     * <pre>
     * last modified time in UTC second
     * </pre>
     *
     * <code>optional uint64 last_modified_time = 3 [default = 0, jstype = JS_STRING];</code>
     * @return Whether the lastModifiedTime field is set.
     */
    boolean hasLastModifiedTime();
    /**
     * <pre>
     * last modified time in UTC second
     * </pre>
     *
     * <code>optional uint64 last_modified_time = 3 [default = 0, jstype = JS_STRING];</code>
     * @return The lastModifiedTime.
     */
    long getLastModifiedTime();

    /**
     * <pre>
     * These fields are not used now
     * platform of machine that wrote this config
     * </pre>
     *
     * <code>optional string platform = 4 [default = ""];</code>
     * @return Whether the platform field is set.
     */
    boolean hasPlatform();
    /**
     * <pre>
     * These fields are not used now
     * platform of machine that wrote this config
     * </pre>
     *
     * <code>optional string platform = 4 [default = ""];</code>
     * @return The platform.
     */
    java.lang.String getPlatform();
    /**
     * <pre>
     * These fields are not used now
     * platform of machine that wrote this config
     * </pre>
     *
     * <code>optional string platform = 4 [default = ""];</code>
     * @return The bytes for platform.
     */
    com.google.protobuf.ByteString
        getPlatformBytes();

    /**
     * <pre>
     * UI locale of machine that wrote this config
     * </pre>
     *
     * <code>optional string ui_locale = 5 [default = ""];</code>
     * @return Whether the uiLocale field is set.
     */
    boolean hasUiLocale();
    /**
     * <pre>
     * UI locale of machine that wrote this config
     * </pre>
     *
     * <code>optional string ui_locale = 5 [default = ""];</code>
     * @return The uiLocale.
     */
    java.lang.String getUiLocale();
    /**
     * <pre>
     * UI locale of machine that wrote this config
     * </pre>
     *
     * <code>optional string ui_locale = 5 [default = ""];</code>
     * @return The bytes for uiLocale.
     */
    com.google.protobuf.ByteString
        getUiLocaleBytes();

    /**
     * <pre>
     * Whether to upload usage stats
     * This flag is used only for Android.
     * </pre>
     *
     * <code>optional bool upload_usage_stats = 6 [default = false];</code>
     * @return Whether the uploadUsageStats field is set.
     */
    boolean hasUploadUsageStats();
    /**
     * <pre>
     * Whether to upload usage stats
     * This flag is used only for Android.
     * </pre>
     *
     * <code>optional bool upload_usage_stats = 6 [default = false];</code>
     * @return The uploadUsageStats.
     */
    boolean getUploadUsageStats();
  }
  /**
   * <pre>
   *&#47;///////////////////////////////////////////////////////////
   * General config (1-9)
   * </pre>
   *
   * Protobuf type {@code mozc.config.GeneralConfig}
   */
  public  static final class GeneralConfig extends
      com.google.protobuf.GeneratedMessageLite<
          GeneralConfig, GeneralConfig.Builder> implements
      // @@protoc_insertion_point(message_implements:mozc.config.GeneralConfig)
      GeneralConfigOrBuilder {
    private GeneralConfig() {
      lastModifiedProductVersion_ = "0.0.0.0";
      platform_ = "";
      uiLocale_ = "";
    }
    private int bitField0_;
    public static final int CONFIG_VERSION_FIELD_NUMBER = 1;
    private int configVersion_;
    /**
     * <pre>
     * config version, corresponding to the suffix of config file
     * </pre>
     *
     * <code>optional uint32 config_version = 1 [default = 0];</code>
     * @return Whether the configVersion field is set.
     */
    @java.lang.Override
    public boolean hasConfigVersion() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * config version, corresponding to the suffix of config file
     * </pre>
     *
     * <code>optional uint32 config_version = 1 [default = 0];</code>
     * @return The configVersion.
     */
    @java.lang.Override
    public int getConfigVersion() {
      return configVersion_;
    }
    /**
     * <pre>
     * config version, corresponding to the suffix of config file
     * </pre>
     *
     * <code>optional uint32 config_version = 1 [default = 0];</code>
     * @param value The configVersion to set.
     */
    private void setConfigVersion(int value) {
      bitField0_ |= 0x00000001;
      configVersion_ = value;
    }
    /**
     * <pre>
     * config version, corresponding to the suffix of config file
     * </pre>
     *
     * <code>optional uint32 config_version = 1 [default = 0];</code>
     */
    private void clearConfigVersion() {
      bitField0_ = (bitField0_ & ~0x00000001);
      configVersion_ = 0;
    }

    public static final int LAST_MODIFIED_PRODUCT_VERSION_FIELD_NUMBER = 2;
    private java.lang.String lastModifiedProductVersion_;
    /**
     * <pre>
     * The product version that wrote this config
     * </pre>
     *
     * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
     * @return Whether the lastModifiedProductVersion field is set.
     */
    @java.lang.Override
    public boolean hasLastModifiedProductVersion() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * The product version that wrote this config
     * </pre>
     *
     * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
     * @return The lastModifiedProductVersion.
     */
    @java.lang.Override
    public java.lang.String getLastModifiedProductVersion() {
      return lastModifiedProductVersion_;
    }
    /**
     * <pre>
     * The product version that wrote this config
     * </pre>
     *
     * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
     * @return The bytes for lastModifiedProductVersion.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getLastModifiedProductVersionBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(lastModifiedProductVersion_);
    }
    /**
     * <pre>
     * The product version that wrote this config
     * </pre>
     *
     * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
     * @param value The lastModifiedProductVersion to set.
     */
    private void setLastModifiedProductVersion(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000002;
      lastModifiedProductVersion_ = value;
    }
    /**
     * <pre>
     * The product version that wrote this config
     * </pre>
     *
     * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
     */
    private void clearLastModifiedProductVersion() {
      bitField0_ = (bitField0_ & ~0x00000002);
      lastModifiedProductVersion_ = getDefaultInstance().getLastModifiedProductVersion();
    }
    /**
     * <pre>
     * The product version that wrote this config
     * </pre>
     *
     * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
     * @param value The bytes for lastModifiedProductVersion to set.
     */
    private void setLastModifiedProductVersionBytes(
        com.google.protobuf.ByteString value) {
      lastModifiedProductVersion_ = value.toStringUtf8();
      bitField0_ |= 0x00000002;
    }

    public static final int LAST_MODIFIED_TIME_FIELD_NUMBER = 3;
    private long lastModifiedTime_;
    /**
     * <pre>
     * last modified time in UTC second
     * </pre>
     *
     * <code>optional uint64 last_modified_time = 3 [default = 0, jstype = JS_STRING];</code>
     * @return Whether the lastModifiedTime field is set.
     */
    @java.lang.Override
    public boolean hasLastModifiedTime() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * last modified time in UTC second
     * </pre>
     *
     * <code>optional uint64 last_modified_time = 3 [default = 0, jstype = JS_STRING];</code>
     * @return The lastModifiedTime.
     */
    @java.lang.Override
    public long getLastModifiedTime() {
      return lastModifiedTime_;
    }
    /**
     * <pre>
     * last modified time in UTC second
     * </pre>
     *
     * <code>optional uint64 last_modified_time = 3 [default = 0, jstype = JS_STRING];</code>
     * @param value The lastModifiedTime to set.
     */
    private void setLastModifiedTime(long value) {
      bitField0_ |= 0x00000004;
      lastModifiedTime_ = value;
    }
    /**
     * <pre>
     * last modified time in UTC second
     * </pre>
     *
     * <code>optional uint64 last_modified_time = 3 [default = 0, jstype = JS_STRING];</code>
     */
    private void clearLastModifiedTime() {
      bitField0_ = (bitField0_ & ~0x00000004);
      lastModifiedTime_ = 0L;
    }

    public static final int PLATFORM_FIELD_NUMBER = 4;
    private java.lang.String platform_;
    /**
     * <pre>
     * These fields are not used now
     * platform of machine that wrote this config
     * </pre>
     *
     * <code>optional string platform = 4 [default = ""];</code>
     * @return Whether the platform field is set.
     */
    @java.lang.Override
    public boolean hasPlatform() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * These fields are not used now
     * platform of machine that wrote this config
     * </pre>
     *
     * <code>optional string platform = 4 [default = ""];</code>
     * @return The platform.
     */
    @java.lang.Override
    public java.lang.String getPlatform() {
      return platform_;
    }
    /**
     * <pre>
     * These fields are not used now
     * platform of machine that wrote this config
     * </pre>
     *
     * <code>optional string platform = 4 [default = ""];</code>
     * @return The bytes for platform.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPlatformBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(platform_);
    }
    /**
     * <pre>
     * These fields are not used now
     * platform of machine that wrote this config
     * </pre>
     *
     * <code>optional string platform = 4 [default = ""];</code>
     * @param value The platform to set.
     */
    private void setPlatform(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000008;
      platform_ = value;
    }
    /**
     * <pre>
     * These fields are not used now
     * platform of machine that wrote this config
     * </pre>
     *
     * <code>optional string platform = 4 [default = ""];</code>
     */
    private void clearPlatform() {
      bitField0_ = (bitField0_ & ~0x00000008);
      platform_ = getDefaultInstance().getPlatform();
    }
    /**
     * <pre>
     * These fields are not used now
     * platform of machine that wrote this config
     * </pre>
     *
     * <code>optional string platform = 4 [default = ""];</code>
     * @param value The bytes for platform to set.
     */
    private void setPlatformBytes(
        com.google.protobuf.ByteString value) {
      platform_ = value.toStringUtf8();
      bitField0_ |= 0x00000008;
    }

    public static final int UI_LOCALE_FIELD_NUMBER = 5;
    private java.lang.String uiLocale_;
    /**
     * <pre>
     * UI locale of machine that wrote this config
     * </pre>
     *
     * <code>optional string ui_locale = 5 [default = ""];</code>
     * @return Whether the uiLocale field is set.
     */
    @java.lang.Override
    public boolean hasUiLocale() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * UI locale of machine that wrote this config
     * </pre>
     *
     * <code>optional string ui_locale = 5 [default = ""];</code>
     * @return The uiLocale.
     */
    @java.lang.Override
    public java.lang.String getUiLocale() {
      return uiLocale_;
    }
    /**
     * <pre>
     * UI locale of machine that wrote this config
     * </pre>
     *
     * <code>optional string ui_locale = 5 [default = ""];</code>
     * @return The bytes for uiLocale.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getUiLocaleBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(uiLocale_);
    }
    /**
     * <pre>
     * UI locale of machine that wrote this config
     * </pre>
     *
     * <code>optional string ui_locale = 5 [default = ""];</code>
     * @param value The uiLocale to set.
     */
    private void setUiLocale(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000010;
      uiLocale_ = value;
    }
    /**
     * <pre>
     * UI locale of machine that wrote this config
     * </pre>
     *
     * <code>optional string ui_locale = 5 [default = ""];</code>
     */
    private void clearUiLocale() {
      bitField0_ = (bitField0_ & ~0x00000010);
      uiLocale_ = getDefaultInstance().getUiLocale();
    }
    /**
     * <pre>
     * UI locale of machine that wrote this config
     * </pre>
     *
     * <code>optional string ui_locale = 5 [default = ""];</code>
     * @param value The bytes for uiLocale to set.
     */
    private void setUiLocaleBytes(
        com.google.protobuf.ByteString value) {
      uiLocale_ = value.toStringUtf8();
      bitField0_ |= 0x00000010;
    }

    public static final int UPLOAD_USAGE_STATS_FIELD_NUMBER = 6;
    private boolean uploadUsageStats_;
    /**
     * <pre>
     * Whether to upload usage stats
     * This flag is used only for Android.
     * </pre>
     *
     * <code>optional bool upload_usage_stats = 6 [default = false];</code>
     * @return Whether the uploadUsageStats field is set.
     */
    @java.lang.Override
    public boolean hasUploadUsageStats() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * Whether to upload usage stats
     * This flag is used only for Android.
     * </pre>
     *
     * <code>optional bool upload_usage_stats = 6 [default = false];</code>
     * @return The uploadUsageStats.
     */
    @java.lang.Override
    public boolean getUploadUsageStats() {
      return uploadUsageStats_;
    }
    /**
     * <pre>
     * Whether to upload usage stats
     * This flag is used only for Android.
     * </pre>
     *
     * <code>optional bool upload_usage_stats = 6 [default = false];</code>
     * @param value The uploadUsageStats to set.
     */
    private void setUploadUsageStats(boolean value) {
      bitField0_ |= 0x00000020;
      uploadUsageStats_ = value;
    }
    /**
     * <pre>
     * Whether to upload usage stats
     * This flag is used only for Android.
     * </pre>
     *
     * <code>optional bool upload_usage_stats = 6 [default = false];</code>
     */
    private void clearUploadUsageStats() {
      bitField0_ = (bitField0_ & ~0x00000020);
      uploadUsageStats_ = false;
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * General config (1-9)
     * </pre>
     *
     * Protobuf type {@code mozc.config.GeneralConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig, Builder> implements
        // @@protoc_insertion_point(builder_implements:mozc.config.GeneralConfig)
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfigOrBuilder {
      // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * config version, corresponding to the suffix of config file
       * </pre>
       *
       * <code>optional uint32 config_version = 1 [default = 0];</code>
       * @return Whether the configVersion field is set.
       */
      @java.lang.Override
      public boolean hasConfigVersion() {
        return instance.hasConfigVersion();
      }
      /**
       * <pre>
       * config version, corresponding to the suffix of config file
       * </pre>
       *
       * <code>optional uint32 config_version = 1 [default = 0];</code>
       * @return The configVersion.
       */
      @java.lang.Override
      public int getConfigVersion() {
        return instance.getConfigVersion();
      }
      /**
       * <pre>
       * config version, corresponding to the suffix of config file
       * </pre>
       *
       * <code>optional uint32 config_version = 1 [default = 0];</code>
       * @param value The configVersion to set.
       * @return This builder for chaining.
       */
      public Builder setConfigVersion(int value) {
        copyOnWrite();
        instance.setConfigVersion(value);
        return this;
      }
      /**
       * <pre>
       * config version, corresponding to the suffix of config file
       * </pre>
       *
       * <code>optional uint32 config_version = 1 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearConfigVersion() {
        copyOnWrite();
        instance.clearConfigVersion();
        return this;
      }

      /**
       * <pre>
       * The product version that wrote this config
       * </pre>
       *
       * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
       * @return Whether the lastModifiedProductVersion field is set.
       */
      @java.lang.Override
      public boolean hasLastModifiedProductVersion() {
        return instance.hasLastModifiedProductVersion();
      }
      /**
       * <pre>
       * The product version that wrote this config
       * </pre>
       *
       * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
       * @return The lastModifiedProductVersion.
       */
      @java.lang.Override
      public java.lang.String getLastModifiedProductVersion() {
        return instance.getLastModifiedProductVersion();
      }
      /**
       * <pre>
       * The product version that wrote this config
       * </pre>
       *
       * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
       * @return The bytes for lastModifiedProductVersion.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getLastModifiedProductVersionBytes() {
        return instance.getLastModifiedProductVersionBytes();
      }
      /**
       * <pre>
       * The product version that wrote this config
       * </pre>
       *
       * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
       * @param value The lastModifiedProductVersion to set.
       * @return This builder for chaining.
       */
      public Builder setLastModifiedProductVersion(
          java.lang.String value) {
        copyOnWrite();
        instance.setLastModifiedProductVersion(value);
        return this;
      }
      /**
       * <pre>
       * The product version that wrote this config
       * </pre>
       *
       * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
       * @return This builder for chaining.
       */
      public Builder clearLastModifiedProductVersion() {
        copyOnWrite();
        instance.clearLastModifiedProductVersion();
        return this;
      }
      /**
       * <pre>
       * The product version that wrote this config
       * </pre>
       *
       * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
       * @param value The bytes for lastModifiedProductVersion to set.
       * @return This builder for chaining.
       */
      public Builder setLastModifiedProductVersionBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setLastModifiedProductVersionBytes(value);
        return this;
      }

      /**
       * <pre>
       * last modified time in UTC second
       * </pre>
       *
       * <code>optional uint64 last_modified_time = 3 [default = 0, jstype = JS_STRING];</code>
       * @return Whether the lastModifiedTime field is set.
       */
      @java.lang.Override
      public boolean hasLastModifiedTime() {
        return instance.hasLastModifiedTime();
      }
      /**
       * <pre>
       * last modified time in UTC second
       * </pre>
       *
       * <code>optional uint64 last_modified_time = 3 [default = 0, jstype = JS_STRING];</code>
       * @return The lastModifiedTime.
       */
      @java.lang.Override
      public long getLastModifiedTime() {
        return instance.getLastModifiedTime();
      }
      /**
       * <pre>
       * last modified time in UTC second
       * </pre>
       *
       * <code>optional uint64 last_modified_time = 3 [default = 0, jstype = JS_STRING];</code>
       * @param value The lastModifiedTime to set.
       * @return This builder for chaining.
       */
      public Builder setLastModifiedTime(long value) {
        copyOnWrite();
        instance.setLastModifiedTime(value);
        return this;
      }
      /**
       * <pre>
       * last modified time in UTC second
       * </pre>
       *
       * <code>optional uint64 last_modified_time = 3 [default = 0, jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearLastModifiedTime() {
        copyOnWrite();
        instance.clearLastModifiedTime();
        return this;
      }

      /**
       * <pre>
       * These fields are not used now
       * platform of machine that wrote this config
       * </pre>
       *
       * <code>optional string platform = 4 [default = ""];</code>
       * @return Whether the platform field is set.
       */
      @java.lang.Override
      public boolean hasPlatform() {
        return instance.hasPlatform();
      }
      /**
       * <pre>
       * These fields are not used now
       * platform of machine that wrote this config
       * </pre>
       *
       * <code>optional string platform = 4 [default = ""];</code>
       * @return The platform.
       */
      @java.lang.Override
      public java.lang.String getPlatform() {
        return instance.getPlatform();
      }
      /**
       * <pre>
       * These fields are not used now
       * platform of machine that wrote this config
       * </pre>
       *
       * <code>optional string platform = 4 [default = ""];</code>
       * @return The bytes for platform.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getPlatformBytes() {
        return instance.getPlatformBytes();
      }
      /**
       * <pre>
       * These fields are not used now
       * platform of machine that wrote this config
       * </pre>
       *
       * <code>optional string platform = 4 [default = ""];</code>
       * @param value The platform to set.
       * @return This builder for chaining.
       */
      public Builder setPlatform(
          java.lang.String value) {
        copyOnWrite();
        instance.setPlatform(value);
        return this;
      }
      /**
       * <pre>
       * These fields are not used now
       * platform of machine that wrote this config
       * </pre>
       *
       * <code>optional string platform = 4 [default = ""];</code>
       * @return This builder for chaining.
       */
      public Builder clearPlatform() {
        copyOnWrite();
        instance.clearPlatform();
        return this;
      }
      /**
       * <pre>
       * These fields are not used now
       * platform of machine that wrote this config
       * </pre>
       *
       * <code>optional string platform = 4 [default = ""];</code>
       * @param value The bytes for platform to set.
       * @return This builder for chaining.
       */
      public Builder setPlatformBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPlatformBytes(value);
        return this;
      }

      /**
       * <pre>
       * UI locale of machine that wrote this config
       * </pre>
       *
       * <code>optional string ui_locale = 5 [default = ""];</code>
       * @return Whether the uiLocale field is set.
       */
      @java.lang.Override
      public boolean hasUiLocale() {
        return instance.hasUiLocale();
      }
      /**
       * <pre>
       * UI locale of machine that wrote this config
       * </pre>
       *
       * <code>optional string ui_locale = 5 [default = ""];</code>
       * @return The uiLocale.
       */
      @java.lang.Override
      public java.lang.String getUiLocale() {
        return instance.getUiLocale();
      }
      /**
       * <pre>
       * UI locale of machine that wrote this config
       * </pre>
       *
       * <code>optional string ui_locale = 5 [default = ""];</code>
       * @return The bytes for uiLocale.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getUiLocaleBytes() {
        return instance.getUiLocaleBytes();
      }
      /**
       * <pre>
       * UI locale of machine that wrote this config
       * </pre>
       *
       * <code>optional string ui_locale = 5 [default = ""];</code>
       * @param value The uiLocale to set.
       * @return This builder for chaining.
       */
      public Builder setUiLocale(
          java.lang.String value) {
        copyOnWrite();
        instance.setUiLocale(value);
        return this;
      }
      /**
       * <pre>
       * UI locale of machine that wrote this config
       * </pre>
       *
       * <code>optional string ui_locale = 5 [default = ""];</code>
       * @return This builder for chaining.
       */
      public Builder clearUiLocale() {
        copyOnWrite();
        instance.clearUiLocale();
        return this;
      }
      /**
       * <pre>
       * UI locale of machine that wrote this config
       * </pre>
       *
       * <code>optional string ui_locale = 5 [default = ""];</code>
       * @param value The bytes for uiLocale to set.
       * @return This builder for chaining.
       */
      public Builder setUiLocaleBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setUiLocaleBytes(value);
        return this;
      }

      /**
       * <pre>
       * Whether to upload usage stats
       * This flag is used only for Android.
       * </pre>
       *
       * <code>optional bool upload_usage_stats = 6 [default = false];</code>
       * @return Whether the uploadUsageStats field is set.
       */
      @java.lang.Override
      public boolean hasUploadUsageStats() {
        return instance.hasUploadUsageStats();
      }
      /**
       * <pre>
       * Whether to upload usage stats
       * This flag is used only for Android.
       * </pre>
       *
       * <code>optional bool upload_usage_stats = 6 [default = false];</code>
       * @return The uploadUsageStats.
       */
      @java.lang.Override
      public boolean getUploadUsageStats() {
        return instance.getUploadUsageStats();
      }
      /**
       * <pre>
       * Whether to upload usage stats
       * This flag is used only for Android.
       * </pre>
       *
       * <code>optional bool upload_usage_stats = 6 [default = false];</code>
       * @param value The uploadUsageStats to set.
       * @return This builder for chaining.
       */
      public Builder setUploadUsageStats(boolean value) {
        copyOnWrite();
        instance.setUploadUsageStats(value);
        return this;
      }
      /**
       * <pre>
       * Whether to upload usage stats
       * This flag is used only for Android.
       * </pre>
       *
       * <code>optional bool upload_usage_stats = 6 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearUploadUsageStats() {
        copyOnWrite();
        instance.clearUploadUsageStats();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:mozc.config.GeneralConfig)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "configVersion_",
              "lastModifiedProductVersion_",
              "lastModifiedTime_",
              "platform_",
              "uiLocale_",
              "uploadUsageStats_",
            };
            java.lang.String info =
                "\u0001\u0006\u0000\u0001\u0001\u0006\u0006\u0000\u0000\u0000\u0001\u100b\u0000\u0002" +
                "\u1008\u0001\u0003\u1003\u0002\u0004\u1008\u0003\u0005\u1008\u0004\u0006\u1007\u0005" +
                "";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig> parser = PARSER;
          if (parser == null) {
            synchronized (org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:mozc.config.GeneralConfig)
    private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig DEFAULT_INSTANCE;
    static {
      GeneralConfig defaultInstance = new GeneralConfig();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        GeneralConfig.class, defaultInstance);
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<GeneralConfig> PARSER;

    public static com.google.protobuf.Parser<GeneralConfig> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mozc.config.Config)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * General config and logging/debugging:
     * We won't use 2-9 and 20-39 ids anymore for historical reasons.
     * </pre>
     *
     * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
     * @return Whether the generalConfig field is set.
     */
    boolean hasGeneralConfig();
    /**
     * <pre>
     * General config and logging/debugging:
     * We won't use 2-9 and 20-39 ids anymore for historical reasons.
     * </pre>
     *
     * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
     * @return The generalConfig.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig getGeneralConfig();

    /**
     * <pre>
     * set verbose level of logging library (FLAGS_v)
     * </pre>
     *
     * <code>optional int32 verbose_level = 10 [default = 0];</code>
     * @return Whether the verboseLevel field is set.
     */
    boolean hasVerboseLevel();
    /**
     * <pre>
     * set verbose level of logging library (FLAGS_v)
     * </pre>
     *
     * <code>optional int32 verbose_level = 10 [default = 0];</code>
     * @return The verboseLevel.
     */
    int getVerboseLevel();

    /**
     * <pre>
     * Incognito mode:
     * Disable all mutable operation if incognito_mode is true
     * Clients needs to check ConversionRequest::incognito_mode() instead
     * of Config::incognito_mode(), as the incoginto mode can also set
     * via Options.
     * </pre>
     *
     * <code>optional bool incognito_mode = 20 [default = false];</code>
     * @return Whether the incognitoMode field is set.
     */
    boolean hasIncognitoMode();
    /**
     * <pre>
     * Incognito mode:
     * Disable all mutable operation if incognito_mode is true
     * Clients needs to check ConversionRequest::incognito_mode() instead
     * of Config::incognito_mode(), as the incoginto mode can also set
     * via Options.
     * </pre>
     *
     * <code>optional bool incognito_mode = 20 [default = false];</code>
     * @return The incognitoMode.
     */
    boolean getIncognitoMode();

    /**
     * <pre>
     * whether to show the set default dialog on startup
     * </pre>
     *
     * <code>optional bool check_default = 22 [default = true];</code>
     * @return Whether the checkDefault field is set.
     */
    boolean hasCheckDefault();
    /**
     * <pre>
     * whether to show the set default dialog on startup
     * </pre>
     *
     * <code>optional bool check_default = 22 [default = true];</code>
     * @return The checkDefault.
     */
    boolean getCheckDefault();

    /**
     * <pre>
     * Presentation mode:
     * disable all suggestion temporally.
     * </pre>
     *
     * <code>optional bool presentation_mode = 23 [default = false];</code>
     * @return Whether the presentationMode field is set.
     */
    boolean hasPresentationMode();
    /**
     * <pre>
     * Presentation mode:
     * disable all suggestion temporally.
     * </pre>
     *
     * <code>optional bool presentation_mode = 23 [default = false];</code>
     * @return The presentationMode.
     */
    boolean getPresentationMode();

    /**
     * <pre>
     * Roman/Kana
     * </pre>
     *
     * <code>optional .mozc.config.Config.PreeditMethod preedit_method = 40 [default = ROMAN];</code>
     * @return Whether the preeditMethod field is set.
     */
    boolean hasPreeditMethod();
    /**
     * <pre>
     * Roman/Kana
     * </pre>
     *
     * <code>optional .mozc.config.Config.PreeditMethod preedit_method = 40 [default = ROMAN];</code>
     * @return The preeditMethod.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod getPreeditMethod();

    /**
     * <code>optional .mozc.config.Config.SessionKeymap session_keymap = 41 [default = NONE];</code>
     * @return Whether the sessionKeymap field is set.
     */
    boolean hasSessionKeymap();
    /**
     * <code>optional .mozc.config.Config.SessionKeymap session_keymap = 41 [default = NONE];</code>
     * @return The sessionKeymap.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap getSessionKeymap();

    /**
     * <pre>
     * custom keymap
     * TODO(taku): replace it with repeated field
     * </pre>
     *
     * <code>optional bytes custom_keymap_table = 42;</code>
     * @return Whether the customKeymapTable field is set.
     */
    boolean hasCustomKeymapTable();
    /**
     * <pre>
     * custom keymap
     * TODO(taku): replace it with repeated field
     * </pre>
     *
     * <code>optional bytes custom_keymap_table = 42;</code>
     * @return The customKeymapTable.
     */
    com.google.protobuf.ByteString getCustomKeymapTable();

    /**
     * <pre>
     * custom roman table
     * </pre>
     *
     * <code>optional bytes custom_roman_table = 43;</code>
     * @return Whether the customRomanTable field is set.
     */
    boolean hasCustomRomanTable();
    /**
     * <pre>
     * custom roman table
     * </pre>
     *
     * <code>optional bytes custom_roman_table = 43;</code>
     * @return The customRomanTable.
     */
    com.google.protobuf.ByteString getCustomRomanTable();

    /**
     * <code>optional .mozc.config.Config.PunctuationMethod punctuation_method = 45 [default = TOUTEN_KUTEN];</code>
     * @return Whether the punctuationMethod field is set.
     */
    boolean hasPunctuationMethod();
    /**
     * <code>optional .mozc.config.Config.PunctuationMethod punctuation_method = 45 [default = TOUTEN_KUTEN];</code>
     * @return The punctuationMethod.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod getPunctuationMethod();

    /**
     * <code>optional .mozc.config.Config.SymbolMethod symbol_method = 46 [default = CORNER_BRACKET_MIDDLE_DOT];</code>
     * @return Whether the symbolMethod field is set.
     */
    boolean hasSymbolMethod();
    /**
     * <code>optional .mozc.config.Config.SymbolMethod symbol_method = 46 [default = CORNER_BRACKET_MIDDLE_DOT];</code>
     * @return The symbolMethod.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod getSymbolMethod();

    /**
     * <code>optional .mozc.config.Config.FundamentalCharacterForm space_character_form = 47 [default = FUNDAMENTAL_INPUT_MODE];</code>
     * @return Whether the spaceCharacterForm field is set.
     */
    boolean hasSpaceCharacterForm();
    /**
     * <code>optional .mozc.config.Config.FundamentalCharacterForm space_character_form = 47 [default = FUNDAMENTAL_INPUT_MODE];</code>
     * @return The spaceCharacterForm.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm getSpaceCharacterForm();

    /**
     * <pre>
     * If this flag is true, Mozc toggles preedit method with some predefined
     * key events when IME is turned on.  Otherwise, Mozc ignores such kind of
     * key events so that their preferred can be preserved even when the toggle
     * key is pressed by accident.
     * As for Mozc, only Windows client supports such kind of toggle so this flag
     * is currently valid only on Windows.
     * Background:
     *   Traditional Japanese IMEs have used "Roma-Ji" key in Japanese 106/109
     *   keyboard to toggle the preedit method between Roman and Kana style and
     *   this behavior was finally adopted into JIS X 4064:2002 as a basic
     *   functionality which is expected to support by a Japanese Input Method.
     *   However, people who are not aware of this functionality have been
     *   puzzled because the default key stroke is likely to be pressed
     *   by accident.
     * </pre>
     *
     * <code>optional bool use_keyboard_to_change_preedit_method = 48 [default = false];</code>
     * @return Whether the useKeyboardToChangePreeditMethod field is set.
     */
    boolean hasUseKeyboardToChangePreeditMethod();
    /**
     * <pre>
     * If this flag is true, Mozc toggles preedit method with some predefined
     * key events when IME is turned on.  Otherwise, Mozc ignores such kind of
     * key events so that their preferred can be preserved even when the toggle
     * key is pressed by accident.
     * As for Mozc, only Windows client supports such kind of toggle so this flag
     * is currently valid only on Windows.
     * Background:
     *   Traditional Japanese IMEs have used "Roma-Ji" key in Japanese 106/109
     *   keyboard to toggle the preedit method between Roman and Kana style and
     *   this behavior was finally adopted into JIS X 4064:2002 as a basic
     *   functionality which is expected to support by a Japanese Input Method.
     *   However, people who are not aware of this functionality have been
     *   puzzled because the default key stroke is likely to be pressed
     *   by accident.
     * </pre>
     *
     * <code>optional bool use_keyboard_to_change_preedit_method = 48 [default = false];</code>
     * @return The useKeyboardToChangePreeditMethod.
     */
    boolean getUseKeyboardToChangePreeditMethod();

    /**
     * <code>optional .mozc.config.Config.HistoryLearningLevel history_learning_level = 50 [default = DEFAULT_HISTORY];</code>
     * @return Whether the historyLearningLevel field is set.
     */
    boolean hasHistoryLearningLevel();
    /**
     * <code>optional .mozc.config.Config.HistoryLearningLevel history_learning_level = 50 [default = DEFAULT_HISTORY];</code>
     * @return The historyLearningLevel.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel getHistoryLearningLevel();

    /**
     * <code>optional .mozc.config.Config.SelectionShortcut selection_shortcut = 52 [default = SHORTCUT_123456789];</code>
     * @return Whether the selectionShortcut field is set.
     */
    boolean hasSelectionShortcut();
    /**
     * <code>optional .mozc.config.Config.SelectionShortcut selection_shortcut = 52 [default = SHORTCUT_123456789];</code>
     * @return The selectionShortcut.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut getSelectionShortcut();

    /**
     * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
     */
    java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule> 
        getCharacterFormRulesList();
    /**
     * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule getCharacterFormRules(int index);
    /**
     * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
     */
    int getCharacterFormRulesCount();

    /**
     * <pre>
     * Automatically switch composition mode.
     * </pre>
     *
     * <code>optional bool auto_switch_composition_mode = 56 [default = true];</code>
     * @return Whether the autoSwitchCompositionMode field is set.
     */
    boolean hasAutoSwitchCompositionMode();
    /**
     * <pre>
     * Automatically switch composition mode.
     * </pre>
     *
     * <code>optional bool auto_switch_composition_mode = 56 [default = true];</code>
     * @return The autoSwitchCompositionMode.
     */
    boolean getAutoSwitchCompositionMode();

    /**
     * <pre>
     * Toggle to use cascanding window for debugging.
     * </pre>
     *
     * <code>optional bool use_cascading_window = 58 [default = true];</code>
     * @return Whether the useCascadingWindow field is set.
     */
    boolean hasUseCascadingWindow();
    /**
     * <pre>
     * Toggle to use cascanding window for debugging.
     * </pre>
     *
     * <code>optional bool use_cascading_window = 58 [default = true];</code>
     * @return The useCascadingWindow.
     */
    boolean getUseCascadingWindow();

    /**
     * <code>optional .mozc.config.Config.ShiftKeyModeSwitch shift_key_mode_switch = 59 [default = ASCII_INPUT_MODE];</code>
     * @return Whether the shiftKeyModeSwitch field is set.
     */
    boolean hasShiftKeyModeSwitch();
    /**
     * <code>optional .mozc.config.Config.ShiftKeyModeSwitch shift_key_mode_switch = 59 [default = ASCII_INPUT_MODE];</code>
     * @return The shiftKeyModeSwitch.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch getShiftKeyModeSwitch();

    /**
     * <code>optional .mozc.config.Config.NumpadCharacterForm numpad_character_form = 60 [default = NUMPAD_HALF_WIDTH];</code>
     * @return Whether the numpadCharacterForm field is set.
     */
    boolean hasNumpadCharacterForm();
    /**
     * <code>optional .mozc.config.Config.NumpadCharacterForm numpad_character_form = 60 [default = NUMPAD_HALF_WIDTH];</code>
     * @return The numpadCharacterForm.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm getNumpadCharacterForm();

    /**
     * <code>optional bool use_auto_conversion = 61 [default = false];</code>
     * @return Whether the useAutoConversion field is set.
     */
    boolean hasUseAutoConversion();
    /**
     * <code>optional bool use_auto_conversion = 61 [default = false];</code>
     * @return The useAutoConversion.
     */
    boolean getUseAutoConversion();

    /**
     * <pre>
     * can't use AutoConversionKey as a type since
     * undefined enum type is not correctly handled.
     * </pre>
     *
     * <code>optional uint32 auto_conversion_key = 62 [default = 13];</code>
     * @return Whether the autoConversionKey field is set.
     */
    boolean hasAutoConversionKey();
    /**
     * <pre>
     * can't use AutoConversionKey as a type since
     * undefined enum type is not correctly handled.
     * </pre>
     *
     * <code>optional uint32 auto_conversion_key = 62 [default = 13];</code>
     * @return The autoConversionKey.
     */
    int getAutoConversionKey();

    /**
     * <pre>
     * Mac-original JIS key layout has "yen-sign" key which generates
     * U+00A5 instead of U+005C and sometimes users get troubles with
     * them because they expect backslashes which are rendered as
     * yen-sign.  If this configuration is BACKSLASH, Mozc will
     * interpret U+005C even when the original key event is U+00A5.
     * </pre>
     *
     * <code>optional .mozc.config.Config.YenSignCharacter yen_sign_character = 63 [default = YEN_SIGN];</code>
     * @return Whether the yenSignCharacter field is set.
     */
    boolean hasYenSignCharacter();
    /**
     * <pre>
     * Mac-original JIS key layout has "yen-sign" key which generates
     * U+00A5 instead of U+005C and sometimes users get troubles with
     * them because they expect backslashes which are rendered as
     * yen-sign.  If this configuration is BACKSLASH, Mozc will
     * interpret U+005C even when the original key event is U+00A5.
     * </pre>
     *
     * <code>optional .mozc.config.Config.YenSignCharacter yen_sign_character = 63 [default = YEN_SIGN];</code>
     * @return The yenSignCharacter.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter getYenSignCharacter();

    /**
     * <pre>
     * Use Japanese keyboard layout even when the user uses other
     * keyboard layouts.  In Mac OSX people can use several keyboard
     * layouts such like French or Spanish but some people want to use
     * Japanese layout for Japanese.  See http://b/2917320
     * </pre>
     *
     * <code>optional bool use_japanese_layout = 64 [default = false];</code>
     * @return Whether the useJapaneseLayout field is set.
     */
    boolean hasUseJapaneseLayout();
    /**
     * <pre>
     * Use Japanese keyboard layout even when the user uses other
     * keyboard layouts.  In Mac OSX people can use several keyboard
     * layouts such like French or Spanish but some people want to use
     * Japanese layout for Japanese.  See http://b/2917320
     * </pre>
     *
     * <code>optional bool use_japanese_layout = 64 [default = false];</code>
     * @return The useJapaneseLayout.
     */
    boolean getUseJapaneseLayout();

    /**
     * <pre>
     * Use kana modifier insensitive conversion.
     * e.g.  -&gt; 
     * Note that Request message has the same field.
     * - Request's one is controlled by the client. A user cannot control it.
     *   On the other hand Config's is under a user's control.
     * - Whether the feature is activated or not is decided by logical-AND
     *   of Request's and Config's.
     * </pre>
     *
     * <code>optional bool use_kana_modifier_insensitive_conversion = 65 [default = false];</code>
     * @return Whether the useKanaModifierInsensitiveConversion field is set.
     */
    boolean hasUseKanaModifierInsensitiveConversion();
    /**
     * <pre>
     * Use kana modifier insensitive conversion.
     * e.g.  -&gt; 
     * Note that Request message has the same field.
     * - Request's one is controlled by the client. A user cannot control it.
     *   On the other hand Config's is under a user's control.
     * - Whether the feature is activated or not is decided by logical-AND
     *   of Request's and Config's.
     * </pre>
     *
     * <code>optional bool use_kana_modifier_insensitive_conversion = 65 [default = false];</code>
     * @return The useKanaModifierInsensitiveConversion.
     */
    boolean getUseKanaModifierInsensitiveConversion();

    /**
     * <pre>
     * Use typing correction feature.
     * e.g. sunkai -&gt; 
     * </pre>
     *
     * <code>optional bool use_typing_correction = 66 [default = false];</code>
     * @return Whether the useTypingCorrection field is set.
     */
    boolean hasUseTypingCorrection();
    /**
     * <pre>
     * Use typing correction feature.
     * e.g. sunkai -&gt; 
     * </pre>
     *
     * <code>optional bool use_typing_correction = 66 [default = false];</code>
     * @return The useTypingCorrection.
     */
    boolean getUseTypingCorrection();

    /**
     * <pre>
     * The duration in millisecond to determine the timeout.
     * If the duration between key inputs is more than this value,
     * a SessionCommand::STOP_KEY_TOGGLING is prepended to the next key input.
     * If the value is 0, STOP_KEY_TOGGLING is not sent.
     * </pre>
     *
     * <code>optional int32 composing_timeout_threshold_msec = 67 [default = 0];</code>
     * @return Whether the composingTimeoutThresholdMsec field is set.
     */
    boolean hasComposingTimeoutThresholdMsec();
    /**
     * <pre>
     * The duration in millisecond to determine the timeout.
     * If the duration between key inputs is more than this value,
     * a SessionCommand::STOP_KEY_TOGGLING is prepended to the next key input.
     * If the value is 0, STOP_KEY_TOGGLING is not sent.
     * </pre>
     *
     * <code>optional int32 composing_timeout_threshold_msec = 67 [default = 0];</code>
     * @return The composingTimeoutThresholdMsec.
     */
    int getComposingTimeoutThresholdMsec();

    /**
     * <pre>
     * The keymaps which are loaded on top of `session_keymap`.
     * Overlay keymaps are prioritized over `session_keymap`.
     * They are used to partially modify the session keymap, for example
     * using Henkan key as IME_ON.
     * </pre>
     *
     * <code>repeated .mozc.config.Config.SessionKeymap overlay_keymaps = 68 [packed = true];</code>
     * @return A list containing the overlayKeymaps.
     */
    java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap> getOverlayKeymapsList();
    /**
     * <pre>
     * The keymaps which are loaded on top of `session_keymap`.
     * Overlay keymaps are prioritized over `session_keymap`.
     * They are used to partially modify the session keymap, for example
     * using Henkan key as IME_ON.
     * </pre>
     *
     * <code>repeated .mozc.config.Config.SessionKeymap overlay_keymaps = 68 [packed = true];</code>
     * @return The count of overlayKeymaps.
     */
    int getOverlayKeymapsCount();
    /**
     * <pre>
     * The keymaps which are loaded on top of `session_keymap`.
     * Overlay keymaps are prioritized over `session_keymap`.
     * They are used to partially modify the session keymap, for example
     * using Henkan key as IME_ON.
     * </pre>
     *
     * <code>repeated .mozc.config.Config.SessionKeymap overlay_keymaps = 68 [packed = true];</code>
     * @param index The index of the element to return.
     * @return The overlayKeymaps at the given index.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap getOverlayKeymaps(int index);

    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Dictionary (80-99)
     * </pre>
     *
     * <code>optional bool use_date_conversion = 80 [default = true];</code>
     * @return Whether the useDateConversion field is set.
     */
    boolean hasUseDateConversion();
    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Dictionary (80-99)
     * </pre>
     *
     * <code>optional bool use_date_conversion = 80 [default = true];</code>
     * @return The useDateConversion.
     */
    boolean getUseDateConversion();

    /**
     * <code>optional bool use_single_kanji_conversion = 81 [default = true];</code>
     * @return Whether the useSingleKanjiConversion field is set.
     */
    boolean hasUseSingleKanjiConversion();
    /**
     * <code>optional bool use_single_kanji_conversion = 81 [default = true];</code>
     * @return The useSingleKanjiConversion.
     */
    boolean getUseSingleKanjiConversion();

    /**
     * <code>optional bool use_symbol_conversion = 82 [default = true];</code>
     * @return Whether the useSymbolConversion field is set.
     */
    boolean hasUseSymbolConversion();
    /**
     * <code>optional bool use_symbol_conversion = 82 [default = true];</code>
     * @return The useSymbolConversion.
     */
    boolean getUseSymbolConversion();

    /**
     * <code>optional bool use_number_conversion = 83 [default = true];</code>
     * @return Whether the useNumberConversion field is set.
     */
    boolean hasUseNumberConversion();
    /**
     * <code>optional bool use_number_conversion = 83 [default = true];</code>
     * @return The useNumberConversion.
     */
    boolean getUseNumberConversion();

    /**
     * <code>optional bool use_emoticon_conversion = 84 [default = true];</code>
     * @return Whether the useEmoticonConversion field is set.
     */
    boolean hasUseEmoticonConversion();
    /**
     * <code>optional bool use_emoticon_conversion = 84 [default = true];</code>
     * @return The useEmoticonConversion.
     */
    boolean getUseEmoticonConversion();

    /**
     * <code>optional bool use_calculator = 85 [default = true];</code>
     * @return Whether the useCalculator field is set.
     */
    boolean hasUseCalculator();
    /**
     * <code>optional bool use_calculator = 85 [default = true];</code>
     * @return The useCalculator.
     */
    boolean getUseCalculator();

    /**
     * <code>optional bool use_t13n_conversion = 86 [default = true];</code>
     * @return Whether the useT13nConversion field is set.
     */
    boolean hasUseT13NConversion();
    /**
     * <code>optional bool use_t13n_conversion = 86 [default = true];</code>
     * @return The useT13nConversion.
     */
    boolean getUseT13NConversion();

    /**
     * <code>optional bool use_zip_code_conversion = 87 [default = true];</code>
     * @return Whether the useZipCodeConversion field is set.
     */
    boolean hasUseZipCodeConversion();
    /**
     * <code>optional bool use_zip_code_conversion = 87 [default = true];</code>
     * @return The useZipCodeConversion.
     */
    boolean getUseZipCodeConversion();

    /**
     * <code>optional bool use_spelling_correction = 88 [default = true];</code>
     * @return Whether the useSpellingCorrection field is set.
     */
    boolean hasUseSpellingCorrection();
    /**
     * <code>optional bool use_spelling_correction = 88 [default = true];</code>
     * @return The useSpellingCorrection.
     */
    boolean getUseSpellingCorrection();

    /**
     * <pre>
     * If use_emoji_conversion is true, the user can input emoji characters
     * by converting from a query string (e.g. "  " [U+1F436]).
     * Even if it is false, users might be able to input emoji characters
     * with other ways.
     * Note: Some characters can be either of text and emoji.  It would be ideal
     * to use the variation sequence to specify emoji presentation [U+FE0E],
     * although it is not implemented yet.
     * See: http://unicode.org/reports/tr51/#Presentation_Style
     * </pre>
     *
     * <code>optional bool use_emoji_conversion = 89 [default = false];</code>
     * @return Whether the useEmojiConversion field is set.
     */
    boolean hasUseEmojiConversion();
    /**
     * <pre>
     * If use_emoji_conversion is true, the user can input emoji characters
     * by converting from a query string (e.g. "  " [U+1F436]).
     * Even if it is false, users might be able to input emoji characters
     * with other ways.
     * Note: Some characters can be either of text and emoji.  It would be ideal
     * to use the variation sequence to specify emoji presentation [U+FE0E],
     * although it is not implemented yet.
     * See: http://unicode.org/reports/tr51/#Presentation_Style
     * </pre>
     *
     * <code>optional bool use_emoji_conversion = 89 [default = false];</code>
     * @return The useEmojiConversion.
     */
    boolean getUseEmojiConversion();

    /**
     * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
     * @return Whether the informationListConfig field is set.
     */
    boolean hasInformationListConfig();
    /**
     * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
     * @return The informationListConfig.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig getInformationListConfig();

    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Suggest (100-119)
     * Suggest is a feature of word suggestion with prefix search.
     * When you type "", you may get "", "" (), "" ()
     * as suggested words.
     * Use history-based suggest feature.
     * If this is true, your previously typed words are prioritized.
     * </pre>
     *
     * <code>optional bool use_history_suggest = 100 [default = true];</code>
     * @return Whether the useHistorySuggest field is set.
     */
    boolean hasUseHistorySuggest();
    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Suggest (100-119)
     * Suggest is a feature of word suggestion with prefix search.
     * When you type "", you may get "", "" (), "" ()
     * as suggested words.
     * Use history-based suggest feature.
     * If this is true, your previously typed words are prioritized.
     * </pre>
     *
     * <code>optional bool use_history_suggest = 100 [default = true];</code>
     * @return The useHistorySuggest.
     */
    boolean getUseHistorySuggest();

    /**
     * <pre>
     * Use dictionary-based suggest feature.
     * If this is true, words in the word dictionary are suggested even if
     * you haven't typed before.
     * </pre>
     *
     * <code>optional bool use_dictionary_suggest = 101 [default = true];</code>
     * @return Whether the useDictionarySuggest field is set.
     */
    boolean hasUseDictionarySuggest();
    /**
     * <pre>
     * Use dictionary-based suggest feature.
     * If this is true, words in the word dictionary are suggested even if
     * you haven't typed before.
     * </pre>
     *
     * <code>optional bool use_dictionary_suggest = 101 [default = true];</code>
     * @return The useDictionarySuggest.
     */
    boolean getUseDictionarySuggest();

    /**
     * <pre>
     * Use realtime conversion feature.
     * </pre>
     *
     * <code>optional bool use_realtime_conversion = 102 [default = true];</code>
     * @return Whether the useRealtimeConversion field is set.
     */
    boolean hasUseRealtimeConversion();
    /**
     * <pre>
     * Use realtime conversion feature.
     * </pre>
     *
     * <code>optional bool use_realtime_conversion = 102 [default = true];</code>
     * @return The useRealtimeConversion.
     */
    boolean getUseRealtimeConversion();

    /**
     * <pre>
     * Size of suggestions.
     * </pre>
     *
     * <code>optional uint32 suggestions_size = 110 [default = 3];</code>
     * @return Whether the suggestionsSize field is set.
     */
    boolean hasSuggestionsSize();
    /**
     * <pre>
     * Size of suggestions.
     * </pre>
     *
     * <code>optional uint32 suggestions_size = 110 [default = 3];</code>
     * @return The suggestionsSize.
     */
    int getSuggestionsSize();

    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Renderer (120-139)
     * Use mode indicator feature.
     * </pre>
     *
     * <code>optional bool use_mode_indicator = 120 [default = true];</code>
     * @return Whether the useModeIndicator field is set.
     */
    boolean hasUseModeIndicator();
    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Renderer (120-139)
     * Use mode indicator feature.
     * </pre>
     *
     * <code>optional bool use_mode_indicator = 120 [default = true];</code>
     * @return The useModeIndicator.
     */
    boolean getUseModeIndicator();
  }
  /**
   * Protobuf type {@code mozc.config.Config}
   */
  public  static final class Config extends
      com.google.protobuf.GeneratedMessageLite<
          Config, Config.Builder> implements
      // @@protoc_insertion_point(message_implements:mozc.config.Config)
      ConfigOrBuilder {
    private Config() {
      checkDefault_ = true;
      sessionKeymap_ = -1;
      customKeymapTable_ = com.google.protobuf.ByteString.EMPTY;
      customRomanTable_ = com.google.protobuf.ByteString.EMPTY;
      selectionShortcut_ = 1;
      characterFormRules_ = emptyProtobufList();
      autoSwitchCompositionMode_ = true;
      useCascadingWindow_ = true;
      shiftKeyModeSwitch_ = 1;
      numpadCharacterForm_ = 2;
      autoConversionKey_ = 13;
      overlayKeymaps_ = emptyIntList();
      useDateConversion_ = true;
      useSingleKanjiConversion_ = true;
      useSymbolConversion_ = true;
      useNumberConversion_ = true;
      useEmoticonConversion_ = true;
      useCalculator_ = true;
      useT13NConversion_ = true;
      useZipCodeConversion_ = true;
      useSpellingCorrection_ = true;
      useHistorySuggest_ = true;
      useDictionarySuggest_ = true;
      useRealtimeConversion_ = true;
      suggestionsSize_ = 3;
      useModeIndicator_ = true;
    }
    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Basic features (40-79)
     * </pre>
     *
     * Protobuf enum {@code mozc.config.Config.PreeditMethod}
     */
    public enum PreeditMethod
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>ROMAN = 0;</code>
       */
      ROMAN(0),
      /**
       * <code>KANA = 1;</code>
       */
      KANA(1),
      ;

      /**
       * <code>ROMAN = 0;</code>
       */
      public static final int ROMAN_VALUE = 0;
      /**
       * <code>KANA = 1;</code>
       */
      public static final int KANA_VALUE = 1;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static PreeditMethod valueOf(int value) {
        return forNumber(value);
      }

      public static PreeditMethod forNumber(int value) {
        switch (value) {
          case 0: return ROMAN;
          case 1: return KANA;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<PreeditMethod>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          PreeditMethod> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<PreeditMethod>() {
              @java.lang.Override
              public PreeditMethod findValueByNumber(int number) {
                return PreeditMethod.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return PreeditMethodVerifier.INSTANCE;
      }

      private static final class PreeditMethodVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new PreeditMethodVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return PreeditMethod.forNumber(number) != null;
              }
            };

      private final int value;

      private PreeditMethod(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.PreeditMethod)
    }

    /**
     * Protobuf enum {@code mozc.config.Config.SessionKeymap}
     */
    public enum SessionKeymap
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <pre>
       * If NONE is selected, it will be replaced with MSIME or KOTOERI.
       * NONE is used only for a placeholder, so a configuration program
       * should not show NONE as one of selections.  NONE should be the
       * last of the items due to the limitation of the Qt GUI's
       * implementation. Note that keymap number should be correspoinding
       * to the index of QComboBox in config dialog. Since NONE is not
       * used, we set -1 here.
       * </pre>
       *
       * <code>NONE = -1;</code>
       */
      NONE(-1),
      /**
       * <code>CUSTOM = 0;</code>
       */
      CUSTOM(0),
      /**
       * <code>ATOK = 1;</code>
       */
      ATOK(1),
      /**
       * <code>MSIME = 2;</code>
       */
      MSIME(2),
      /**
       * <code>KOTOERI = 3;</code>
       */
      KOTOERI(3),
      /**
       * <code>MOBILE = 4;</code>
       */
      MOBILE(4),
      /**
       * <code>CHROMEOS = 5;</code>
       */
      CHROMEOS(5),
      /**
       * <code>OVERLAY_HENKAN_MUHENKAN_TO_IME_ON_OFF = 100;</code>
       */
      OVERLAY_HENKAN_MUHENKAN_TO_IME_ON_OFF(100),
      /**
       * <code>OVERLAY_FOR_TEST = 10000;</code>
       */
      OVERLAY_FOR_TEST(10000),
      ;

      /**
       * <pre>
       * If NONE is selected, it will be replaced with MSIME or KOTOERI.
       * NONE is used only for a placeholder, so a configuration program
       * should not show NONE as one of selections.  NONE should be the
       * last of the items due to the limitation of the Qt GUI's
       * implementation. Note that keymap number should be correspoinding
       * to the index of QComboBox in config dialog. Since NONE is not
       * used, we set -1 here.
       * </pre>
       *
       * <code>NONE = -1;</code>
       */
      public static final int NONE_VALUE = -1;
      /**
       * <code>CUSTOM = 0;</code>
       */
      public static final int CUSTOM_VALUE = 0;
      /**
       * <code>ATOK = 1;</code>
       */
      public static final int ATOK_VALUE = 1;
      /**
       * <code>MSIME = 2;</code>
       */
      public static final int MSIME_VALUE = 2;
      /**
       * <code>KOTOERI = 3;</code>
       */
      public static final int KOTOERI_VALUE = 3;
      /**
       * <code>MOBILE = 4;</code>
       */
      public static final int MOBILE_VALUE = 4;
      /**
       * <code>CHROMEOS = 5;</code>
       */
      public static final int CHROMEOS_VALUE = 5;
      /**
       * <code>OVERLAY_HENKAN_MUHENKAN_TO_IME_ON_OFF = 100;</code>
       */
      public static final int OVERLAY_HENKAN_MUHENKAN_TO_IME_ON_OFF_VALUE = 100;
      /**
       * <code>OVERLAY_FOR_TEST = 10000;</code>
       */
      public static final int OVERLAY_FOR_TEST_VALUE = 10000;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static SessionKeymap valueOf(int value) {
        return forNumber(value);
      }

      public static SessionKeymap forNumber(int value) {
        switch (value) {
          case -1: return NONE;
          case 0: return CUSTOM;
          case 1: return ATOK;
          case 2: return MSIME;
          case 3: return KOTOERI;
          case 4: return MOBILE;
          case 5: return CHROMEOS;
          case 100: return OVERLAY_HENKAN_MUHENKAN_TO_IME_ON_OFF;
          case 10000: return OVERLAY_FOR_TEST;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<SessionKeymap>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          SessionKeymap> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<SessionKeymap>() {
              @java.lang.Override
              public SessionKeymap findValueByNumber(int number) {
                return SessionKeymap.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return SessionKeymapVerifier.INSTANCE;
      }

      private static final class SessionKeymapVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new SessionKeymapVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return SessionKeymap.forNumber(number) != null;
              }
            };

      private final int value;

      private SessionKeymap(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.SessionKeymap)
    }

    /**
     * Protobuf enum {@code mozc.config.Config.PunctuationMethod}
     */
    public enum PunctuationMethod
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>TOUTEN_KUTEN = 0;</code>
       */
      TOUTEN_KUTEN(0),
      /**
       * <code>COMMA_PERIOD = 1;</code>
       */
      COMMA_PERIOD(1),
      /**
       * <code>TOUTEN_PERIOD = 2;</code>
       */
      TOUTEN_PERIOD(2),
      /**
       * <code>COMMA_KUTEN = 3;</code>
       */
      COMMA_KUTEN(3),
      ;

      /**
       * <code>TOUTEN_KUTEN = 0;</code>
       */
      public static final int TOUTEN_KUTEN_VALUE = 0;
      /**
       * <code>COMMA_PERIOD = 1;</code>
       */
      public static final int COMMA_PERIOD_VALUE = 1;
      /**
       * <code>TOUTEN_PERIOD = 2;</code>
       */
      public static final int TOUTEN_PERIOD_VALUE = 2;
      /**
       * <code>COMMA_KUTEN = 3;</code>
       */
      public static final int COMMA_KUTEN_VALUE = 3;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static PunctuationMethod valueOf(int value) {
        return forNumber(value);
      }

      public static PunctuationMethod forNumber(int value) {
        switch (value) {
          case 0: return TOUTEN_KUTEN;
          case 1: return COMMA_PERIOD;
          case 2: return TOUTEN_PERIOD;
          case 3: return COMMA_KUTEN;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<PunctuationMethod>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          PunctuationMethod> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<PunctuationMethod>() {
              @java.lang.Override
              public PunctuationMethod findValueByNumber(int number) {
                return PunctuationMethod.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return PunctuationMethodVerifier.INSTANCE;
      }

      private static final class PunctuationMethodVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new PunctuationMethodVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return PunctuationMethod.forNumber(number) != null;
              }
            };

      private final int value;

      private PunctuationMethod(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.PunctuationMethod)
    }

    /**
     * Protobuf enum {@code mozc.config.Config.SymbolMethod}
     */
    public enum SymbolMethod
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>CORNER_BRACKET_MIDDLE_DOT = 0;</code>
       */
      CORNER_BRACKET_MIDDLE_DOT(0),
      /**
       * <code>SQUARE_BRACKET_SLASH = 1;</code>
       */
      SQUARE_BRACKET_SLASH(1),
      /**
       * <code>CORNER_BRACKET_SLASH = 2;</code>
       */
      CORNER_BRACKET_SLASH(2),
      /**
       * <code>SQUARE_BRACKET_MIDDLE_DOT = 3;</code>
       */
      SQUARE_BRACKET_MIDDLE_DOT(3),
      ;

      /**
       * <code>CORNER_BRACKET_MIDDLE_DOT = 0;</code>
       */
      public static final int CORNER_BRACKET_MIDDLE_DOT_VALUE = 0;
      /**
       * <code>SQUARE_BRACKET_SLASH = 1;</code>
       */
      public static final int SQUARE_BRACKET_SLASH_VALUE = 1;
      /**
       * <code>CORNER_BRACKET_SLASH = 2;</code>
       */
      public static final int CORNER_BRACKET_SLASH_VALUE = 2;
      /**
       * <code>SQUARE_BRACKET_MIDDLE_DOT = 3;</code>
       */
      public static final int SQUARE_BRACKET_MIDDLE_DOT_VALUE = 3;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static SymbolMethod valueOf(int value) {
        return forNumber(value);
      }

      public static SymbolMethod forNumber(int value) {
        switch (value) {
          case 0: return CORNER_BRACKET_MIDDLE_DOT;
          case 1: return SQUARE_BRACKET_SLASH;
          case 2: return CORNER_BRACKET_SLASH;
          case 3: return SQUARE_BRACKET_MIDDLE_DOT;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<SymbolMethod>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          SymbolMethod> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<SymbolMethod>() {
              @java.lang.Override
              public SymbolMethod findValueByNumber(int number) {
                return SymbolMethod.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return SymbolMethodVerifier.INSTANCE;
      }

      private static final class SymbolMethodVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new SymbolMethodVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return SymbolMethod.forNumber(number) != null;
              }
            };

      private final int value;

      private SymbolMethod(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.SymbolMethod)
    }

    /**
     * Protobuf enum {@code mozc.config.Config.FundamentalCharacterForm}
     */
    public enum FundamentalCharacterForm
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <pre>
       * follow the input mode
       * </pre>
       *
       * <code>FUNDAMENTAL_INPUT_MODE = 0;</code>
       */
      FUNDAMENTAL_INPUT_MODE(0),
      /**
       * <pre>
       * always FullWidth
       * </pre>
       *
       * <code>FUNDAMENTAL_FULL_WIDTH = 1;</code>
       */
      FUNDAMENTAL_FULL_WIDTH(1),
      /**
       * <pre>
       * always HalfWidth
       * </pre>
       *
       * <code>FUNDAMENTAL_HALF_WIDTH = 2;</code>
       */
      FUNDAMENTAL_HALF_WIDTH(2),
      ;

      /**
       * <pre>
       * follow the input mode
       * </pre>
       *
       * <code>FUNDAMENTAL_INPUT_MODE = 0;</code>
       */
      public static final int FUNDAMENTAL_INPUT_MODE_VALUE = 0;
      /**
       * <pre>
       * always FullWidth
       * </pre>
       *
       * <code>FUNDAMENTAL_FULL_WIDTH = 1;</code>
       */
      public static final int FUNDAMENTAL_FULL_WIDTH_VALUE = 1;
      /**
       * <pre>
       * always HalfWidth
       * </pre>
       *
       * <code>FUNDAMENTAL_HALF_WIDTH = 2;</code>
       */
      public static final int FUNDAMENTAL_HALF_WIDTH_VALUE = 2;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static FundamentalCharacterForm valueOf(int value) {
        return forNumber(value);
      }

      public static FundamentalCharacterForm forNumber(int value) {
        switch (value) {
          case 0: return FUNDAMENTAL_INPUT_MODE;
          case 1: return FUNDAMENTAL_FULL_WIDTH;
          case 2: return FUNDAMENTAL_HALF_WIDTH;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<FundamentalCharacterForm>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          FundamentalCharacterForm> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<FundamentalCharacterForm>() {
              @java.lang.Override
              public FundamentalCharacterForm findValueByNumber(int number) {
                return FundamentalCharacterForm.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return FundamentalCharacterFormVerifier.INSTANCE;
      }

      private static final class FundamentalCharacterFormVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new FundamentalCharacterFormVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return FundamentalCharacterForm.forNumber(number) != null;
              }
            };

      private final int value;

      private FundamentalCharacterForm(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.FundamentalCharacterForm)
    }

    /**
     * <pre>
     * User history learning
     * </pre>
     *
     * Protobuf enum {@code mozc.config.Config.HistoryLearningLevel}
     */
    public enum HistoryLearningLevel
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>DEFAULT_HISTORY = 0;</code>
       */
      DEFAULT_HISTORY(0),
      /**
       * <code>READ_ONLY = 1;</code>
       */
      READ_ONLY(1),
      /**
       * <code>NO_HISTORY = 2;</code>
       */
      NO_HISTORY(2),
      ;

      /**
       * <code>DEFAULT_HISTORY = 0;</code>
       */
      public static final int DEFAULT_HISTORY_VALUE = 0;
      /**
       * <code>READ_ONLY = 1;</code>
       */
      public static final int READ_ONLY_VALUE = 1;
      /**
       * <code>NO_HISTORY = 2;</code>
       */
      public static final int NO_HISTORY_VALUE = 2;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static HistoryLearningLevel valueOf(int value) {
        return forNumber(value);
      }

      public static HistoryLearningLevel forNumber(int value) {
        switch (value) {
          case 0: return DEFAULT_HISTORY;
          case 1: return READ_ONLY;
          case 2: return NO_HISTORY;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<HistoryLearningLevel>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          HistoryLearningLevel> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<HistoryLearningLevel>() {
              @java.lang.Override
              public HistoryLearningLevel findValueByNumber(int number) {
                return HistoryLearningLevel.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return HistoryLearningLevelVerifier.INSTANCE;
      }

      private static final class HistoryLearningLevelVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new HistoryLearningLevelVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return HistoryLearningLevel.forNumber(number) != null;
              }
            };

      private final int value;

      private HistoryLearningLevel(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.HistoryLearningLevel)
    }

    /**
     * <pre>
     * The style of candidate selection shortcut.
     * Note that if the current Request has SpecialRomajiTable (== the keyevent
     * is from a virtual keyboard), shortcut is no-op.
     * </pre>
     *
     * Protobuf enum {@code mozc.config.Config.SelectionShortcut}
     */
    public enum SelectionShortcut
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>NO_SHORTCUT = 0;</code>
       */
      NO_SHORTCUT(0),
      /**
       * <code>SHORTCUT_123456789 = 1;</code>
       */
      SHORTCUT_123456789(1),
      /**
       * <code>SHORTCUT_ASDFGHJKL = 2;</code>
       */
      SHORTCUT_ASDFGHJKL(2),
      ;

      /**
       * <code>NO_SHORTCUT = 0;</code>
       */
      public static final int NO_SHORTCUT_VALUE = 0;
      /**
       * <code>SHORTCUT_123456789 = 1;</code>
       */
      public static final int SHORTCUT_123456789_VALUE = 1;
      /**
       * <code>SHORTCUT_ASDFGHJKL = 2;</code>
       */
      public static final int SHORTCUT_ASDFGHJKL_VALUE = 2;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static SelectionShortcut valueOf(int value) {
        return forNumber(value);
      }

      public static SelectionShortcut forNumber(int value) {
        switch (value) {
          case 0: return NO_SHORTCUT;
          case 1: return SHORTCUT_123456789;
          case 2: return SHORTCUT_ASDFGHJKL;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<SelectionShortcut>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          SelectionShortcut> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<SelectionShortcut>() {
              @java.lang.Override
              public SelectionShortcut findValueByNumber(int number) {
                return SelectionShortcut.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return SelectionShortcutVerifier.INSTANCE;
      }

      private static final class SelectionShortcutVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new SelectionShortcutVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return SelectionShortcut.forNumber(number) != null;
              }
            };

      private final int value;

      private SelectionShortcut(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.SelectionShortcut)
    }

    /**
     * <pre>
     * character form (Halfwidth/Fullwidth
     * </pre>
     *
     * Protobuf enum {@code mozc.config.Config.CharacterForm}
     */
    public enum CharacterForm
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>HALF_WIDTH = 0;</code>
       */
      HALF_WIDTH(0),
      /**
       * <code>FULL_WIDTH = 1;</code>
       */
      FULL_WIDTH(1),
      /**
       * <code>LAST_FORM = 2;</code>
       */
      LAST_FORM(2),
      /**
       * <code>NO_CONVERSION = 3;</code>
       */
      NO_CONVERSION(3),
      ;

      /**
       * <code>HALF_WIDTH = 0;</code>
       */
      public static final int HALF_WIDTH_VALUE = 0;
      /**
       * <code>FULL_WIDTH = 1;</code>
       */
      public static final int FULL_WIDTH_VALUE = 1;
      /**
       * <code>LAST_FORM = 2;</code>
       */
      public static final int LAST_FORM_VALUE = 2;
      /**
       * <code>NO_CONVERSION = 3;</code>
       */
      public static final int NO_CONVERSION_VALUE = 3;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static CharacterForm valueOf(int value) {
        return forNumber(value);
      }

      public static CharacterForm forNumber(int value) {
        switch (value) {
          case 0: return HALF_WIDTH;
          case 1: return FULL_WIDTH;
          case 2: return LAST_FORM;
          case 3: return NO_CONVERSION;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<CharacterForm>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          CharacterForm> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<CharacterForm>() {
              @java.lang.Override
              public CharacterForm findValueByNumber(int number) {
                return CharacterForm.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return CharacterFormVerifier.INSTANCE;
      }

      private static final class CharacterFormVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new CharacterFormVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return CharacterForm.forNumber(number) != null;
              }
            };

      private final int value;

      private CharacterForm(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.CharacterForm)
    }

    /**
     * <pre>
     * Shift key mode switch
     * </pre>
     *
     * Protobuf enum {@code mozc.config.Config.ShiftKeyModeSwitch}
     */
    public enum ShiftKeyModeSwitch
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <pre>
       * Case insensitive
       * </pre>
       *
       * <code>OFF = 0;</code>
       */
      OFF(0),
      /**
       * <pre>
       * MSIME, ATOK behavior
       * </pre>
       *
       * <code>ASCII_INPUT_MODE = 1;</code>
       */
      ASCII_INPUT_MODE(1),
      /**
       * <pre>
       * Kotoeri behavior
       * </pre>
       *
       * <code>KATAKANA_INPUT_MODE = 2;</code>
       */
      KATAKANA_INPUT_MODE(2),
      ;

      /**
       * <pre>
       * Case insensitive
       * </pre>
       *
       * <code>OFF = 0;</code>
       */
      public static final int OFF_VALUE = 0;
      /**
       * <pre>
       * MSIME, ATOK behavior
       * </pre>
       *
       * <code>ASCII_INPUT_MODE = 1;</code>
       */
      public static final int ASCII_INPUT_MODE_VALUE = 1;
      /**
       * <pre>
       * Kotoeri behavior
       * </pre>
       *
       * <code>KATAKANA_INPUT_MODE = 2;</code>
       */
      public static final int KATAKANA_INPUT_MODE_VALUE = 2;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static ShiftKeyModeSwitch valueOf(int value) {
        return forNumber(value);
      }

      public static ShiftKeyModeSwitch forNumber(int value) {
        switch (value) {
          case 0: return OFF;
          case 1: return ASCII_INPUT_MODE;
          case 2: return KATAKANA_INPUT_MODE;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<ShiftKeyModeSwitch>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          ShiftKeyModeSwitch> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<ShiftKeyModeSwitch>() {
              @java.lang.Override
              public ShiftKeyModeSwitch findValueByNumber(int number) {
                return ShiftKeyModeSwitch.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return ShiftKeyModeSwitchVerifier.INSTANCE;
      }

      private static final class ShiftKeyModeSwitchVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new ShiftKeyModeSwitchVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return ShiftKeyModeSwitch.forNumber(number) != null;
              }
            };

      private final int value;

      private ShiftKeyModeSwitch(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.ShiftKeyModeSwitch)
    }

    /**
     * Protobuf enum {@code mozc.config.Config.NumpadCharacterForm}
     */
    public enum NumpadCharacterForm
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>NUMPAD_INPUT_MODE = 0;</code>
       */
      NUMPAD_INPUT_MODE(0),
      /**
       * <code>NUMPAD_FULL_WIDTH = 1;</code>
       */
      NUMPAD_FULL_WIDTH(1),
      /**
       * <code>NUMPAD_HALF_WIDTH = 2;</code>
       */
      NUMPAD_HALF_WIDTH(2),
      /**
       * <code>NUMPAD_DIRECT_INPUT = 3;</code>
       */
      NUMPAD_DIRECT_INPUT(3),
      ;

      /**
       * <code>NUMPAD_INPUT_MODE = 0;</code>
       */
      public static final int NUMPAD_INPUT_MODE_VALUE = 0;
      /**
       * <code>NUMPAD_FULL_WIDTH = 1;</code>
       */
      public static final int NUMPAD_FULL_WIDTH_VALUE = 1;
      /**
       * <code>NUMPAD_HALF_WIDTH = 2;</code>
       */
      public static final int NUMPAD_HALF_WIDTH_VALUE = 2;
      /**
       * <code>NUMPAD_DIRECT_INPUT = 3;</code>
       */
      public static final int NUMPAD_DIRECT_INPUT_VALUE = 3;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static NumpadCharacterForm valueOf(int value) {
        return forNumber(value);
      }

      public static NumpadCharacterForm forNumber(int value) {
        switch (value) {
          case 0: return NUMPAD_INPUT_MODE;
          case 1: return NUMPAD_FULL_WIDTH;
          case 2: return NUMPAD_HALF_WIDTH;
          case 3: return NUMPAD_DIRECT_INPUT;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<NumpadCharacterForm>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          NumpadCharacterForm> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<NumpadCharacterForm>() {
              @java.lang.Override
              public NumpadCharacterForm findValueByNumber(int number) {
                return NumpadCharacterForm.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return NumpadCharacterFormVerifier.INSTANCE;
      }

      private static final class NumpadCharacterFormVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new NumpadCharacterFormVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return NumpadCharacterForm.forNumber(number) != null;
              }
            };

      private final int value;

      private NumpadCharacterForm(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.NumpadCharacterForm)
    }

    /**
     * Protobuf enum {@code mozc.config.Config.AutoConversionKey}
     */
    public enum AutoConversionKey
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>AUTO_CONVERSION_OFF = 0;</code>
       */
      AUTO_CONVERSION_OFF(0),
      /**
       * <code>AUTO_CONVERSION_KUTEN = 1;</code>
       */
      AUTO_CONVERSION_KUTEN(1),
      /**
       * <code>AUTO_CONVERSION_TOUTEN = 2;</code>
       */
      AUTO_CONVERSION_TOUTEN(2),
      /**
       * <code>AUTO_CONVERSION_QUESTION_MARK = 4;</code>
       */
      AUTO_CONVERSION_QUESTION_MARK(4),
      /**
       * <code>AUTO_CONVERSION_EXCLAMATION_MARK = 8;</code>
       */
      AUTO_CONVERSION_EXCLAMATION_MARK(8),
      ;

      /**
       * <code>AUTO_CONVERSION_OFF = 0;</code>
       */
      public static final int AUTO_CONVERSION_OFF_VALUE = 0;
      /**
       * <code>AUTO_CONVERSION_KUTEN = 1;</code>
       */
      public static final int AUTO_CONVERSION_KUTEN_VALUE = 1;
      /**
       * <code>AUTO_CONVERSION_TOUTEN = 2;</code>
       */
      public static final int AUTO_CONVERSION_TOUTEN_VALUE = 2;
      /**
       * <code>AUTO_CONVERSION_QUESTION_MARK = 4;</code>
       */
      public static final int AUTO_CONVERSION_QUESTION_MARK_VALUE = 4;
      /**
       * <code>AUTO_CONVERSION_EXCLAMATION_MARK = 8;</code>
       */
      public static final int AUTO_CONVERSION_EXCLAMATION_MARK_VALUE = 8;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static AutoConversionKey valueOf(int value) {
        return forNumber(value);
      }

      public static AutoConversionKey forNumber(int value) {
        switch (value) {
          case 0: return AUTO_CONVERSION_OFF;
          case 1: return AUTO_CONVERSION_KUTEN;
          case 2: return AUTO_CONVERSION_TOUTEN;
          case 4: return AUTO_CONVERSION_QUESTION_MARK;
          case 8: return AUTO_CONVERSION_EXCLAMATION_MARK;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<AutoConversionKey>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          AutoConversionKey> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AutoConversionKey>() {
              @java.lang.Override
              public AutoConversionKey findValueByNumber(int number) {
                return AutoConversionKey.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return AutoConversionKeyVerifier.INSTANCE;
      }

      private static final class AutoConversionKeyVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new AutoConversionKeyVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return AutoConversionKey.forNumber(number) != null;
              }
            };

      private final int value;

      private AutoConversionKey(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.AutoConversionKey)
    }

    /**
     * <pre>
     * Mac only config items: yen_sign_character and use_japanese_layout.
     * </pre>
     *
     * Protobuf enum {@code mozc.config.Config.YenSignCharacter}
     */
    public enum YenSignCharacter
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>YEN_SIGN = 0;</code>
       */
      YEN_SIGN(0),
      /**
       * <code>BACKSLASH = 1;</code>
       */
      BACKSLASH(1),
      ;

      /**
       * <code>YEN_SIGN = 0;</code>
       */
      public static final int YEN_SIGN_VALUE = 0;
      /**
       * <code>BACKSLASH = 1;</code>
       */
      public static final int BACKSLASH_VALUE = 1;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static YenSignCharacter valueOf(int value) {
        return forNumber(value);
      }

      public static YenSignCharacter forNumber(int value) {
        switch (value) {
          case 0: return YEN_SIGN;
          case 1: return BACKSLASH;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<YenSignCharacter>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          YenSignCharacter> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<YenSignCharacter>() {
              @java.lang.Override
              public YenSignCharacter findValueByNumber(int number) {
                return YenSignCharacter.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return YenSignCharacterVerifier.INSTANCE;
      }

      private static final class YenSignCharacterVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new YenSignCharacterVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return YenSignCharacter.forNumber(number) != null;
              }
            };

      private final int value;

      private YenSignCharacter(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.YenSignCharacter)
    }

    public interface CharacterFormRuleOrBuilder extends
        // @@protoc_insertion_point(interface_extends:mozc.config.Config.CharacterFormRule)
        com.google.protobuf.MessageLiteOrBuilder {

      /**
       * <code>optional string group = 1;</code>
       * @return Whether the group field is set.
       */
      boolean hasGroup();
      /**
       * <code>optional string group = 1;</code>
       * @return The group.
       */
      java.lang.String getGroup();
      /**
       * <code>optional string group = 1;</code>
       * @return The bytes for group.
       */
      com.google.protobuf.ByteString
          getGroupBytes();

      /**
       * <code>optional .mozc.config.Config.CharacterForm preedit_character_form = 2 [default = FULL_WIDTH];</code>
       * @return Whether the preeditCharacterForm field is set.
       */
      boolean hasPreeditCharacterForm();
      /**
       * <code>optional .mozc.config.Config.CharacterForm preedit_character_form = 2 [default = FULL_WIDTH];</code>
       * @return The preeditCharacterForm.
       */
      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm getPreeditCharacterForm();

      /**
       * <code>optional .mozc.config.Config.CharacterForm conversion_character_form = 3 [default = FULL_WIDTH];</code>
       * @return Whether the conversionCharacterForm field is set.
       */
      boolean hasConversionCharacterForm();
      /**
       * <code>optional .mozc.config.Config.CharacterForm conversion_character_form = 3 [default = FULL_WIDTH];</code>
       * @return The conversionCharacterForm.
       */
      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm getConversionCharacterForm();
    }
    /**
     * Protobuf type {@code mozc.config.Config.CharacterFormRule}
     */
    public  static final class CharacterFormRule extends
        com.google.protobuf.GeneratedMessageLite<
            CharacterFormRule, CharacterFormRule.Builder> implements
        // @@protoc_insertion_point(message_implements:mozc.config.Config.CharacterFormRule)
        CharacterFormRuleOrBuilder {
      private CharacterFormRule() {
        group_ = "";
        preeditCharacterForm_ = 1;
        conversionCharacterForm_ = 1;
      }
      private int bitField0_;
      public static final int GROUP_FIELD_NUMBER = 1;
      private java.lang.String group_;
      /**
       * <code>optional string group = 1;</code>
       * @return Whether the group field is set.
       */
      @java.lang.Override
      public boolean hasGroup() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional string group = 1;</code>
       * @return The group.
       */
      @java.lang.Override
      public java.lang.String getGroup() {
        return group_;
      }
      /**
       * <code>optional string group = 1;</code>
       * @return The bytes for group.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getGroupBytes() {
        return com.google.protobuf.ByteString.copyFromUtf8(group_);
      }
      /**
       * <code>optional string group = 1;</code>
       * @param value The group to set.
       */
      private void setGroup(
          java.lang.String value) {
        java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000001;
        group_ = value;
      }
      /**
       * <code>optional string group = 1;</code>
       */
      private void clearGroup() {
        bitField0_ = (bitField0_ & ~0x00000001);
        group_ = getDefaultInstance().getGroup();
      }
      /**
       * <code>optional string group = 1;</code>
       * @param value The bytes for group to set.
       */
      private void setGroupBytes(
          com.google.protobuf.ByteString value) {
        group_ = value.toStringUtf8();
        bitField0_ |= 0x00000001;
      }

      public static final int PREEDIT_CHARACTER_FORM_FIELD_NUMBER = 2;
      private int preeditCharacterForm_;
      /**
       * <code>optional .mozc.config.Config.CharacterForm preedit_character_form = 2 [default = FULL_WIDTH];</code>
       * @return Whether the preeditCharacterForm field is set.
       */
      @java.lang.Override
      public boolean hasPreeditCharacterForm() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional .mozc.config.Config.CharacterForm preedit_character_form = 2 [default = FULL_WIDTH];</code>
       * @return The preeditCharacterForm.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm getPreeditCharacterForm() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm.forNumber(preeditCharacterForm_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm.FULL_WIDTH : result;
      }
      /**
       * <code>optional .mozc.config.Config.CharacterForm preedit_character_form = 2 [default = FULL_WIDTH];</code>
       * @param value The preeditCharacterForm to set.
       */
      private void setPreeditCharacterForm(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm value) {
        preeditCharacterForm_ = value.getNumber();
        bitField0_ |= 0x00000002;
      }
      /**
       * <code>optional .mozc.config.Config.CharacterForm preedit_character_form = 2 [default = FULL_WIDTH];</code>
       */
      private void clearPreeditCharacterForm() {
        bitField0_ = (bitField0_ & ~0x00000002);
        preeditCharacterForm_ = 1;
      }

      public static final int CONVERSION_CHARACTER_FORM_FIELD_NUMBER = 3;
      private int conversionCharacterForm_;
      /**
       * <code>optional .mozc.config.Config.CharacterForm conversion_character_form = 3 [default = FULL_WIDTH];</code>
       * @return Whether the conversionCharacterForm field is set.
       */
      @java.lang.Override
      public boolean hasConversionCharacterForm() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <code>optional .mozc.config.Config.CharacterForm conversion_character_form = 3 [default = FULL_WIDTH];</code>
       * @return The conversionCharacterForm.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm getConversionCharacterForm() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm.forNumber(conversionCharacterForm_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm.FULL_WIDTH : result;
      }
      /**
       * <code>optional .mozc.config.Config.CharacterForm conversion_character_form = 3 [default = FULL_WIDTH];</code>
       * @param value The conversionCharacterForm to set.
       */
      private void setConversionCharacterForm(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm value) {
        conversionCharacterForm_ = value.getNumber();
        bitField0_ |= 0x00000004;
      }
      /**
       * <code>optional .mozc.config.Config.CharacterForm conversion_character_form = 3 [default = FULL_WIDTH];</code>
       */
      private void clearConversionCharacterForm() {
        bitField0_ = (bitField0_ & ~0x00000004);
        conversionCharacterForm_ = 1;
      }

      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }

      public static Builder newBuilder() {
        return (Builder) DEFAULT_INSTANCE.createBuilder();
      }
      public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule prototype) {
        return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
      }

      /**
       * Protobuf type {@code mozc.config.Config.CharacterFormRule}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageLite.Builder<
            org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule, Builder> implements
          // @@protoc_insertion_point(builder_implements:mozc.config.Config.CharacterFormRule)
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRuleOrBuilder {
        // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.newBuilder()
        private Builder() {
          super(DEFAULT_INSTANCE);
        }


        /**
         * <code>optional string group = 1;</code>
         * @return Whether the group field is set.
         */
        @java.lang.Override
        public boolean hasGroup() {
          return instance.hasGroup();
        }
        /**
         * <code>optional string group = 1;</code>
         * @return The group.
         */
        @java.lang.Override
        public java.lang.String getGroup() {
          return instance.getGroup();
        }
        /**
         * <code>optional string group = 1;</code>
         * @return The bytes for group.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
            getGroupBytes() {
          return instance.getGroupBytes();
        }
        /**
         * <code>optional string group = 1;</code>
         * @param value The group to set.
         * @return This builder for chaining.
         */
        public Builder setGroup(
            java.lang.String value) {
          copyOnWrite();
          instance.setGroup(value);
          return this;
        }
        /**
         * <code>optional string group = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearGroup() {
          copyOnWrite();
          instance.clearGroup();
          return this;
        }
        /**
         * <code>optional string group = 1;</code>
         * @param value The bytes for group to set.
         * @return This builder for chaining.
         */
        public Builder setGroupBytes(
            com.google.protobuf.ByteString value) {
          copyOnWrite();
          instance.setGroupBytes(value);
          return this;
        }

        /**
         * <code>optional .mozc.config.Config.CharacterForm preedit_character_form = 2 [default = FULL_WIDTH];</code>
         * @return Whether the preeditCharacterForm field is set.
         */
        @java.lang.Override
        public boolean hasPreeditCharacterForm() {
          return instance.hasPreeditCharacterForm();
        }
        /**
         * <code>optional .mozc.config.Config.CharacterForm preedit_character_form = 2 [default = FULL_WIDTH];</code>
         * @return The preeditCharacterForm.
         */
        @java.lang.Override
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm getPreeditCharacterForm() {
          return instance.getPreeditCharacterForm();
        }
        /**
         * <code>optional .mozc.config.Config.CharacterForm preedit_character_form = 2 [default = FULL_WIDTH];</code>
         * @param value The enum numeric value on the wire for preeditCharacterForm to set.
         * @return This builder for chaining.
         */
        public Builder setPreeditCharacterForm(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm value) {
          copyOnWrite();
          instance.setPreeditCharacterForm(value);
          return this;
        }
        /**
         * <code>optional .mozc.config.Config.CharacterForm preedit_character_form = 2 [default = FULL_WIDTH];</code>
         * @return This builder for chaining.
         */
        public Builder clearPreeditCharacterForm() {
          copyOnWrite();
          instance.clearPreeditCharacterForm();
          return this;
        }

        /**
         * <code>optional .mozc.config.Config.CharacterForm conversion_character_form = 3 [default = FULL_WIDTH];</code>
         * @return Whether the conversionCharacterForm field is set.
         */
        @java.lang.Override
        public boolean hasConversionCharacterForm() {
          return instance.hasConversionCharacterForm();
        }
        /**
         * <code>optional .mozc.config.Config.CharacterForm conversion_character_form = 3 [default = FULL_WIDTH];</code>
         * @return The conversionCharacterForm.
         */
        @java.lang.Override
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm getConversionCharacterForm() {
          return instance.getConversionCharacterForm();
        }
        /**
         * <code>optional .mozc.config.Config.CharacterForm conversion_character_form = 3 [default = FULL_WIDTH];</code>
         * @param value The enum numeric value on the wire for conversionCharacterForm to set.
         * @return This builder for chaining.
         */
        public Builder setConversionCharacterForm(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm value) {
          copyOnWrite();
          instance.setConversionCharacterForm(value);
          return this;
        }
        /**
         * <code>optional .mozc.config.Config.CharacterForm conversion_character_form = 3 [default = FULL_WIDTH];</code>
         * @return This builder for chaining.
         */
        public Builder clearConversionCharacterForm() {
          copyOnWrite();
          instance.clearConversionCharacterForm();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:mozc.config.Config.CharacterFormRule)
      }
      @java.lang.Override
      @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
      protected final java.lang.Object dynamicMethod(
          com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
          java.lang.Object arg0, java.lang.Object arg1) {
        switch (method) {
          case NEW_MUTABLE_INSTANCE: {
            return new org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule();
          }
          case NEW_BUILDER: {
            return new Builder();
          }
          case BUILD_MESSAGE_INFO: {
              java.lang.Object[] objects = new java.lang.Object[] {
                "bitField0_",
                "group_",
                "preeditCharacterForm_",
                org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm.internalGetVerifier(),
                "conversionCharacterForm_",
                org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm.internalGetVerifier(),
              };
              java.lang.String info =
                  "\u0001\u0003\u0000\u0001\u0001\u0003\u0003\u0000\u0000\u0000\u0001\u1008\u0000\u0002" +
                  "\u100c\u0001\u0003\u100c\u0002";
              return newMessageInfo(DEFAULT_INSTANCE, info, objects);
          }
          // fall through
          case GET_DEFAULT_INSTANCE: {
            return DEFAULT_INSTANCE;
          }
          case GET_PARSER: {
            com.google.protobuf.Parser<org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule> parser = PARSER;
            if (parser == null) {
              synchronized (org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.class) {
                parser = PARSER;
                if (parser == null) {
                  parser =
                      new DefaultInstanceBasedParser<org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule>(
                          DEFAULT_INSTANCE);
                  PARSER = parser;
                }
              }
            }
            return parser;
        }
        case GET_MEMOIZED_IS_INITIALIZED: {
          return (byte) 1;
        }
        case SET_MEMOIZED_IS_INITIALIZED: {
          return null;
        }
        }
        throw new UnsupportedOperationException();
      }


      // @@protoc_insertion_point(class_scope:mozc.config.Config.CharacterFormRule)
      private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule DEFAULT_INSTANCE;
      static {
        CharacterFormRule defaultInstance = new CharacterFormRule();
        // New instances are implicitly immutable so no need to make
        // immutable.
        DEFAULT_INSTANCE = defaultInstance;
        com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
          CharacterFormRule.class, defaultInstance);
      }

      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static volatile com.google.protobuf.Parser<CharacterFormRule> PARSER;

      public static com.google.protobuf.Parser<CharacterFormRule> parser() {
        return DEFAULT_INSTANCE.getParserForType();
      }
    }

    public interface InformationListConfigOrBuilder extends
        // @@protoc_insertion_point(interface_extends:mozc.config.Config.InformationListConfig)
        com.google.protobuf.MessageLiteOrBuilder {

      /**
       * <code>optional bool use_local_usage_dictionary = 1 [default = true];</code>
       * @return Whether the useLocalUsageDictionary field is set.
       */
      boolean hasUseLocalUsageDictionary();
      /**
       * <code>optional bool use_local_usage_dictionary = 1 [default = true];</code>
       * @return The useLocalUsageDictionary.
       */
      boolean getUseLocalUsageDictionary();
    }
    /**
     * Protobuf type {@code mozc.config.Config.InformationListConfig}
     */
    public  static final class InformationListConfig extends
        com.google.protobuf.GeneratedMessageLite<
            InformationListConfig, InformationListConfig.Builder> implements
        // @@protoc_insertion_point(message_implements:mozc.config.Config.InformationListConfig)
        InformationListConfigOrBuilder {
      private InformationListConfig() {
        useLocalUsageDictionary_ = true;
      }
      private int bitField0_;
      public static final int USE_LOCAL_USAGE_DICTIONARY_FIELD_NUMBER = 1;
      private boolean useLocalUsageDictionary_;
      /**
       * <code>optional bool use_local_usage_dictionary = 1 [default = true];</code>
       * @return Whether the useLocalUsageDictionary field is set.
       */
      @java.lang.Override
      public boolean hasUseLocalUsageDictionary() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional bool use_local_usage_dictionary = 1 [default = true];</code>
       * @return The useLocalUsageDictionary.
       */
      @java.lang.Override
      public boolean getUseLocalUsageDictionary() {
        return useLocalUsageDictionary_;
      }
      /**
       * <code>optional bool use_local_usage_dictionary = 1 [default = true];</code>
       * @param value The useLocalUsageDictionary to set.
       */
      private void setUseLocalUsageDictionary(boolean value) {
        bitField0_ |= 0x00000001;
        useLocalUsageDictionary_ = value;
      }
      /**
       * <code>optional bool use_local_usage_dictionary = 1 [default = true];</code>
       */
      private void clearUseLocalUsageDictionary() {
        bitField0_ = (bitField0_ & ~0x00000001);
        useLocalUsageDictionary_ = true;
      }

      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }

      public static Builder newBuilder() {
        return (Builder) DEFAULT_INSTANCE.createBuilder();
      }
      public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig prototype) {
        return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
      }

      /**
       * Protobuf type {@code mozc.config.Config.InformationListConfig}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageLite.Builder<
            org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig, Builder> implements
          // @@protoc_insertion_point(builder_implements:mozc.config.Config.InformationListConfig)
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfigOrBuilder {
        // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.newBuilder()
        private Builder() {
          super(DEFAULT_INSTANCE);
        }


        /**
         * <code>optional bool use_local_usage_dictionary = 1 [default = true];</code>
         * @return Whether the useLocalUsageDictionary field is set.
         */
        @java.lang.Override
        public boolean hasUseLocalUsageDictionary() {
          return instance.hasUseLocalUsageDictionary();
        }
        /**
         * <code>optional bool use_local_usage_dictionary = 1 [default = true];</code>
         * @return The useLocalUsageDictionary.
         */
        @java.lang.Override
        public boolean getUseLocalUsageDictionary() {
          return instance.getUseLocalUsageDictionary();
        }
        /**
         * <code>optional bool use_local_usage_dictionary = 1 [default = true];</code>
         * @param value The useLocalUsageDictionary to set.
         * @return This builder for chaining.
         */
        public Builder setUseLocalUsageDictionary(boolean value) {
          copyOnWrite();
          instance.setUseLocalUsageDictionary(value);
          return this;
        }
        /**
         * <code>optional bool use_local_usage_dictionary = 1 [default = true];</code>
         * @return This builder for chaining.
         */
        public Builder clearUseLocalUsageDictionary() {
          copyOnWrite();
          instance.clearUseLocalUsageDictionary();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:mozc.config.Config.InformationListConfig)
      }
      @java.lang.Override
      @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
      protected final java.lang.Object dynamicMethod(
          com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
          java.lang.Object arg0, java.lang.Object arg1) {
        switch (method) {
          case NEW_MUTABLE_INSTANCE: {
            return new org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig();
          }
          case NEW_BUILDER: {
            return new Builder();
          }
          case BUILD_MESSAGE_INFO: {
              java.lang.Object[] objects = new java.lang.Object[] {
                "bitField0_",
                "useLocalUsageDictionary_",
              };
              java.lang.String info =
                  "\u0001\u0001\u0000\u0001\u0001\u0001\u0001\u0000\u0000\u0000\u0001\u1007\u0000";
              return newMessageInfo(DEFAULT_INSTANCE, info, objects);
          }
          // fall through
          case GET_DEFAULT_INSTANCE: {
            return DEFAULT_INSTANCE;
          }
          case GET_PARSER: {
            com.google.protobuf.Parser<org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig> parser = PARSER;
            if (parser == null) {
              synchronized (org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.class) {
                parser = PARSER;
                if (parser == null) {
                  parser =
                      new DefaultInstanceBasedParser<org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig>(
                          DEFAULT_INSTANCE);
                  PARSER = parser;
                }
              }
            }
            return parser;
        }
        case GET_MEMOIZED_IS_INITIALIZED: {
          return (byte) 1;
        }
        case SET_MEMOIZED_IS_INITIALIZED: {
          return null;
        }
        }
        throw new UnsupportedOperationException();
      }


      // @@protoc_insertion_point(class_scope:mozc.config.Config.InformationListConfig)
      private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig DEFAULT_INSTANCE;
      static {
        InformationListConfig defaultInstance = new InformationListConfig();
        // New instances are implicitly immutable so no need to make
        // immutable.
        DEFAULT_INSTANCE = defaultInstance;
        com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
          InformationListConfig.class, defaultInstance);
      }

      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static volatile com.google.protobuf.Parser<InformationListConfig> PARSER;

      public static com.google.protobuf.Parser<InformationListConfig> parser() {
        return DEFAULT_INSTANCE.getParserForType();
      }
    }

    private int bitField0_;
    private int bitField1_;
    public static final int GENERAL_CONFIG_FIELD_NUMBER = 1;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig generalConfig_;
    /**
     * <pre>
     * General config and logging/debugging:
     * We won't use 2-9 and 20-39 ids anymore for historical reasons.
     * </pre>
     *
     * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
     */
    @java.lang.Override
    public boolean hasGeneralConfig() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * General config and logging/debugging:
     * We won't use 2-9 and 20-39 ids anymore for historical reasons.
     * </pre>
     *
     * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig getGeneralConfig() {
      return generalConfig_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.getDefaultInstance() : generalConfig_;
    }
    /**
     * <pre>
     * General config and logging/debugging:
     * We won't use 2-9 and 20-39 ids anymore for historical reasons.
     * </pre>
     *
     * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
     */
    private void setGeneralConfig(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig value) {
      value.getClass();
  generalConfig_ = value;
      bitField0_ |= 0x00000001;
      }
    /**
     * <pre>
     * General config and logging/debugging:
     * We won't use 2-9 and 20-39 ids anymore for historical reasons.
     * </pre>
     *
     * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeGeneralConfig(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig value) {
      value.getClass();
  if (generalConfig_ != null &&
          generalConfig_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.getDefaultInstance()) {
        generalConfig_ =
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.newBuilder(generalConfig_).mergeFrom(value).buildPartial();
      } else {
        generalConfig_ = value;
      }
      bitField0_ |= 0x00000001;
    }
    /**
     * <pre>
     * General config and logging/debugging:
     * We won't use 2-9 and 20-39 ids anymore for historical reasons.
     * </pre>
     *
     * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
     */
    private void clearGeneralConfig() {  generalConfig_ = null;
      bitField0_ = (bitField0_ & ~0x00000001);
    }

    public static final int VERBOSE_LEVEL_FIELD_NUMBER = 10;
    private int verboseLevel_;
    /**
     * <pre>
     * set verbose level of logging library (FLAGS_v)
     * </pre>
     *
     * <code>optional int32 verbose_level = 10 [default = 0];</code>
     * @return Whether the verboseLevel field is set.
     */
    @java.lang.Override
    public boolean hasVerboseLevel() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * set verbose level of logging library (FLAGS_v)
     * </pre>
     *
     * <code>optional int32 verbose_level = 10 [default = 0];</code>
     * @return The verboseLevel.
     */
    @java.lang.Override
    public int getVerboseLevel() {
      return verboseLevel_;
    }
    /**
     * <pre>
     * set verbose level of logging library (FLAGS_v)
     * </pre>
     *
     * <code>optional int32 verbose_level = 10 [default = 0];</code>
     * @param value The verboseLevel to set.
     */
    private void setVerboseLevel(int value) {
      bitField0_ |= 0x00000002;
      verboseLevel_ = value;
    }
    /**
     * <pre>
     * set verbose level of logging library (FLAGS_v)
     * </pre>
     *
     * <code>optional int32 verbose_level = 10 [default = 0];</code>
     */
    private void clearVerboseLevel() {
      bitField0_ = (bitField0_ & ~0x00000002);
      verboseLevel_ = 0;
    }

    public static final int INCOGNITO_MODE_FIELD_NUMBER = 20;
    private boolean incognitoMode_;
    /**
     * <pre>
     * Incognito mode:
     * Disable all mutable operation if incognito_mode is true
     * Clients needs to check ConversionRequest::incognito_mode() instead
     * of Config::incognito_mode(), as the incoginto mode can also set
     * via Options.
     * </pre>
     *
     * <code>optional bool incognito_mode = 20 [default = false];</code>
     * @return Whether the incognitoMode field is set.
     */
    @java.lang.Override
    public boolean hasIncognitoMode() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Incognito mode:
     * Disable all mutable operation if incognito_mode is true
     * Clients needs to check ConversionRequest::incognito_mode() instead
     * of Config::incognito_mode(), as the incoginto mode can also set
     * via Options.
     * </pre>
     *
     * <code>optional bool incognito_mode = 20 [default = false];</code>
     * @return The incognitoMode.
     */
    @java.lang.Override
    public boolean getIncognitoMode() {
      return incognitoMode_;
    }
    /**
     * <pre>
     * Incognito mode:
     * Disable all mutable operation if incognito_mode is true
     * Clients needs to check ConversionRequest::incognito_mode() instead
     * of Config::incognito_mode(), as the incoginto mode can also set
     * via Options.
     * </pre>
     *
     * <code>optional bool incognito_mode = 20 [default = false];</code>
     * @param value The incognitoMode to set.
     */
    private void setIncognitoMode(boolean value) {
      bitField0_ |= 0x00000004;
      incognitoMode_ = value;
    }
    /**
     * <pre>
     * Incognito mode:
     * Disable all mutable operation if incognito_mode is true
     * Clients needs to check ConversionRequest::incognito_mode() instead
     * of Config::incognito_mode(), as the incoginto mode can also set
     * via Options.
     * </pre>
     *
     * <code>optional bool incognito_mode = 20 [default = false];</code>
     */
    private void clearIncognitoMode() {
      bitField0_ = (bitField0_ & ~0x00000004);
      incognitoMode_ = false;
    }

    public static final int CHECK_DEFAULT_FIELD_NUMBER = 22;
    private boolean checkDefault_;
    /**
     * <pre>
     * whether to show the set default dialog on startup
     * </pre>
     *
     * <code>optional bool check_default = 22 [default = true];</code>
     * @return Whether the checkDefault field is set.
     */
    @java.lang.Override
    public boolean hasCheckDefault() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * whether to show the set default dialog on startup
     * </pre>
     *
     * <code>optional bool check_default = 22 [default = true];</code>
     * @return The checkDefault.
     */
    @java.lang.Override
    public boolean getCheckDefault() {
      return checkDefault_;
    }
    /**
     * <pre>
     * whether to show the set default dialog on startup
     * </pre>
     *
     * <code>optional bool check_default = 22 [default = true];</code>
     * @param value The checkDefault to set.
     */
    private void setCheckDefault(boolean value) {
      bitField0_ |= 0x00000008;
      checkDefault_ = value;
    }
    /**
     * <pre>
     * whether to show the set default dialog on startup
     * </pre>
     *
     * <code>optional bool check_default = 22 [default = true];</code>
     */
    private void clearCheckDefault() {
      bitField0_ = (bitField0_ & ~0x00000008);
      checkDefault_ = true;
    }

    public static final int PRESENTATION_MODE_FIELD_NUMBER = 23;
    private boolean presentationMode_;
    /**
     * <pre>
     * Presentation mode:
     * disable all suggestion temporally.
     * </pre>
     *
     * <code>optional bool presentation_mode = 23 [default = false];</code>
     * @return Whether the presentationMode field is set.
     */
    @java.lang.Override
    public boolean hasPresentationMode() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Presentation mode:
     * disable all suggestion temporally.
     * </pre>
     *
     * <code>optional bool presentation_mode = 23 [default = false];</code>
     * @return The presentationMode.
     */
    @java.lang.Override
    public boolean getPresentationMode() {
      return presentationMode_;
    }
    /**
     * <pre>
     * Presentation mode:
     * disable all suggestion temporally.
     * </pre>
     *
     * <code>optional bool presentation_mode = 23 [default = false];</code>
     * @param value The presentationMode to set.
     */
    private void setPresentationMode(boolean value) {
      bitField0_ |= 0x00000010;
      presentationMode_ = value;
    }
    /**
     * <pre>
     * Presentation mode:
     * disable all suggestion temporally.
     * </pre>
     *
     * <code>optional bool presentation_mode = 23 [default = false];</code>
     */
    private void clearPresentationMode() {
      bitField0_ = (bitField0_ & ~0x00000010);
      presentationMode_ = false;
    }

    public static final int PREEDIT_METHOD_FIELD_NUMBER = 40;
    private int preeditMethod_;
    /**
     * <pre>
     * Roman/Kana
     * </pre>
     *
     * <code>optional .mozc.config.Config.PreeditMethod preedit_method = 40 [default = ROMAN];</code>
     * @return Whether the preeditMethod field is set.
     */
    @java.lang.Override
    public boolean hasPreeditMethod() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * Roman/Kana
     * </pre>
     *
     * <code>optional .mozc.config.Config.PreeditMethod preedit_method = 40 [default = ROMAN];</code>
     * @return The preeditMethod.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod getPreeditMethod() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod.forNumber(preeditMethod_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod.ROMAN : result;
    }
    /**
     * <pre>
     * Roman/Kana
     * </pre>
     *
     * <code>optional .mozc.config.Config.PreeditMethod preedit_method = 40 [default = ROMAN];</code>
     * @param value The preeditMethod to set.
     */
    private void setPreeditMethod(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod value) {
      preeditMethod_ = value.getNumber();
      bitField0_ |= 0x00000020;
    }
    /**
     * <pre>
     * Roman/Kana
     * </pre>
     *
     * <code>optional .mozc.config.Config.PreeditMethod preedit_method = 40 [default = ROMAN];</code>
     */
    private void clearPreeditMethod() {
      bitField0_ = (bitField0_ & ~0x00000020);
      preeditMethod_ = 0;
    }

    public static final int SESSION_KEYMAP_FIELD_NUMBER = 41;
    private int sessionKeymap_;
    /**
     * <code>optional .mozc.config.Config.SessionKeymap session_keymap = 41 [default = NONE];</code>
     * @return Whether the sessionKeymap field is set.
     */
    @java.lang.Override
    public boolean hasSessionKeymap() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <code>optional .mozc.config.Config.SessionKeymap session_keymap = 41 [default = NONE];</code>
     * @return The sessionKeymap.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap getSessionKeymap() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap.forNumber(sessionKeymap_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap.NONE : result;
    }
    /**
     * <code>optional .mozc.config.Config.SessionKeymap session_keymap = 41 [default = NONE];</code>
     * @param value The sessionKeymap to set.
     */
    private void setSessionKeymap(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap value) {
      sessionKeymap_ = value.getNumber();
      bitField0_ |= 0x00000040;
    }
    /**
     * <code>optional .mozc.config.Config.SessionKeymap session_keymap = 41 [default = NONE];</code>
     */
    private void clearSessionKeymap() {
      bitField0_ = (bitField0_ & ~0x00000040);
      sessionKeymap_ = -1;
    }

    public static final int CUSTOM_KEYMAP_TABLE_FIELD_NUMBER = 42;
    private com.google.protobuf.ByteString customKeymapTable_;
    /**
     * <pre>
     * custom keymap
     * TODO(taku): replace it with repeated field
     * </pre>
     *
     * <code>optional bytes custom_keymap_table = 42;</code>
     * @return Whether the customKeymapTable field is set.
     */
    @java.lang.Override
    public boolean hasCustomKeymapTable() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * custom keymap
     * TODO(taku): replace it with repeated field
     * </pre>
     *
     * <code>optional bytes custom_keymap_table = 42;</code>
     * @return The customKeymapTable.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getCustomKeymapTable() {
      return customKeymapTable_;
    }
    /**
     * <pre>
     * custom keymap
     * TODO(taku): replace it with repeated field
     * </pre>
     *
     * <code>optional bytes custom_keymap_table = 42;</code>
     * @param value The customKeymapTable to set.
     */
    private void setCustomKeymapTable(com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000080;
      customKeymapTable_ = value;
    }
    /**
     * <pre>
     * custom keymap
     * TODO(taku): replace it with repeated field
     * </pre>
     *
     * <code>optional bytes custom_keymap_table = 42;</code>
     */
    private void clearCustomKeymapTable() {
      bitField0_ = (bitField0_ & ~0x00000080);
      customKeymapTable_ = getDefaultInstance().getCustomKeymapTable();
    }

    public static final int CUSTOM_ROMAN_TABLE_FIELD_NUMBER = 43;
    private com.google.protobuf.ByteString customRomanTable_;
    /**
     * <pre>
     * custom roman table
     * </pre>
     *
     * <code>optional bytes custom_roman_table = 43;</code>
     * @return Whether the customRomanTable field is set.
     */
    @java.lang.Override
    public boolean hasCustomRomanTable() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * custom roman table
     * </pre>
     *
     * <code>optional bytes custom_roman_table = 43;</code>
     * @return The customRomanTable.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getCustomRomanTable() {
      return customRomanTable_;
    }
    /**
     * <pre>
     * custom roman table
     * </pre>
     *
     * <code>optional bytes custom_roman_table = 43;</code>
     * @param value The customRomanTable to set.
     */
    private void setCustomRomanTable(com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000100;
      customRomanTable_ = value;
    }
    /**
     * <pre>
     * custom roman table
     * </pre>
     *
     * <code>optional bytes custom_roman_table = 43;</code>
     */
    private void clearCustomRomanTable() {
      bitField0_ = (bitField0_ & ~0x00000100);
      customRomanTable_ = getDefaultInstance().getCustomRomanTable();
    }

    public static final int PUNCTUATION_METHOD_FIELD_NUMBER = 45;
    private int punctuationMethod_;
    /**
     * <code>optional .mozc.config.Config.PunctuationMethod punctuation_method = 45 [default = TOUTEN_KUTEN];</code>
     * @return Whether the punctuationMethod field is set.
     */
    @java.lang.Override
    public boolean hasPunctuationMethod() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <code>optional .mozc.config.Config.PunctuationMethod punctuation_method = 45 [default = TOUTEN_KUTEN];</code>
     * @return The punctuationMethod.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod getPunctuationMethod() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod.forNumber(punctuationMethod_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod.TOUTEN_KUTEN : result;
    }
    /**
     * <code>optional .mozc.config.Config.PunctuationMethod punctuation_method = 45 [default = TOUTEN_KUTEN];</code>
     * @param value The punctuationMethod to set.
     */
    private void setPunctuationMethod(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod value) {
      punctuationMethod_ = value.getNumber();
      bitField0_ |= 0x00000200;
    }
    /**
     * <code>optional .mozc.config.Config.PunctuationMethod punctuation_method = 45 [default = TOUTEN_KUTEN];</code>
     */
    private void clearPunctuationMethod() {
      bitField0_ = (bitField0_ & ~0x00000200);
      punctuationMethod_ = 0;
    }

    public static final int SYMBOL_METHOD_FIELD_NUMBER = 46;
    private int symbolMethod_;
    /**
     * <code>optional .mozc.config.Config.SymbolMethod symbol_method = 46 [default = CORNER_BRACKET_MIDDLE_DOT];</code>
     * @return Whether the symbolMethod field is set.
     */
    @java.lang.Override
    public boolean hasSymbolMethod() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     * <code>optional .mozc.config.Config.SymbolMethod symbol_method = 46 [default = CORNER_BRACKET_MIDDLE_DOT];</code>
     * @return The symbolMethod.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod getSymbolMethod() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod.forNumber(symbolMethod_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod.CORNER_BRACKET_MIDDLE_DOT : result;
    }
    /**
     * <code>optional .mozc.config.Config.SymbolMethod symbol_method = 46 [default = CORNER_BRACKET_MIDDLE_DOT];</code>
     * @param value The symbolMethod to set.
     */
    private void setSymbolMethod(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod value) {
      symbolMethod_ = value.getNumber();
      bitField0_ |= 0x00000400;
    }
    /**
     * <code>optional .mozc.config.Config.SymbolMethod symbol_method = 46 [default = CORNER_BRACKET_MIDDLE_DOT];</code>
     */
    private void clearSymbolMethod() {
      bitField0_ = (bitField0_ & ~0x00000400);
      symbolMethod_ = 0;
    }

    public static final int SPACE_CHARACTER_FORM_FIELD_NUMBER = 47;
    private int spaceCharacterForm_;
    /**
     * <code>optional .mozc.config.Config.FundamentalCharacterForm space_character_form = 47 [default = FUNDAMENTAL_INPUT_MODE];</code>
     * @return Whether the spaceCharacterForm field is set.
     */
    @java.lang.Override
    public boolean hasSpaceCharacterForm() {
      return ((bitField0_ & 0x00000800) != 0);
    }
    /**
     * <code>optional .mozc.config.Config.FundamentalCharacterForm space_character_form = 47 [default = FUNDAMENTAL_INPUT_MODE];</code>
     * @return The spaceCharacterForm.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm getSpaceCharacterForm() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm.forNumber(spaceCharacterForm_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm.FUNDAMENTAL_INPUT_MODE : result;
    }
    /**
     * <code>optional .mozc.config.Config.FundamentalCharacterForm space_character_form = 47 [default = FUNDAMENTAL_INPUT_MODE];</code>
     * @param value The spaceCharacterForm to set.
     */
    private void setSpaceCharacterForm(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm value) {
      spaceCharacterForm_ = value.getNumber();
      bitField0_ |= 0x00000800;
    }
    /**
     * <code>optional .mozc.config.Config.FundamentalCharacterForm space_character_form = 47 [default = FUNDAMENTAL_INPUT_MODE];</code>
     */
    private void clearSpaceCharacterForm() {
      bitField0_ = (bitField0_ & ~0x00000800);
      spaceCharacterForm_ = 0;
    }

    public static final int USE_KEYBOARD_TO_CHANGE_PREEDIT_METHOD_FIELD_NUMBER = 48;
    private boolean useKeyboardToChangePreeditMethod_;
    /**
     * <pre>
     * If this flag is true, Mozc toggles preedit method with some predefined
     * key events when IME is turned on.  Otherwise, Mozc ignores such kind of
     * key events so that their preferred can be preserved even when the toggle
     * key is pressed by accident.
     * As for Mozc, only Windows client supports such kind of toggle so this flag
     * is currently valid only on Windows.
     * Background:
     *   Traditional Japanese IMEs have used "Roma-Ji" key in Japanese 106/109
     *   keyboard to toggle the preedit method between Roman and Kana style and
     *   this behavior was finally adopted into JIS X 4064:2002 as a basic
     *   functionality which is expected to support by a Japanese Input Method.
     *   However, people who are not aware of this functionality have been
     *   puzzled because the default key stroke is likely to be pressed
     *   by accident.
     * </pre>
     *
     * <code>optional bool use_keyboard_to_change_preedit_method = 48 [default = false];</code>
     * @return Whether the useKeyboardToChangePreeditMethod field is set.
     */
    @java.lang.Override
    public boolean hasUseKeyboardToChangePreeditMethod() {
      return ((bitField0_ & 0x00001000) != 0);
    }
    /**
     * <pre>
     * If this flag is true, Mozc toggles preedit method with some predefined
     * key events when IME is turned on.  Otherwise, Mozc ignores such kind of
     * key events so that their preferred can be preserved even when the toggle
     * key is pressed by accident.
     * As for Mozc, only Windows client supports such kind of toggle so this flag
     * is currently valid only on Windows.
     * Background:
     *   Traditional Japanese IMEs have used "Roma-Ji" key in Japanese 106/109
     *   keyboard to toggle the preedit method between Roman and Kana style and
     *   this behavior was finally adopted into JIS X 4064:2002 as a basic
     *   functionality which is expected to support by a Japanese Input Method.
     *   However, people who are not aware of this functionality have been
     *   puzzled because the default key stroke is likely to be pressed
     *   by accident.
     * </pre>
     *
     * <code>optional bool use_keyboard_to_change_preedit_method = 48 [default = false];</code>
     * @return The useKeyboardToChangePreeditMethod.
     */
    @java.lang.Override
    public boolean getUseKeyboardToChangePreeditMethod() {
      return useKeyboardToChangePreeditMethod_;
    }
    /**
     * <pre>
     * If this flag is true, Mozc toggles preedit method with some predefined
     * key events when IME is turned on.  Otherwise, Mozc ignores such kind of
     * key events so that their preferred can be preserved even when the toggle
     * key is pressed by accident.
     * As for Mozc, only Windows client supports such kind of toggle so this flag
     * is currently valid only on Windows.
     * Background:
     *   Traditional Japanese IMEs have used "Roma-Ji" key in Japanese 106/109
     *   keyboard to toggle the preedit method between Roman and Kana style and
     *   this behavior was finally adopted into JIS X 4064:2002 as a basic
     *   functionality which is expected to support by a Japanese Input Method.
     *   However, people who are not aware of this functionality have been
     *   puzzled because the default key stroke is likely to be pressed
     *   by accident.
     * </pre>
     *
     * <code>optional bool use_keyboard_to_change_preedit_method = 48 [default = false];</code>
     * @param value The useKeyboardToChangePreeditMethod to set.
     */
    private void setUseKeyboardToChangePreeditMethod(boolean value) {
      bitField0_ |= 0x00001000;
      useKeyboardToChangePreeditMethod_ = value;
    }
    /**
     * <pre>
     * If this flag is true, Mozc toggles preedit method with some predefined
     * key events when IME is turned on.  Otherwise, Mozc ignores such kind of
     * key events so that their preferred can be preserved even when the toggle
     * key is pressed by accident.
     * As for Mozc, only Windows client supports such kind of toggle so this flag
     * is currently valid only on Windows.
     * Background:
     *   Traditional Japanese IMEs have used "Roma-Ji" key in Japanese 106/109
     *   keyboard to toggle the preedit method between Roman and Kana style and
     *   this behavior was finally adopted into JIS X 4064:2002 as a basic
     *   functionality which is expected to support by a Japanese Input Method.
     *   However, people who are not aware of this functionality have been
     *   puzzled because the default key stroke is likely to be pressed
     *   by accident.
     * </pre>
     *
     * <code>optional bool use_keyboard_to_change_preedit_method = 48 [default = false];</code>
     */
    private void clearUseKeyboardToChangePreeditMethod() {
      bitField0_ = (bitField0_ & ~0x00001000);
      useKeyboardToChangePreeditMethod_ = false;
    }

    public static final int HISTORY_LEARNING_LEVEL_FIELD_NUMBER = 50;
    private int historyLearningLevel_;
    /**
     * <code>optional .mozc.config.Config.HistoryLearningLevel history_learning_level = 50 [default = DEFAULT_HISTORY];</code>
     * @return Whether the historyLearningLevel field is set.
     */
    @java.lang.Override
    public boolean hasHistoryLearningLevel() {
      return ((bitField0_ & 0x00002000) != 0);
    }
    /**
     * <code>optional .mozc.config.Config.HistoryLearningLevel history_learning_level = 50 [default = DEFAULT_HISTORY];</code>
     * @return The historyLearningLevel.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel getHistoryLearningLevel() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel.forNumber(historyLearningLevel_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel.DEFAULT_HISTORY : result;
    }
    /**
     * <code>optional .mozc.config.Config.HistoryLearningLevel history_learning_level = 50 [default = DEFAULT_HISTORY];</code>
     * @param value The historyLearningLevel to set.
     */
    private void setHistoryLearningLevel(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel value) {
      historyLearningLevel_ = value.getNumber();
      bitField0_ |= 0x00002000;
    }
    /**
     * <code>optional .mozc.config.Config.HistoryLearningLevel history_learning_level = 50 [default = DEFAULT_HISTORY];</code>
     */
    private void clearHistoryLearningLevel() {
      bitField0_ = (bitField0_ & ~0x00002000);
      historyLearningLevel_ = 0;
    }

    public static final int SELECTION_SHORTCUT_FIELD_NUMBER = 52;
    private int selectionShortcut_;
    /**
     * <code>optional .mozc.config.Config.SelectionShortcut selection_shortcut = 52 [default = SHORTCUT_123456789];</code>
     * @return Whether the selectionShortcut field is set.
     */
    @java.lang.Override
    public boolean hasSelectionShortcut() {
      return ((bitField0_ & 0x00004000) != 0);
    }
    /**
     * <code>optional .mozc.config.Config.SelectionShortcut selection_shortcut = 52 [default = SHORTCUT_123456789];</code>
     * @return The selectionShortcut.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut getSelectionShortcut() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut.forNumber(selectionShortcut_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut.SHORTCUT_123456789 : result;
    }
    /**
     * <code>optional .mozc.config.Config.SelectionShortcut selection_shortcut = 52 [default = SHORTCUT_123456789];</code>
     * @param value The selectionShortcut to set.
     */
    private void setSelectionShortcut(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut value) {
      selectionShortcut_ = value.getNumber();
      bitField0_ |= 0x00004000;
    }
    /**
     * <code>optional .mozc.config.Config.SelectionShortcut selection_shortcut = 52 [default = SHORTCUT_123456789];</code>
     */
    private void clearSelectionShortcut() {
      bitField0_ = (bitField0_ & ~0x00004000);
      selectionShortcut_ = 1;
    }

    public static final int CHARACTER_FORM_RULES_FIELD_NUMBER = 54;
    private com.google.protobuf.Internal.ProtobufList<org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule> characterFormRules_;
    /**
     * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
     */
    @java.lang.Override
    public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule> getCharacterFormRulesList() {
      return characterFormRules_;
    }
    /**
     * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
     */
    public java.util.List<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRuleOrBuilder> 
        getCharacterFormRulesOrBuilderList() {
      return characterFormRules_;
    }
    /**
     * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
     */
    @java.lang.Override
    public int getCharacterFormRulesCount() {
      return characterFormRules_.size();
    }
    /**
     * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule getCharacterFormRules(int index) {
      return characterFormRules_.get(index);
    }
    /**
     * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
     */
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRuleOrBuilder getCharacterFormRulesOrBuilder(
        int index) {
      return characterFormRules_.get(index);
    }
    private void ensureCharacterFormRulesIsMutable() {
      com.google.protobuf.Internal.ProtobufList<org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule> tmp = characterFormRules_;
      if (!tmp.isModifiable()) {
        characterFormRules_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
     */
    private void setCharacterFormRules(
        int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule value) {
      value.getClass();
  ensureCharacterFormRulesIsMutable();
      characterFormRules_.set(index, value);
    }
    /**
     * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
     */
    private void addCharacterFormRules(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule value) {
      value.getClass();
  ensureCharacterFormRulesIsMutable();
      characterFormRules_.add(value);
    }
    /**
     * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
     */
    private void addCharacterFormRules(
        int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule value) {
      value.getClass();
  ensureCharacterFormRulesIsMutable();
      characterFormRules_.add(index, value);
    }
    /**
     * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
     */
    private void addAllCharacterFormRules(
        java.lang.Iterable<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule> values) {
      ensureCharacterFormRulesIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, characterFormRules_);
    }
    /**
     * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
     */
    private void clearCharacterFormRules() {
      characterFormRules_ = emptyProtobufList();
    }
    /**
     * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
     */
    private void removeCharacterFormRules(int index) {
      ensureCharacterFormRulesIsMutable();
      characterFormRules_.remove(index);
    }

    public static final int AUTO_SWITCH_COMPOSITION_MODE_FIELD_NUMBER = 56;
    private boolean autoSwitchCompositionMode_;
    /**
     * <pre>
     * Automatically switch composition mode.
     * </pre>
     *
     * <code>optional bool auto_switch_composition_mode = 56 [default = true];</code>
     * @return Whether the autoSwitchCompositionMode field is set.
     */
    @java.lang.Override
    public boolean hasAutoSwitchCompositionMode() {
      return ((bitField0_ & 0x00008000) != 0);
    }
    /**
     * <pre>
     * Automatically switch composition mode.
     * </pre>
     *
     * <code>optional bool auto_switch_composition_mode = 56 [default = true];</code>
     * @return The autoSwitchCompositionMode.
     */
    @java.lang.Override
    public boolean getAutoSwitchCompositionMode() {
      return autoSwitchCompositionMode_;
    }
    /**
     * <pre>
     * Automatically switch composition mode.
     * </pre>
     *
     * <code>optional bool auto_switch_composition_mode = 56 [default = true];</code>
     * @param value The autoSwitchCompositionMode to set.
     */
    private void setAutoSwitchCompositionMode(boolean value) {
      bitField0_ |= 0x00008000;
      autoSwitchCompositionMode_ = value;
    }
    /**
     * <pre>
     * Automatically switch composition mode.
     * </pre>
     *
     * <code>optional bool auto_switch_composition_mode = 56 [default = true];</code>
     */
    private void clearAutoSwitchCompositionMode() {
      bitField0_ = (bitField0_ & ~0x00008000);
      autoSwitchCompositionMode_ = true;
    }

    public static final int USE_CASCADING_WINDOW_FIELD_NUMBER = 58;
    private boolean useCascadingWindow_;
    /**
     * <pre>
     * Toggle to use cascanding window for debugging.
     * </pre>
     *
     * <code>optional bool use_cascading_window = 58 [default = true];</code>
     * @return Whether the useCascadingWindow field is set.
     */
    @java.lang.Override
    public boolean hasUseCascadingWindow() {
      return ((bitField0_ & 0x00010000) != 0);
    }
    /**
     * <pre>
     * Toggle to use cascanding window for debugging.
     * </pre>
     *
     * <code>optional bool use_cascading_window = 58 [default = true];</code>
     * @return The useCascadingWindow.
     */
    @java.lang.Override
    public boolean getUseCascadingWindow() {
      return useCascadingWindow_;
    }
    /**
     * <pre>
     * Toggle to use cascanding window for debugging.
     * </pre>
     *
     * <code>optional bool use_cascading_window = 58 [default = true];</code>
     * @param value The useCascadingWindow to set.
     */
    private void setUseCascadingWindow(boolean value) {
      bitField0_ |= 0x00010000;
      useCascadingWindow_ = value;
    }
    /**
     * <pre>
     * Toggle to use cascanding window for debugging.
     * </pre>
     *
     * <code>optional bool use_cascading_window = 58 [default = true];</code>
     */
    private void clearUseCascadingWindow() {
      bitField0_ = (bitField0_ & ~0x00010000);
      useCascadingWindow_ = true;
    }

    public static final int SHIFT_KEY_MODE_SWITCH_FIELD_NUMBER = 59;
    private int shiftKeyModeSwitch_;
    /**
     * <code>optional .mozc.config.Config.ShiftKeyModeSwitch shift_key_mode_switch = 59 [default = ASCII_INPUT_MODE];</code>
     * @return Whether the shiftKeyModeSwitch field is set.
     */
    @java.lang.Override
    public boolean hasShiftKeyModeSwitch() {
      return ((bitField0_ & 0x00020000) != 0);
    }
    /**
     * <code>optional .mozc.config.Config.ShiftKeyModeSwitch shift_key_mode_switch = 59 [default = ASCII_INPUT_MODE];</code>
     * @return The shiftKeyModeSwitch.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch getShiftKeyModeSwitch() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch.forNumber(shiftKeyModeSwitch_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch.ASCII_INPUT_MODE : result;
    }
    /**
     * <code>optional .mozc.config.Config.ShiftKeyModeSwitch shift_key_mode_switch = 59 [default = ASCII_INPUT_MODE];</code>
     * @param value The shiftKeyModeSwitch to set.
     */
    private void setShiftKeyModeSwitch(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch value) {
      shiftKeyModeSwitch_ = value.getNumber();
      bitField0_ |= 0x00020000;
    }
    /**
     * <code>optional .mozc.config.Config.ShiftKeyModeSwitch shift_key_mode_switch = 59 [default = ASCII_INPUT_MODE];</code>
     */
    private void clearShiftKeyModeSwitch() {
      bitField0_ = (bitField0_ & ~0x00020000);
      shiftKeyModeSwitch_ = 1;
    }

    public static final int NUMPAD_CHARACTER_FORM_FIELD_NUMBER = 60;
    private int numpadCharacterForm_;
    /**
     * <code>optional .mozc.config.Config.NumpadCharacterForm numpad_character_form = 60 [default = NUMPAD_HALF_WIDTH];</code>
     * @return Whether the numpadCharacterForm field is set.
     */
    @java.lang.Override
    public boolean hasNumpadCharacterForm() {
      return ((bitField0_ & 0x00040000) != 0);
    }
    /**
     * <code>optional .mozc.config.Config.NumpadCharacterForm numpad_character_form = 60 [default = NUMPAD_HALF_WIDTH];</code>
     * @return The numpadCharacterForm.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm getNumpadCharacterForm() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm.forNumber(numpadCharacterForm_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm.NUMPAD_HALF_WIDTH : result;
    }
    /**
     * <code>optional .mozc.config.Config.NumpadCharacterForm numpad_character_form = 60 [default = NUMPAD_HALF_WIDTH];</code>
     * @param value The numpadCharacterForm to set.
     */
    private void setNumpadCharacterForm(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm value) {
      numpadCharacterForm_ = value.getNumber();
      bitField0_ |= 0x00040000;
    }
    /**
     * <code>optional .mozc.config.Config.NumpadCharacterForm numpad_character_form = 60 [default = NUMPAD_HALF_WIDTH];</code>
     */
    private void clearNumpadCharacterForm() {
      bitField0_ = (bitField0_ & ~0x00040000);
      numpadCharacterForm_ = 2;
    }

    public static final int USE_AUTO_CONVERSION_FIELD_NUMBER = 61;
    private boolean useAutoConversion_;
    /**
     * <code>optional bool use_auto_conversion = 61 [default = false];</code>
     * @return Whether the useAutoConversion field is set.
     */
    @java.lang.Override
    public boolean hasUseAutoConversion() {
      return ((bitField0_ & 0x00080000) != 0);
    }
    /**
     * <code>optional bool use_auto_conversion = 61 [default = false];</code>
     * @return The useAutoConversion.
     */
    @java.lang.Override
    public boolean getUseAutoConversion() {
      return useAutoConversion_;
    }
    /**
     * <code>optional bool use_auto_conversion = 61 [default = false];</code>
     * @param value The useAutoConversion to set.
     */
    private void setUseAutoConversion(boolean value) {
      bitField0_ |= 0x00080000;
      useAutoConversion_ = value;
    }
    /**
     * <code>optional bool use_auto_conversion = 61 [default = false];</code>
     */
    private void clearUseAutoConversion() {
      bitField0_ = (bitField0_ & ~0x00080000);
      useAutoConversion_ = false;
    }

    public static final int AUTO_CONVERSION_KEY_FIELD_NUMBER = 62;
    private int autoConversionKey_;
    /**
     * <pre>
     * can't use AutoConversionKey as a type since
     * undefined enum type is not correctly handled.
     * </pre>
     *
     * <code>optional uint32 auto_conversion_key = 62 [default = 13];</code>
     * @return Whether the autoConversionKey field is set.
     */
    @java.lang.Override
    public boolean hasAutoConversionKey() {
      return ((bitField0_ & 0x00100000) != 0);
    }
    /**
     * <pre>
     * can't use AutoConversionKey as a type since
     * undefined enum type is not correctly handled.
     * </pre>
     *
     * <code>optional uint32 auto_conversion_key = 62 [default = 13];</code>
     * @return The autoConversionKey.
     */
    @java.lang.Override
    public int getAutoConversionKey() {
      return autoConversionKey_;
    }
    /**
     * <pre>
     * can't use AutoConversionKey as a type since
     * undefined enum type is not correctly handled.
     * </pre>
     *
     * <code>optional uint32 auto_conversion_key = 62 [default = 13];</code>
     * @param value The autoConversionKey to set.
     */
    private void setAutoConversionKey(int value) {
      bitField0_ |= 0x00100000;
      autoConversionKey_ = value;
    }
    /**
     * <pre>
     * can't use AutoConversionKey as a type since
     * undefined enum type is not correctly handled.
     * </pre>
     *
     * <code>optional uint32 auto_conversion_key = 62 [default = 13];</code>
     */
    private void clearAutoConversionKey() {
      bitField0_ = (bitField0_ & ~0x00100000);
      autoConversionKey_ = 13;
    }

    public static final int YEN_SIGN_CHARACTER_FIELD_NUMBER = 63;
    private int yenSignCharacter_;
    /**
     * <pre>
     * Mac-original JIS key layout has "yen-sign" key which generates
     * U+00A5 instead of U+005C and sometimes users get troubles with
     * them because they expect backslashes which are rendered as
     * yen-sign.  If this configuration is BACKSLASH, Mozc will
     * interpret U+005C even when the original key event is U+00A5.
     * </pre>
     *
     * <code>optional .mozc.config.Config.YenSignCharacter yen_sign_character = 63 [default = YEN_SIGN];</code>
     * @return Whether the yenSignCharacter field is set.
     */
    @java.lang.Override
    public boolean hasYenSignCharacter() {
      return ((bitField0_ & 0x00200000) != 0);
    }
    /**
     * <pre>
     * Mac-original JIS key layout has "yen-sign" key which generates
     * U+00A5 instead of U+005C and sometimes users get troubles with
     * them because they expect backslashes which are rendered as
     * yen-sign.  If this configuration is BACKSLASH, Mozc will
     * interpret U+005C even when the original key event is U+00A5.
     * </pre>
     *
     * <code>optional .mozc.config.Config.YenSignCharacter yen_sign_character = 63 [default = YEN_SIGN];</code>
     * @return The yenSignCharacter.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter getYenSignCharacter() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter.forNumber(yenSignCharacter_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter.YEN_SIGN : result;
    }
    /**
     * <pre>
     * Mac-original JIS key layout has "yen-sign" key which generates
     * U+00A5 instead of U+005C and sometimes users get troubles with
     * them because they expect backslashes which are rendered as
     * yen-sign.  If this configuration is BACKSLASH, Mozc will
     * interpret U+005C even when the original key event is U+00A5.
     * </pre>
     *
     * <code>optional .mozc.config.Config.YenSignCharacter yen_sign_character = 63 [default = YEN_SIGN];</code>
     * @param value The yenSignCharacter to set.
     */
    private void setYenSignCharacter(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter value) {
      yenSignCharacter_ = value.getNumber();
      bitField0_ |= 0x00200000;
    }
    /**
     * <pre>
     * Mac-original JIS key layout has "yen-sign" key which generates
     * U+00A5 instead of U+005C and sometimes users get troubles with
     * them because they expect backslashes which are rendered as
     * yen-sign.  If this configuration is BACKSLASH, Mozc will
     * interpret U+005C even when the original key event is U+00A5.
     * </pre>
     *
     * <code>optional .mozc.config.Config.YenSignCharacter yen_sign_character = 63 [default = YEN_SIGN];</code>
     */
    private void clearYenSignCharacter() {
      bitField0_ = (bitField0_ & ~0x00200000);
      yenSignCharacter_ = 0;
    }

    public static final int USE_JAPANESE_LAYOUT_FIELD_NUMBER = 64;
    private boolean useJapaneseLayout_;
    /**
     * <pre>
     * Use Japanese keyboard layout even when the user uses other
     * keyboard layouts.  In Mac OSX people can use several keyboard
     * layouts such like French or Spanish but some people want to use
     * Japanese layout for Japanese.  See http://b/2917320
     * </pre>
     *
     * <code>optional bool use_japanese_layout = 64 [default = false];</code>
     * @return Whether the useJapaneseLayout field is set.
     */
    @java.lang.Override
    public boolean hasUseJapaneseLayout() {
      return ((bitField0_ & 0x00400000) != 0);
    }
    /**
     * <pre>
     * Use Japanese keyboard layout even when the user uses other
     * keyboard layouts.  In Mac OSX people can use several keyboard
     * layouts such like French or Spanish but some people want to use
     * Japanese layout for Japanese.  See http://b/2917320
     * </pre>
     *
     * <code>optional bool use_japanese_layout = 64 [default = false];</code>
     * @return The useJapaneseLayout.
     */
    @java.lang.Override
    public boolean getUseJapaneseLayout() {
      return useJapaneseLayout_;
    }
    /**
     * <pre>
     * Use Japanese keyboard layout even when the user uses other
     * keyboard layouts.  In Mac OSX people can use several keyboard
     * layouts such like French or Spanish but some people want to use
     * Japanese layout for Japanese.  See http://b/2917320
     * </pre>
     *
     * <code>optional bool use_japanese_layout = 64 [default = false];</code>
     * @param value The useJapaneseLayout to set.
     */
    private void setUseJapaneseLayout(boolean value) {
      bitField0_ |= 0x00400000;
      useJapaneseLayout_ = value;
    }
    /**
     * <pre>
     * Use Japanese keyboard layout even when the user uses other
     * keyboard layouts.  In Mac OSX people can use several keyboard
     * layouts such like French or Spanish but some people want to use
     * Japanese layout for Japanese.  See http://b/2917320
     * </pre>
     *
     * <code>optional bool use_japanese_layout = 64 [default = false];</code>
     */
    private void clearUseJapaneseLayout() {
      bitField0_ = (bitField0_ & ~0x00400000);
      useJapaneseLayout_ = false;
    }

    public static final int USE_KANA_MODIFIER_INSENSITIVE_CONVERSION_FIELD_NUMBER = 65;
    private boolean useKanaModifierInsensitiveConversion_;
    /**
     * <pre>
     * Use kana modifier insensitive conversion.
     * e.g.  -&gt; 
     * Note that Request message has the same field.
     * - Request's one is controlled by the client. A user cannot control it.
     *   On the other hand Config's is under a user's control.
     * - Whether the feature is activated or not is decided by logical-AND
     *   of Request's and Config's.
     * </pre>
     *
     * <code>optional bool use_kana_modifier_insensitive_conversion = 65 [default = false];</code>
     * @return Whether the useKanaModifierInsensitiveConversion field is set.
     */
    @java.lang.Override
    public boolean hasUseKanaModifierInsensitiveConversion() {
      return ((bitField0_ & 0x00800000) != 0);
    }
    /**
     * <pre>
     * Use kana modifier insensitive conversion.
     * e.g.  -&gt; 
     * Note that Request message has the same field.
     * - Request's one is controlled by the client. A user cannot control it.
     *   On the other hand Config's is under a user's control.
     * - Whether the feature is activated or not is decided by logical-AND
     *   of Request's and Config's.
     * </pre>
     *
     * <code>optional bool use_kana_modifier_insensitive_conversion = 65 [default = false];</code>
     * @return The useKanaModifierInsensitiveConversion.
     */
    @java.lang.Override
    public boolean getUseKanaModifierInsensitiveConversion() {
      return useKanaModifierInsensitiveConversion_;
    }
    /**
     * <pre>
     * Use kana modifier insensitive conversion.
     * e.g.  -&gt; 
     * Note that Request message has the same field.
     * - Request's one is controlled by the client. A user cannot control it.
     *   On the other hand Config's is under a user's control.
     * - Whether the feature is activated or not is decided by logical-AND
     *   of Request's and Config's.
     * </pre>
     *
     * <code>optional bool use_kana_modifier_insensitive_conversion = 65 [default = false];</code>
     * @param value The useKanaModifierInsensitiveConversion to set.
     */
    private void setUseKanaModifierInsensitiveConversion(boolean value) {
      bitField0_ |= 0x00800000;
      useKanaModifierInsensitiveConversion_ = value;
    }
    /**
     * <pre>
     * Use kana modifier insensitive conversion.
     * e.g.  -&gt; 
     * Note that Request message has the same field.
     * - Request's one is controlled by the client. A user cannot control it.
     *   On the other hand Config's is under a user's control.
     * - Whether the feature is activated or not is decided by logical-AND
     *   of Request's and Config's.
     * </pre>
     *
     * <code>optional bool use_kana_modifier_insensitive_conversion = 65 [default = false];</code>
     */
    private void clearUseKanaModifierInsensitiveConversion() {
      bitField0_ = (bitField0_ & ~0x00800000);
      useKanaModifierInsensitiveConversion_ = false;
    }

    public static final int USE_TYPING_CORRECTION_FIELD_NUMBER = 66;
    private boolean useTypingCorrection_;
    /**
     * <pre>
     * Use typing correction feature.
     * e.g. sunkai -&gt; 
     * </pre>
     *
     * <code>optional bool use_typing_correction = 66 [default = false];</code>
     * @return Whether the useTypingCorrection field is set.
     */
    @java.lang.Override
    public boolean hasUseTypingCorrection() {
      return ((bitField0_ & 0x01000000) != 0);
    }
    /**
     * <pre>
     * Use typing correction feature.
     * e.g. sunkai -&gt; 
     * </pre>
     *
     * <code>optional bool use_typing_correction = 66 [default = false];</code>
     * @return The useTypingCorrection.
     */
    @java.lang.Override
    public boolean getUseTypingCorrection() {
      return useTypingCorrection_;
    }
    /**
     * <pre>
     * Use typing correction feature.
     * e.g. sunkai -&gt; 
     * </pre>
     *
     * <code>optional bool use_typing_correction = 66 [default = false];</code>
     * @param value The useTypingCorrection to set.
     */
    private void setUseTypingCorrection(boolean value) {
      bitField0_ |= 0x01000000;
      useTypingCorrection_ = value;
    }
    /**
     * <pre>
     * Use typing correction feature.
     * e.g. sunkai -&gt; 
     * </pre>
     *
     * <code>optional bool use_typing_correction = 66 [default = false];</code>
     */
    private void clearUseTypingCorrection() {
      bitField0_ = (bitField0_ & ~0x01000000);
      useTypingCorrection_ = false;
    }

    public static final int COMPOSING_TIMEOUT_THRESHOLD_MSEC_FIELD_NUMBER = 67;
    private int composingTimeoutThresholdMsec_;
    /**
     * <pre>
     * The duration in millisecond to determine the timeout.
     * If the duration between key inputs is more than this value,
     * a SessionCommand::STOP_KEY_TOGGLING is prepended to the next key input.
     * If the value is 0, STOP_KEY_TOGGLING is not sent.
     * </pre>
     *
     * <code>optional int32 composing_timeout_threshold_msec = 67 [default = 0];</code>
     * @return Whether the composingTimeoutThresholdMsec field is set.
     */
    @java.lang.Override
    public boolean hasComposingTimeoutThresholdMsec() {
      return ((bitField0_ & 0x02000000) != 0);
    }
    /**
     * <pre>
     * The duration in millisecond to determine the timeout.
     * If the duration between key inputs is more than this value,
     * a SessionCommand::STOP_KEY_TOGGLING is prepended to the next key input.
     * If the value is 0, STOP_KEY_TOGGLING is not sent.
     * </pre>
     *
     * <code>optional int32 composing_timeout_threshold_msec = 67 [default = 0];</code>
     * @return The composingTimeoutThresholdMsec.
     */
    @java.lang.Override
    public int getComposingTimeoutThresholdMsec() {
      return composingTimeoutThresholdMsec_;
    }
    /**
     * <pre>
     * The duration in millisecond to determine the timeout.
     * If the duration between key inputs is more than this value,
     * a SessionCommand::STOP_KEY_TOGGLING is prepended to the next key input.
     * If the value is 0, STOP_KEY_TOGGLING is not sent.
     * </pre>
     *
     * <code>optional int32 composing_timeout_threshold_msec = 67 [default = 0];</code>
     * @param value The composingTimeoutThresholdMsec to set.
     */
    private void setComposingTimeoutThresholdMsec(int value) {
      bitField0_ |= 0x02000000;
      composingTimeoutThresholdMsec_ = value;
    }
    /**
     * <pre>
     * The duration in millisecond to determine the timeout.
     * If the duration between key inputs is more than this value,
     * a SessionCommand::STOP_KEY_TOGGLING is prepended to the next key input.
     * If the value is 0, STOP_KEY_TOGGLING is not sent.
     * </pre>
     *
     * <code>optional int32 composing_timeout_threshold_msec = 67 [default = 0];</code>
     */
    private void clearComposingTimeoutThresholdMsec() {
      bitField0_ = (bitField0_ & ~0x02000000);
      composingTimeoutThresholdMsec_ = 0;
    }

    public static final int OVERLAY_KEYMAPS_FIELD_NUMBER = 68;
    private com.google.protobuf.Internal.IntList overlayKeymaps_;
    private static final com.google.protobuf.Internal.ListAdapter.Converter<
        java.lang.Integer, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap> overlayKeymaps_converter_ =
            new com.google.protobuf.Internal.ListAdapter.Converter<
                java.lang.Integer, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap>() {
              @java.lang.Override
              public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap convert(java.lang.Integer from) {
                org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap.forNumber(from);
                return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap.NONE : result;
              }
            };
    /**
     * <pre>
     * The keymaps which are loaded on top of `session_keymap`.
     * Overlay keymaps are prioritized over `session_keymap`.
     * They are used to partially modify the session keymap, for example
     * using Henkan key as IME_ON.
     * </pre>
     *
     * <code>repeated .mozc.config.Config.SessionKeymap overlay_keymaps = 68 [packed = true];</code>
     * @return A list containing the overlayKeymaps.
     */
    @java.lang.Override
    public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap> getOverlayKeymapsList() {
      return new com.google.protobuf.Internal.ListAdapter<
          java.lang.Integer, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap>(overlayKeymaps_, overlayKeymaps_converter_);
    }
    /**
     * <pre>
     * The keymaps which are loaded on top of `session_keymap`.
     * Overlay keymaps are prioritized over `session_keymap`.
     * They are used to partially modify the session keymap, for example
     * using Henkan key as IME_ON.
     * </pre>
     *
     * <code>repeated .mozc.config.Config.SessionKeymap overlay_keymaps = 68 [packed = true];</code>
     * @return The count of overlayKeymaps.
     */
    @java.lang.Override
    public int getOverlayKeymapsCount() {
      return overlayKeymaps_.size();
    }
    /**
     * <pre>
     * The keymaps which are loaded on top of `session_keymap`.
     * Overlay keymaps are prioritized over `session_keymap`.
     * They are used to partially modify the session keymap, for example
     * using Henkan key as IME_ON.
     * </pre>
     *
     * <code>repeated .mozc.config.Config.SessionKeymap overlay_keymaps = 68 [packed = true];</code>
     * @param index The index of the element to return.
     * @return The overlayKeymaps at the given index.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap getOverlayKeymaps(int index) {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap.forNumber(overlayKeymaps_.getInt(index));
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap.NONE : result;
    }
    private int overlayKeymapsMemoizedSerializedSize;
    private void ensureOverlayKeymapsIsMutable() {
      com.google.protobuf.Internal.IntList tmp = overlayKeymaps_;
      if (!tmp.isModifiable()) {
        overlayKeymaps_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
      }
    }
    /**
     * <pre>
     * The keymaps which are loaded on top of `session_keymap`.
     * Overlay keymaps are prioritized over `session_keymap`.
     * They are used to partially modify the session keymap, for example
     * using Henkan key as IME_ON.
     * </pre>
     *
     * <code>repeated .mozc.config.Config.SessionKeymap overlay_keymaps = 68 [packed = true];</code>
     * @param index The index to set the value at.
     * @param value The overlayKeymaps to set.
     */
    private void setOverlayKeymaps(
        int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap value) {
      value.getClass();
  ensureOverlayKeymapsIsMutable();
      overlayKeymaps_.setInt(index, value.getNumber());
    }
    /**
     * <pre>
     * The keymaps which are loaded on top of `session_keymap`.
     * Overlay keymaps are prioritized over `session_keymap`.
     * They are used to partially modify the session keymap, for example
     * using Henkan key as IME_ON.
     * </pre>
     *
     * <code>repeated .mozc.config.Config.SessionKeymap overlay_keymaps = 68 [packed = true];</code>
     * @param value The overlayKeymaps to add.
     */
    private void addOverlayKeymaps(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap value) {
      value.getClass();
  ensureOverlayKeymapsIsMutable();
      overlayKeymaps_.addInt(value.getNumber());
    }
    /**
     * <pre>
     * The keymaps which are loaded on top of `session_keymap`.
     * Overlay keymaps are prioritized over `session_keymap`.
     * They are used to partially modify the session keymap, for example
     * using Henkan key as IME_ON.
     * </pre>
     *
     * <code>repeated .mozc.config.Config.SessionKeymap overlay_keymaps = 68 [packed = true];</code>
     * @param values The overlayKeymaps to add.
     */
    private void addAllOverlayKeymaps(
        java.lang.Iterable<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap> values) {
      ensureOverlayKeymapsIsMutable();
      for (org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap value : values) {
        overlayKeymaps_.addInt(value.getNumber());
      }
    }
    /**
     * <pre>
     * The keymaps which are loaded on top of `session_keymap`.
     * Overlay keymaps are prioritized over `session_keymap`.
     * They are used to partially modify the session keymap, for example
     * using Henkan key as IME_ON.
     * </pre>
     *
     * <code>repeated .mozc.config.Config.SessionKeymap overlay_keymaps = 68 [packed = true];</code>
     */
    private void clearOverlayKeymaps() {
      overlayKeymaps_ = emptyIntList();
    }

    public static final int USE_DATE_CONVERSION_FIELD_NUMBER = 80;
    private boolean useDateConversion_;
    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Dictionary (80-99)
     * </pre>
     *
     * <code>optional bool use_date_conversion = 80 [default = true];</code>
     * @return Whether the useDateConversion field is set.
     */
    @java.lang.Override
    public boolean hasUseDateConversion() {
      return ((bitField0_ & 0x04000000) != 0);
    }
    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Dictionary (80-99)
     * </pre>
     *
     * <code>optional bool use_date_conversion = 80 [default = true];</code>
     * @return The useDateConversion.
     */
    @java.lang.Override
    public boolean getUseDateConversion() {
      return useDateConversion_;
    }
    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Dictionary (80-99)
     * </pre>
     *
     * <code>optional bool use_date_conversion = 80 [default = true];</code>
     * @param value The useDateConversion to set.
     */
    private void setUseDateConversion(boolean value) {
      bitField0_ |= 0x04000000;
      useDateConversion_ = value;
    }
    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Dictionary (80-99)
     * </pre>
     *
     * <code>optional bool use_date_conversion = 80 [default = true];</code>
     */
    private void clearUseDateConversion() {
      bitField0_ = (bitField0_ & ~0x04000000);
      useDateConversion_ = true;
    }

    public static final int USE_SINGLE_KANJI_CONVERSION_FIELD_NUMBER = 81;
    private boolean useSingleKanjiConversion_;
    /**
     * <code>optional bool use_single_kanji_conversion = 81 [default = true];</code>
     * @return Whether the useSingleKanjiConversion field is set.
     */
    @java.lang.Override
    public boolean hasUseSingleKanjiConversion() {
      return ((bitField0_ & 0x08000000) != 0);
    }
    /**
     * <code>optional bool use_single_kanji_conversion = 81 [default = true];</code>
     * @return The useSingleKanjiConversion.
     */
    @java.lang.Override
    public boolean getUseSingleKanjiConversion() {
      return useSingleKanjiConversion_;
    }
    /**
     * <code>optional bool use_single_kanji_conversion = 81 [default = true];</code>
     * @param value The useSingleKanjiConversion to set.
     */
    private void setUseSingleKanjiConversion(boolean value) {
      bitField0_ |= 0x08000000;
      useSingleKanjiConversion_ = value;
    }
    /**
     * <code>optional bool use_single_kanji_conversion = 81 [default = true];</code>
     */
    private void clearUseSingleKanjiConversion() {
      bitField0_ = (bitField0_ & ~0x08000000);
      useSingleKanjiConversion_ = true;
    }

    public static final int USE_SYMBOL_CONVERSION_FIELD_NUMBER = 82;
    private boolean useSymbolConversion_;
    /**
     * <code>optional bool use_symbol_conversion = 82 [default = true];</code>
     * @return Whether the useSymbolConversion field is set.
     */
    @java.lang.Override
    public boolean hasUseSymbolConversion() {
      return ((bitField0_ & 0x10000000) != 0);
    }
    /**
     * <code>optional bool use_symbol_conversion = 82 [default = true];</code>
     * @return The useSymbolConversion.
     */
    @java.lang.Override
    public boolean getUseSymbolConversion() {
      return useSymbolConversion_;
    }
    /**
     * <code>optional bool use_symbol_conversion = 82 [default = true];</code>
     * @param value The useSymbolConversion to set.
     */
    private void setUseSymbolConversion(boolean value) {
      bitField0_ |= 0x10000000;
      useSymbolConversion_ = value;
    }
    /**
     * <code>optional bool use_symbol_conversion = 82 [default = true];</code>
     */
    private void clearUseSymbolConversion() {
      bitField0_ = (bitField0_ & ~0x10000000);
      useSymbolConversion_ = true;
    }

    public static final int USE_NUMBER_CONVERSION_FIELD_NUMBER = 83;
    private boolean useNumberConversion_;
    /**
     * <code>optional bool use_number_conversion = 83 [default = true];</code>
     * @return Whether the useNumberConversion field is set.
     */
    @java.lang.Override
    public boolean hasUseNumberConversion() {
      return ((bitField0_ & 0x20000000) != 0);
    }
    /**
     * <code>optional bool use_number_conversion = 83 [default = true];</code>
     * @return The useNumberConversion.
     */
    @java.lang.Override
    public boolean getUseNumberConversion() {
      return useNumberConversion_;
    }
    /**
     * <code>optional bool use_number_conversion = 83 [default = true];</code>
     * @param value The useNumberConversion to set.
     */
    private void setUseNumberConversion(boolean value) {
      bitField0_ |= 0x20000000;
      useNumberConversion_ = value;
    }
    /**
     * <code>optional bool use_number_conversion = 83 [default = true];</code>
     */
    private void clearUseNumberConversion() {
      bitField0_ = (bitField0_ & ~0x20000000);
      useNumberConversion_ = true;
    }

    public static final int USE_EMOTICON_CONVERSION_FIELD_NUMBER = 84;
    private boolean useEmoticonConversion_;
    /**
     * <code>optional bool use_emoticon_conversion = 84 [default = true];</code>
     * @return Whether the useEmoticonConversion field is set.
     */
    @java.lang.Override
    public boolean hasUseEmoticonConversion() {
      return ((bitField0_ & 0x40000000) != 0);
    }
    /**
     * <code>optional bool use_emoticon_conversion = 84 [default = true];</code>
     * @return The useEmoticonConversion.
     */
    @java.lang.Override
    public boolean getUseEmoticonConversion() {
      return useEmoticonConversion_;
    }
    /**
     * <code>optional bool use_emoticon_conversion = 84 [default = true];</code>
     * @param value The useEmoticonConversion to set.
     */
    private void setUseEmoticonConversion(boolean value) {
      bitField0_ |= 0x40000000;
      useEmoticonConversion_ = value;
    }
    /**
     * <code>optional bool use_emoticon_conversion = 84 [default = true];</code>
     */
    private void clearUseEmoticonConversion() {
      bitField0_ = (bitField0_ & ~0x40000000);
      useEmoticonConversion_ = true;
    }

    public static final int USE_CALCULATOR_FIELD_NUMBER = 85;
    private boolean useCalculator_;
    /**
     * <code>optional bool use_calculator = 85 [default = true];</code>
     * @return Whether the useCalculator field is set.
     */
    @java.lang.Override
    public boolean hasUseCalculator() {
      return ((bitField0_ & 0x80000000) != 0);
    }
    /**
     * <code>optional bool use_calculator = 85 [default = true];</code>
     * @return The useCalculator.
     */
    @java.lang.Override
    public boolean getUseCalculator() {
      return useCalculator_;
    }
    /**
     * <code>optional bool use_calculator = 85 [default = true];</code>
     * @param value The useCalculator to set.
     */
    private void setUseCalculator(boolean value) {
      bitField0_ |= 0x80000000;
      useCalculator_ = value;
    }
    /**
     * <code>optional bool use_calculator = 85 [default = true];</code>
     */
    private void clearUseCalculator() {
      bitField0_ = (bitField0_ & ~0x80000000);
      useCalculator_ = true;
    }

    public static final int USE_T13N_CONVERSION_FIELD_NUMBER = 86;
    private boolean useT13NConversion_;
    /**
     * <code>optional bool use_t13n_conversion = 86 [default = true];</code>
     * @return Whether the useT13nConversion field is set.
     */
    @java.lang.Override
    public boolean hasUseT13NConversion() {
      return ((bitField1_ & 0x00000001) != 0);
    }
    /**
     * <code>optional bool use_t13n_conversion = 86 [default = true];</code>
     * @return The useT13nConversion.
     */
    @java.lang.Override
    public boolean getUseT13NConversion() {
      return useT13NConversion_;
    }
    /**
     * <code>optional bool use_t13n_conversion = 86 [default = true];</code>
     * @param value The useT13nConversion to set.
     */
    private void setUseT13NConversion(boolean value) {
      bitField1_ |= 0x00000001;
      useT13NConversion_ = value;
    }
    /**
     * <code>optional bool use_t13n_conversion = 86 [default = true];</code>
     */
    private void clearUseT13NConversion() {
      bitField1_ = (bitField1_ & ~0x00000001);
      useT13NConversion_ = true;
    }

    public static final int USE_ZIP_CODE_CONVERSION_FIELD_NUMBER = 87;
    private boolean useZipCodeConversion_;
    /**
     * <code>optional bool use_zip_code_conversion = 87 [default = true];</code>
     * @return Whether the useZipCodeConversion field is set.
     */
    @java.lang.Override
    public boolean hasUseZipCodeConversion() {
      return ((bitField1_ & 0x00000002) != 0);
    }
    /**
     * <code>optional bool use_zip_code_conversion = 87 [default = true];</code>
     * @return The useZipCodeConversion.
     */
    @java.lang.Override
    public boolean getUseZipCodeConversion() {
      return useZipCodeConversion_;
    }
    /**
     * <code>optional bool use_zip_code_conversion = 87 [default = true];</code>
     * @param value The useZipCodeConversion to set.
     */
    private void setUseZipCodeConversion(boolean value) {
      bitField1_ |= 0x00000002;
      useZipCodeConversion_ = value;
    }
    /**
     * <code>optional bool use_zip_code_conversion = 87 [default = true];</code>
     */
    private void clearUseZipCodeConversion() {
      bitField1_ = (bitField1_ & ~0x00000002);
      useZipCodeConversion_ = true;
    }

    public static final int USE_SPELLING_CORRECTION_FIELD_NUMBER = 88;
    private boolean useSpellingCorrection_;
    /**
     * <code>optional bool use_spelling_correction = 88 [default = true];</code>
     * @return Whether the useSpellingCorrection field is set.
     */
    @java.lang.Override
    public boolean hasUseSpellingCorrection() {
      return ((bitField1_ & 0x00000004) != 0);
    }
    /**
     * <code>optional bool use_spelling_correction = 88 [default = true];</code>
     * @return The useSpellingCorrection.
     */
    @java.lang.Override
    public boolean getUseSpellingCorrection() {
      return useSpellingCorrection_;
    }
    /**
     * <code>optional bool use_spelling_correction = 88 [default = true];</code>
     * @param value The useSpellingCorrection to set.
     */
    private void setUseSpellingCorrection(boolean value) {
      bitField1_ |= 0x00000004;
      useSpellingCorrection_ = value;
    }
    /**
     * <code>optional bool use_spelling_correction = 88 [default = true];</code>
     */
    private void clearUseSpellingCorrection() {
      bitField1_ = (bitField1_ & ~0x00000004);
      useSpellingCorrection_ = true;
    }

    public static final int USE_EMOJI_CONVERSION_FIELD_NUMBER = 89;
    private boolean useEmojiConversion_;
    /**
     * <pre>
     * If use_emoji_conversion is true, the user can input emoji characters
     * by converting from a query string (e.g. "  " [U+1F436]).
     * Even if it is false, users might be able to input emoji characters
     * with other ways.
     * Note: Some characters can be either of text and emoji.  It would be ideal
     * to use the variation sequence to specify emoji presentation [U+FE0E],
     * although it is not implemented yet.
     * See: http://unicode.org/reports/tr51/#Presentation_Style
     * </pre>
     *
     * <code>optional bool use_emoji_conversion = 89 [default = false];</code>
     * @return Whether the useEmojiConversion field is set.
     */
    @java.lang.Override
    public boolean hasUseEmojiConversion() {
      return ((bitField1_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * If use_emoji_conversion is true, the user can input emoji characters
     * by converting from a query string (e.g. "  " [U+1F436]).
     * Even if it is false, users might be able to input emoji characters
     * with other ways.
     * Note: Some characters can be either of text and emoji.  It would be ideal
     * to use the variation sequence to specify emoji presentation [U+FE0E],
     * although it is not implemented yet.
     * See: http://unicode.org/reports/tr51/#Presentation_Style
     * </pre>
     *
     * <code>optional bool use_emoji_conversion = 89 [default = false];</code>
     * @return The useEmojiConversion.
     */
    @java.lang.Override
    public boolean getUseEmojiConversion() {
      return useEmojiConversion_;
    }
    /**
     * <pre>
     * If use_emoji_conversion is true, the user can input emoji characters
     * by converting from a query string (e.g. "  " [U+1F436]).
     * Even if it is false, users might be able to input emoji characters
     * with other ways.
     * Note: Some characters can be either of text and emoji.  It would be ideal
     * to use the variation sequence to specify emoji presentation [U+FE0E],
     * although it is not implemented yet.
     * See: http://unicode.org/reports/tr51/#Presentation_Style
     * </pre>
     *
     * <code>optional bool use_emoji_conversion = 89 [default = false];</code>
     * @param value The useEmojiConversion to set.
     */
    private void setUseEmojiConversion(boolean value) {
      bitField1_ |= 0x00000008;
      useEmojiConversion_ = value;
    }
    /**
     * <pre>
     * If use_emoji_conversion is true, the user can input emoji characters
     * by converting from a query string (e.g. "  " [U+1F436]).
     * Even if it is false, users might be able to input emoji characters
     * with other ways.
     * Note: Some characters can be either of text and emoji.  It would be ideal
     * to use the variation sequence to specify emoji presentation [U+FE0E],
     * although it is not implemented yet.
     * See: http://unicode.org/reports/tr51/#Presentation_Style
     * </pre>
     *
     * <code>optional bool use_emoji_conversion = 89 [default = false];</code>
     */
    private void clearUseEmojiConversion() {
      bitField1_ = (bitField1_ & ~0x00000008);
      useEmojiConversion_ = false;
    }

    public static final int INFORMATION_LIST_CONFIG_FIELD_NUMBER = 90;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig informationListConfig_;
    /**
     * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
     */
    @java.lang.Override
    public boolean hasInformationListConfig() {
      return ((bitField1_ & 0x00000010) != 0);
    }
    /**
     * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig getInformationListConfig() {
      return informationListConfig_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.getDefaultInstance() : informationListConfig_;
    }
    /**
     * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
     */
    private void setInformationListConfig(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig value) {
      value.getClass();
  informationListConfig_ = value;
      bitField1_ |= 0x00000010;
      }
    /**
     * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeInformationListConfig(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig value) {
      value.getClass();
  if (informationListConfig_ != null &&
          informationListConfig_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.getDefaultInstance()) {
        informationListConfig_ =
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.newBuilder(informationListConfig_).mergeFrom(value).buildPartial();
      } else {
        informationListConfig_ = value;
      }
      bitField1_ |= 0x00000010;
    }
    /**
     * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
     */
    private void clearInformationListConfig() {  informationListConfig_ = null;
      bitField1_ = (bitField1_ & ~0x00000010);
    }

    public static final int USE_HISTORY_SUGGEST_FIELD_NUMBER = 100;
    private boolean useHistorySuggest_;
    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Suggest (100-119)
     * Suggest is a feature of word suggestion with prefix search.
     * When you type "", you may get "", "" (), "" ()
     * as suggested words.
     * Use history-based suggest feature.
     * If this is true, your previously typed words are prioritized.
     * </pre>
     *
     * <code>optional bool use_history_suggest = 100 [default = true];</code>
     * @return Whether the useHistorySuggest field is set.
     */
    @java.lang.Override
    public boolean hasUseHistorySuggest() {
      return ((bitField1_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Suggest (100-119)
     * Suggest is a feature of word suggestion with prefix search.
     * When you type "", you may get "", "" (), "" ()
     * as suggested words.
     * Use history-based suggest feature.
     * If this is true, your previously typed words are prioritized.
     * </pre>
     *
     * <code>optional bool use_history_suggest = 100 [default = true];</code>
     * @return The useHistorySuggest.
     */
    @java.lang.Override
    public boolean getUseHistorySuggest() {
      return useHistorySuggest_;
    }
    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Suggest (100-119)
     * Suggest is a feature of word suggestion with prefix search.
     * When you type "", you may get "", "" (), "" ()
     * as suggested words.
     * Use history-based suggest feature.
     * If this is true, your previously typed words are prioritized.
     * </pre>
     *
     * <code>optional bool use_history_suggest = 100 [default = true];</code>
     * @param value The useHistorySuggest to set.
     */
    private void setUseHistorySuggest(boolean value) {
      bitField1_ |= 0x00000020;
      useHistorySuggest_ = value;
    }
    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Suggest (100-119)
     * Suggest is a feature of word suggestion with prefix search.
     * When you type "", you may get "", "" (), "" ()
     * as suggested words.
     * Use history-based suggest feature.
     * If this is true, your previously typed words are prioritized.
     * </pre>
     *
     * <code>optional bool use_history_suggest = 100 [default = true];</code>
     */
    private void clearUseHistorySuggest() {
      bitField1_ = (bitField1_ & ~0x00000020);
      useHistorySuggest_ = true;
    }

    public static final int USE_DICTIONARY_SUGGEST_FIELD_NUMBER = 101;
    private boolean useDictionarySuggest_;
    /**
     * <pre>
     * Use dictionary-based suggest feature.
     * If this is true, words in the word dictionary are suggested even if
     * you haven't typed before.
     * </pre>
     *
     * <code>optional bool use_dictionary_suggest = 101 [default = true];</code>
     * @return Whether the useDictionarySuggest field is set.
     */
    @java.lang.Override
    public boolean hasUseDictionarySuggest() {
      return ((bitField1_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * Use dictionary-based suggest feature.
     * If this is true, words in the word dictionary are suggested even if
     * you haven't typed before.
     * </pre>
     *
     * <code>optional bool use_dictionary_suggest = 101 [default = true];</code>
     * @return The useDictionarySuggest.
     */
    @java.lang.Override
    public boolean getUseDictionarySuggest() {
      return useDictionarySuggest_;
    }
    /**
     * <pre>
     * Use dictionary-based suggest feature.
     * If this is true, words in the word dictionary are suggested even if
     * you haven't typed before.
     * </pre>
     *
     * <code>optional bool use_dictionary_suggest = 101 [default = true];</code>
     * @param value The useDictionarySuggest to set.
     */
    private void setUseDictionarySuggest(boolean value) {
      bitField1_ |= 0x00000040;
      useDictionarySuggest_ = value;
    }
    /**
     * <pre>
     * Use dictionary-based suggest feature.
     * If this is true, words in the word dictionary are suggested even if
     * you haven't typed before.
     * </pre>
     *
     * <code>optional bool use_dictionary_suggest = 101 [default = true];</code>
     */
    private void clearUseDictionarySuggest() {
      bitField1_ = (bitField1_ & ~0x00000040);
      useDictionarySuggest_ = true;
    }

    public static final int USE_REALTIME_CONVERSION_FIELD_NUMBER = 102;
    private boolean useRealtimeConversion_;
    /**
     * <pre>
     * Use realtime conversion feature.
     * </pre>
     *
     * <code>optional bool use_realtime_conversion = 102 [default = true];</code>
     * @return Whether the useRealtimeConversion field is set.
     */
    @java.lang.Override
    public boolean hasUseRealtimeConversion() {
      return ((bitField1_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * Use realtime conversion feature.
     * </pre>
     *
     * <code>optional bool use_realtime_conversion = 102 [default = true];</code>
     * @return The useRealtimeConversion.
     */
    @java.lang.Override
    public boolean getUseRealtimeConversion() {
      return useRealtimeConversion_;
    }
    /**
     * <pre>
     * Use realtime conversion feature.
     * </pre>
     *
     * <code>optional bool use_realtime_conversion = 102 [default = true];</code>
     * @param value The useRealtimeConversion to set.
     */
    private void setUseRealtimeConversion(boolean value) {
      bitField1_ |= 0x00000080;
      useRealtimeConversion_ = value;
    }
    /**
     * <pre>
     * Use realtime conversion feature.
     * </pre>
     *
     * <code>optional bool use_realtime_conversion = 102 [default = true];</code>
     */
    private void clearUseRealtimeConversion() {
      bitField1_ = (bitField1_ & ~0x00000080);
      useRealtimeConversion_ = true;
    }

    public static final int SUGGESTIONS_SIZE_FIELD_NUMBER = 110;
    private int suggestionsSize_;
    /**
     * <pre>
     * Size of suggestions.
     * </pre>
     *
     * <code>optional uint32 suggestions_size = 110 [default = 3];</code>
     * @return Whether the suggestionsSize field is set.
     */
    @java.lang.Override
    public boolean hasSuggestionsSize() {
      return ((bitField1_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * Size of suggestions.
     * </pre>
     *
     * <code>optional uint32 suggestions_size = 110 [default = 3];</code>
     * @return The suggestionsSize.
     */
    @java.lang.Override
    public int getSuggestionsSize() {
      return suggestionsSize_;
    }
    /**
     * <pre>
     * Size of suggestions.
     * </pre>
     *
     * <code>optional uint32 suggestions_size = 110 [default = 3];</code>
     * @param value The suggestionsSize to set.
     */
    private void setSuggestionsSize(int value) {
      bitField1_ |= 0x00000100;
      suggestionsSize_ = value;
    }
    /**
     * <pre>
     * Size of suggestions.
     * </pre>
     *
     * <code>optional uint32 suggestions_size = 110 [default = 3];</code>
     */
    private void clearSuggestionsSize() {
      bitField1_ = (bitField1_ & ~0x00000100);
      suggestionsSize_ = 3;
    }

    public static final int USE_MODE_INDICATOR_FIELD_NUMBER = 120;
    private boolean useModeIndicator_;
    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Renderer (120-139)
     * Use mode indicator feature.
     * </pre>
     *
     * <code>optional bool use_mode_indicator = 120 [default = true];</code>
     * @return Whether the useModeIndicator field is set.
     */
    @java.lang.Override
    public boolean hasUseModeIndicator() {
      return ((bitField1_ & 0x00000200) != 0);
    }
    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Renderer (120-139)
     * Use mode indicator feature.
     * </pre>
     *
     * <code>optional bool use_mode_indicator = 120 [default = true];</code>
     * @return The useModeIndicator.
     */
    @java.lang.Override
    public boolean getUseModeIndicator() {
      return useModeIndicator_;
    }
    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Renderer (120-139)
     * Use mode indicator feature.
     * </pre>
     *
     * <code>optional bool use_mode_indicator = 120 [default = true];</code>
     * @param value The useModeIndicator to set.
     */
    private void setUseModeIndicator(boolean value) {
      bitField1_ |= 0x00000200;
      useModeIndicator_ = value;
    }
    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Renderer (120-139)
     * Use mode indicator feature.
     * </pre>
     *
     * <code>optional bool use_mode_indicator = 120 [default = true];</code>
     */
    private void clearUseModeIndicator() {
      bitField1_ = (bitField1_ & ~0x00000200);
      useModeIndicator_ = true;
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code mozc.config.Config}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config, Builder> implements
        // @@protoc_insertion_point(builder_implements:mozc.config.Config)
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.ConfigOrBuilder {
      // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * General config and logging/debugging:
       * We won't use 2-9 and 20-39 ids anymore for historical reasons.
       * </pre>
       *
       * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
       */
      @java.lang.Override
      public boolean hasGeneralConfig() {
        return instance.hasGeneralConfig();
      }
      /**
       * <pre>
       * General config and logging/debugging:
       * We won't use 2-9 and 20-39 ids anymore for historical reasons.
       * </pre>
       *
       * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig getGeneralConfig() {
        return instance.getGeneralConfig();
      }
      /**
       * <pre>
       * General config and logging/debugging:
       * We won't use 2-9 and 20-39 ids anymore for historical reasons.
       * </pre>
       *
       * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
       */
      public Builder setGeneralConfig(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig value) {
        copyOnWrite();
        instance.setGeneralConfig(value);
        return this;
        }
      /**
       * <pre>
       * General config and logging/debugging:
       * We won't use 2-9 and 20-39 ids anymore for historical reasons.
       * </pre>
       *
       * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
       */
      public Builder setGeneralConfig(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.Builder builderForValue) {
        copyOnWrite();
        instance.setGeneralConfig(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * General config and logging/debugging:
       * We won't use 2-9 and 20-39 ids anymore for historical reasons.
       * </pre>
       *
       * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
       */
      public Builder mergeGeneralConfig(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig value) {
        copyOnWrite();
        instance.mergeGeneralConfig(value);
        return this;
      }
      /**
       * <pre>
       * General config and logging/debugging:
       * We won't use 2-9 and 20-39 ids anymore for historical reasons.
       * </pre>
       *
       * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
       */
      public Builder clearGeneralConfig() {  copyOnWrite();
        instance.clearGeneralConfig();
        return this;
      }

      /**
       * <pre>
       * set verbose level of logging library (FLAGS_v)
       * </pre>
       *
       * <code>optional int32 verbose_level = 10 [default = 0];</code>
       * @return Whether the verboseLevel field is set.
       */
      @java.lang.Override
      public boolean hasVerboseLevel() {
        return instance.hasVerboseLevel();
      }
      /**
       * <pre>
       * set verbose level of logging library (FLAGS_v)
       * </pre>
       *
       * <code>optional int32 verbose_level = 10 [default = 0];</code>
       * @return The verboseLevel.
       */
      @java.lang.Override
      public int getVerboseLevel() {
        return instance.getVerboseLevel();
      }
      /**
       * <pre>
       * set verbose level of logging library (FLAGS_v)
       * </pre>
       *
       * <code>optional int32 verbose_level = 10 [default = 0];</code>
       * @param value The verboseLevel to set.
       * @return This builder for chaining.
       */
      public Builder setVerboseLevel(int value) {
        copyOnWrite();
        instance.setVerboseLevel(value);
        return this;
      }
      /**
       * <pre>
       * set verbose level of logging library (FLAGS_v)
       * </pre>
       *
       * <code>optional int32 verbose_level = 10 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearVerboseLevel() {
        copyOnWrite();
        instance.clearVerboseLevel();
        return this;
      }

      /**
       * <pre>
       * Incognito mode:
       * Disable all mutable operation if incognito_mode is true
       * Clients needs to check ConversionRequest::incognito_mode() instead
       * of Config::incognito_mode(), as the incoginto mode can also set
       * via Options.
       * </pre>
       *
       * <code>optional bool incognito_mode = 20 [default = false];</code>
       * @return Whether the incognitoMode field is set.
       */
      @java.lang.Override
      public boolean hasIncognitoMode() {
        return instance.hasIncognitoMode();
      }
      /**
       * <pre>
       * Incognito mode:
       * Disable all mutable operation if incognito_mode is true
       * Clients needs to check ConversionRequest::incognito_mode() instead
       * of Config::incognito_mode(), as the incoginto mode can also set
       * via Options.
       * </pre>
       *
       * <code>optional bool incognito_mode = 20 [default = false];</code>
       * @return The incognitoMode.
       */
      @java.lang.Override
      public boolean getIncognitoMode() {
        return instance.getIncognitoMode();
      }
      /**
       * <pre>
       * Incognito mode:
       * Disable all mutable operation if incognito_mode is true
       * Clients needs to check ConversionRequest::incognito_mode() instead
       * of Config::incognito_mode(), as the incoginto mode can also set
       * via Options.
       * </pre>
       *
       * <code>optional bool incognito_mode = 20 [default = false];</code>
       * @param value The incognitoMode to set.
       * @return This builder for chaining.
       */
      public Builder setIncognitoMode(boolean value) {
        copyOnWrite();
        instance.setIncognitoMode(value);
        return this;
      }
      /**
       * <pre>
       * Incognito mode:
       * Disable all mutable operation if incognito_mode is true
       * Clients needs to check ConversionRequest::incognito_mode() instead
       * of Config::incognito_mode(), as the incoginto mode can also set
       * via Options.
       * </pre>
       *
       * <code>optional bool incognito_mode = 20 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearIncognitoMode() {
        copyOnWrite();
        instance.clearIncognitoMode();
        return this;
      }

      /**
       * <pre>
       * whether to show the set default dialog on startup
       * </pre>
       *
       * <code>optional bool check_default = 22 [default = true];</code>
       * @return Whether the checkDefault field is set.
       */
      @java.lang.Override
      public boolean hasCheckDefault() {
        return instance.hasCheckDefault();
      }
      /**
       * <pre>
       * whether to show the set default dialog on startup
       * </pre>
       *
       * <code>optional bool check_default = 22 [default = true];</code>
       * @return The checkDefault.
       */
      @java.lang.Override
      public boolean getCheckDefault() {
        return instance.getCheckDefault();
      }
      /**
       * <pre>
       * whether to show the set default dialog on startup
       * </pre>
       *
       * <code>optional bool check_default = 22 [default = true];</code>
       * @param value The checkDefault to set.
       * @return This builder for chaining.
       */
      public Builder setCheckDefault(boolean value) {
        copyOnWrite();
        instance.setCheckDefault(value);
        return this;
      }
      /**
       * <pre>
       * whether to show the set default dialog on startup
       * </pre>
       *
       * <code>optional bool check_default = 22 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearCheckDefault() {
        copyOnWrite();
        instance.clearCheckDefault();
        return this;
      }

      /**
       * <pre>
       * Presentation mode:
       * disable all suggestion temporally.
       * </pre>
       *
       * <code>optional bool presentation_mode = 23 [default = false];</code>
       * @return Whether the presentationMode field is set.
       */
      @java.lang.Override
      public boolean hasPresentationMode() {
        return instance.hasPresentationMode();
      }
      /**
       * <pre>
       * Presentation mode:
       * disable all suggestion temporally.
       * </pre>
       *
       * <code>optional bool presentation_mode = 23 [default = false];</code>
       * @return The presentationMode.
       */
      @java.lang.Override
      public boolean getPresentationMode() {
        return instance.getPresentationMode();
      }
      /**
       * <pre>
       * Presentation mode:
       * disable all suggestion temporally.
       * </pre>
       *
       * <code>optional bool presentation_mode = 23 [default = false];</code>
       * @param value The presentationMode to set.
       * @return This builder for chaining.
       */
      public Builder setPresentationMode(boolean value) {
        copyOnWrite();
        instance.setPresentationMode(value);
        return this;
      }
      /**
       * <pre>
       * Presentation mode:
       * disable all suggestion temporally.
       * </pre>
       *
       * <code>optional bool presentation_mode = 23 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearPresentationMode() {
        copyOnWrite();
        instance.clearPresentationMode();
        return this;
      }

      /**
       * <pre>
       * Roman/Kana
       * </pre>
       *
       * <code>optional .mozc.config.Config.PreeditMethod preedit_method = 40 [default = ROMAN];</code>
       * @return Whether the preeditMethod field is set.
       */
      @java.lang.Override
      public boolean hasPreeditMethod() {
        return instance.hasPreeditMethod();
      }
      /**
       * <pre>
       * Roman/Kana
       * </pre>
       *
       * <code>optional .mozc.config.Config.PreeditMethod preedit_method = 40 [default = ROMAN];</code>
       * @return The preeditMethod.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod getPreeditMethod() {
        return instance.getPreeditMethod();
      }
      /**
       * <pre>
       * Roman/Kana
       * </pre>
       *
       * <code>optional .mozc.config.Config.PreeditMethod preedit_method = 40 [default = ROMAN];</code>
       * @param value The enum numeric value on the wire for preeditMethod to set.
       * @return This builder for chaining.
       */
      public Builder setPreeditMethod(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod value) {
        copyOnWrite();
        instance.setPreeditMethod(value);
        return this;
      }
      /**
       * <pre>
       * Roman/Kana
       * </pre>
       *
       * <code>optional .mozc.config.Config.PreeditMethod preedit_method = 40 [default = ROMAN];</code>
       * @return This builder for chaining.
       */
      public Builder clearPreeditMethod() {
        copyOnWrite();
        instance.clearPreeditMethod();
        return this;
      }

      /**
       * <code>optional .mozc.config.Config.SessionKeymap session_keymap = 41 [default = NONE];</code>
       * @return Whether the sessionKeymap field is set.
       */
      @java.lang.Override
      public boolean hasSessionKeymap() {
        return instance.hasSessionKeymap();
      }
      /**
       * <code>optional .mozc.config.Config.SessionKeymap session_keymap = 41 [default = NONE];</code>
       * @return The sessionKeymap.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap getSessionKeymap() {
        return instance.getSessionKeymap();
      }
      /**
       * <code>optional .mozc.config.Config.SessionKeymap session_keymap = 41 [default = NONE];</code>
       * @param value The enum numeric value on the wire for sessionKeymap to set.
       * @return This builder for chaining.
       */
      public Builder setSessionKeymap(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap value) {
        copyOnWrite();
        instance.setSessionKeymap(value);
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.SessionKeymap session_keymap = 41 [default = NONE];</code>
       * @return This builder for chaining.
       */
      public Builder clearSessionKeymap() {
        copyOnWrite();
        instance.clearSessionKeymap();
        return this;
      }

      /**
       * <pre>
       * custom keymap
       * TODO(taku): replace it with repeated field
       * </pre>
       *
       * <code>optional bytes custom_keymap_table = 42;</code>
       * @return Whether the customKeymapTable field is set.
       */
      @java.lang.Override
      public boolean hasCustomKeymapTable() {
        return instance.hasCustomKeymapTable();
      }
      /**
       * <pre>
       * custom keymap
       * TODO(taku): replace it with repeated field
       * </pre>
       *
       * <code>optional bytes custom_keymap_table = 42;</code>
       * @return The customKeymapTable.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getCustomKeymapTable() {
        return instance.getCustomKeymapTable();
      }
      /**
       * <pre>
       * custom keymap
       * TODO(taku): replace it with repeated field
       * </pre>
       *
       * <code>optional bytes custom_keymap_table = 42;</code>
       * @param value The customKeymapTable to set.
       * @return This builder for chaining.
       */
      public Builder setCustomKeymapTable(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setCustomKeymapTable(value);
        return this;
      }
      /**
       * <pre>
       * custom keymap
       * TODO(taku): replace it with repeated field
       * </pre>
       *
       * <code>optional bytes custom_keymap_table = 42;</code>
       * @return This builder for chaining.
       */
      public Builder clearCustomKeymapTable() {
        copyOnWrite();
        instance.clearCustomKeymapTable();
        return this;
      }

      /**
       * <pre>
       * custom roman table
       * </pre>
       *
       * <code>optional bytes custom_roman_table = 43;</code>
       * @return Whether the customRomanTable field is set.
       */
      @java.lang.Override
      public boolean hasCustomRomanTable() {
        return instance.hasCustomRomanTable();
      }
      /**
       * <pre>
       * custom roman table
       * </pre>
       *
       * <code>optional bytes custom_roman_table = 43;</code>
       * @return The customRomanTable.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getCustomRomanTable() {
        return instance.getCustomRomanTable();
      }
      /**
       * <pre>
       * custom roman table
       * </pre>
       *
       * <code>optional bytes custom_roman_table = 43;</code>
       * @param value The customRomanTable to set.
       * @return This builder for chaining.
       */
      public Builder setCustomRomanTable(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setCustomRomanTable(value);
        return this;
      }
      /**
       * <pre>
       * custom roman table
       * </pre>
       *
       * <code>optional bytes custom_roman_table = 43;</code>
       * @return This builder for chaining.
       */
      public Builder clearCustomRomanTable() {
        copyOnWrite();
        instance.clearCustomRomanTable();
        return this;
      }

      /**
       * <code>optional .mozc.config.Config.PunctuationMethod punctuation_method = 45 [default = TOUTEN_KUTEN];</code>
       * @return Whether the punctuationMethod field is set.
       */
      @java.lang.Override
      public boolean hasPunctuationMethod() {
        return instance.hasPunctuationMethod();
      }
      /**
       * <code>optional .mozc.config.Config.PunctuationMethod punctuation_method = 45 [default = TOUTEN_KUTEN];</code>
       * @return The punctuationMethod.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod getPunctuationMethod() {
        return instance.getPunctuationMethod();
      }
      /**
       * <code>optional .mozc.config.Config.PunctuationMethod punctuation_method = 45 [default = TOUTEN_KUTEN];</code>
       * @param value The enum numeric value on the wire for punctuationMethod to set.
       * @return This builder for chaining.
       */
      public Builder setPunctuationMethod(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod value) {
        copyOnWrite();
        instance.setPunctuationMethod(value);
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.PunctuationMethod punctuation_method = 45 [default = TOUTEN_KUTEN];</code>
       * @return This builder for chaining.
       */
      public Builder clearPunctuationMethod() {
        copyOnWrite();
        instance.clearPunctuationMethod();
        return this;
      }

      /**
       * <code>optional .mozc.config.Config.SymbolMethod symbol_method = 46 [default = CORNER_BRACKET_MIDDLE_DOT];</code>
       * @return Whether the symbolMethod field is set.
       */
      @java.lang.Override
      public boolean hasSymbolMethod() {
        return instance.hasSymbolMethod();
      }
      /**
       * <code>optional .mozc.config.Config.SymbolMethod symbol_method = 46 [default = CORNER_BRACKET_MIDDLE_DOT];</code>
       * @return The symbolMethod.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod getSymbolMethod() {
        return instance.getSymbolMethod();
      }
      /**
       * <code>optional .mozc.config.Config.SymbolMethod symbol_method = 46 [default = CORNER_BRACKET_MIDDLE_DOT];</code>
       * @param value The enum numeric value on the wire for symbolMethod to set.
       * @return This builder for chaining.
       */
      public Builder setSymbolMethod(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod value) {
        copyOnWrite();
        instance.setSymbolMethod(value);
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.SymbolMethod symbol_method = 46 [default = CORNER_BRACKET_MIDDLE_DOT];</code>
       * @return This builder for chaining.
       */
      public Builder clearSymbolMethod() {
        copyOnWrite();
        instance.clearSymbolMethod();
        return this;
      }

      /**
       * <code>optional .mozc.config.Config.FundamentalCharacterForm space_character_form = 47 [default = FUNDAMENTAL_INPUT_MODE];</code>
       * @return Whether the spaceCharacterForm field is set.
       */
      @java.lang.Override
      public boolean hasSpaceCharacterForm() {
        return instance.hasSpaceCharacterForm();
      }
      /**
       * <code>optional .mozc.config.Config.FundamentalCharacterForm space_character_form = 47 [default = FUNDAMENTAL_INPUT_MODE];</code>
       * @return The spaceCharacterForm.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm getSpaceCharacterForm() {
        return instance.getSpaceCharacterForm();
      }
      /**
       * <code>optional .mozc.config.Config.FundamentalCharacterForm space_character_form = 47 [default = FUNDAMENTAL_INPUT_MODE];</code>
       * @param value The enum numeric value on the wire for spaceCharacterForm to set.
       * @return This builder for chaining.
       */
      public Builder setSpaceCharacterForm(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm value) {
        copyOnWrite();
        instance.setSpaceCharacterForm(value);
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.FundamentalCharacterForm space_character_form = 47 [default = FUNDAMENTAL_INPUT_MODE];</code>
       * @return This builder for chaining.
       */
      public Builder clearSpaceCharacterForm() {
        copyOnWrite();
        instance.clearSpaceCharacterForm();
        return this;
      }

      /**
       * <pre>
       * If this flag is true, Mozc toggles preedit method with some predefined
       * key events when IME is turned on.  Otherwise, Mozc ignores such kind of
       * key events so that their preferred can be preserved even when the toggle
       * key is pressed by accident.
       * As for Mozc, only Windows client supports such kind of toggle so this flag
       * is currently valid only on Windows.
       * Background:
       *   Traditional Japanese IMEs have used "Roma-Ji" key in Japanese 106/109
       *   keyboard to toggle the preedit method between Roman and Kana style and
       *   this behavior was finally adopted into JIS X 4064:2002 as a basic
       *   functionality which is expected to support by a Japanese Input Method.
       *   However, people who are not aware of this functionality have been
       *   puzzled because the default key stroke is likely to be pressed
       *   by accident.
       * </pre>
       *
       * <code>optional bool use_keyboard_to_change_preedit_method = 48 [default = false];</code>
       * @return Whether the useKeyboardToChangePreeditMethod field is set.
       */
      @java.lang.Override
      public boolean hasUseKeyboardToChangePreeditMethod() {
        return instance.hasUseKeyboardToChangePreeditMethod();
      }
      /**
       * <pre>
       * If this flag is true, Mozc toggles preedit method with some predefined
       * key events when IME is turned on.  Otherwise, Mozc ignores such kind of
       * key events so that their preferred can be preserved even when the toggle
       * key is pressed by accident.
       * As for Mozc, only Windows client supports such kind of toggle so this flag
       * is currently valid only on Windows.
       * Background:
       *   Traditional Japanese IMEs have used "Roma-Ji" key in Japanese 106/109
       *   keyboard to toggle the preedit method between Roman and Kana style and
       *   this behavior was finally adopted into JIS X 4064:2002 as a basic
       *   functionality which is expected to support by a Japanese Input Method.
       *   However, people who are not aware of this functionality have been
       *   puzzled because the default key stroke is likely to be pressed
       *   by accident.
       * </pre>
       *
       * <code>optional bool use_keyboard_to_change_preedit_method = 48 [default = false];</code>
       * @return The useKeyboardToChangePreeditMethod.
       */
      @java.lang.Override
      public boolean getUseKeyboardToChangePreeditMethod() {
        return instance.getUseKeyboardToChangePreeditMethod();
      }
      /**
       * <pre>
       * If this flag is true, Mozc toggles preedit method with some predefined
       * key events when IME is turned on.  Otherwise, Mozc ignores such kind of
       * key events so that their preferred can be preserved even when the toggle
       * key is pressed by accident.
       * As for Mozc, only Windows client supports such kind of toggle so this flag
       * is currently valid only on Windows.
       * Background:
       *   Traditional Japanese IMEs have used "Roma-Ji" key in Japanese 106/109
       *   keyboard to toggle the preedit method between Roman and Kana style and
       *   this behavior was finally adopted into JIS X 4064:2002 as a basic
       *   functionality which is expected to support by a Japanese Input Method.
       *   However, people who are not aware of this functionality have been
       *   puzzled because the default key stroke is likely to be pressed
       *   by accident.
       * </pre>
       *
       * <code>optional bool use_keyboard_to_change_preedit_method = 48 [default = false];</code>
       * @param value The useKeyboardToChangePreeditMethod to set.
       * @return This builder for chaining.
       */
      public Builder setUseKeyboardToChangePreeditMethod(boolean value) {
        copyOnWrite();
        instance.setUseKeyboardToChangePreeditMethod(value);
        return this;
      }
      /**
       * <pre>
       * If this flag is true, Mozc toggles preedit method with some predefined
       * key events when IME is turned on.  Otherwise, Mozc ignores such kind of
       * key events so that their preferred can be preserved even when the toggle
       * key is pressed by accident.
       * As for Mozc, only Windows client supports such kind of toggle so this flag
       * is currently valid only on Windows.
       * Background:
       *   Traditional Japanese IMEs have used "Roma-Ji" key in Japanese 106/109
       *   keyboard to toggle the preedit method between Roman and Kana style and
       *   this behavior was finally adopted into JIS X 4064:2002 as a basic
       *   functionality which is expected to support by a Japanese Input Method.
       *   However, people who are not aware of this functionality have been
       *   puzzled because the default key stroke is likely to be pressed
       *   by accident.
       * </pre>
       *
       * <code>optional bool use_keyboard_to_change_preedit_method = 48 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseKeyboardToChangePreeditMethod() {
        copyOnWrite();
        instance.clearUseKeyboardToChangePreeditMethod();
        return this;
      }

      /**
       * <code>optional .mozc.config.Config.HistoryLearningLevel history_learning_level = 50 [default = DEFAULT_HISTORY];</code>
       * @return Whether the historyLearningLevel field is set.
       */
      @java.lang.Override
      public boolean hasHistoryLearningLevel() {
        return instance.hasHistoryLearningLevel();
      }
      /**
       * <code>optional .mozc.config.Config.HistoryLearningLevel history_learning_level = 50 [default = DEFAULT_HISTORY];</code>
       * @return The historyLearningLevel.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel getHistoryLearningLevel() {
        return instance.getHistoryLearningLevel();
      }
      /**
       * <code>optional .mozc.config.Config.HistoryLearningLevel history_learning_level = 50 [default = DEFAULT_HISTORY];</code>
       * @param value The enum numeric value on the wire for historyLearningLevel to set.
       * @return This builder for chaining.
       */
      public Builder setHistoryLearningLevel(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel value) {
        copyOnWrite();
        instance.setHistoryLearningLevel(value);
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.HistoryLearningLevel history_learning_level = 50 [default = DEFAULT_HISTORY];</code>
       * @return This builder for chaining.
       */
      public Builder clearHistoryLearningLevel() {
        copyOnWrite();
        instance.clearHistoryLearningLevel();
        return this;
      }

      /**
       * <code>optional .mozc.config.Config.SelectionShortcut selection_shortcut = 52 [default = SHORTCUT_123456789];</code>
       * @return Whether the selectionShortcut field is set.
       */
      @java.lang.Override
      public boolean hasSelectionShortcut() {
        return instance.hasSelectionShortcut();
      }
      /**
       * <code>optional .mozc.config.Config.SelectionShortcut selection_shortcut = 52 [default = SHORTCUT_123456789];</code>
       * @return The selectionShortcut.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut getSelectionShortcut() {
        return instance.getSelectionShortcut();
      }
      /**
       * <code>optional .mozc.config.Config.SelectionShortcut selection_shortcut = 52 [default = SHORTCUT_123456789];</code>
       * @param value The enum numeric value on the wire for selectionShortcut to set.
       * @return This builder for chaining.
       */
      public Builder setSelectionShortcut(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut value) {
        copyOnWrite();
        instance.setSelectionShortcut(value);
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.SelectionShortcut selection_shortcut = 52 [default = SHORTCUT_123456789];</code>
       * @return This builder for chaining.
       */
      public Builder clearSelectionShortcut() {
        copyOnWrite();
        instance.clearSelectionShortcut();
        return this;
      }

      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      @java.lang.Override
      public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule> getCharacterFormRulesList() {
        return java.util.Collections.unmodifiableList(
            instance.getCharacterFormRulesList());
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      @java.lang.Override
      public int getCharacterFormRulesCount() {
        return instance.getCharacterFormRulesCount();
      }/**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule getCharacterFormRules(int index) {
        return instance.getCharacterFormRules(index);
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public Builder setCharacterFormRules(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule value) {
        copyOnWrite();
        instance.setCharacterFormRules(index, value);
        return this;
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public Builder setCharacterFormRules(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.Builder builderForValue) {
        copyOnWrite();
        instance.setCharacterFormRules(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public Builder addCharacterFormRules(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule value) {
        copyOnWrite();
        instance.addCharacterFormRules(value);
        return this;
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public Builder addCharacterFormRules(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule value) {
        copyOnWrite();
        instance.addCharacterFormRules(index, value);
        return this;
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public Builder addCharacterFormRules(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.Builder builderForValue) {
        copyOnWrite();
        instance.addCharacterFormRules(builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public Builder addCharacterFormRules(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.Builder builderForValue) {
        copyOnWrite();
        instance.addCharacterFormRules(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public Builder addAllCharacterFormRules(
          java.lang.Iterable<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule> values) {
        copyOnWrite();
        instance.addAllCharacterFormRules(values);
        return this;
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public Builder clearCharacterFormRules() {
        copyOnWrite();
        instance.clearCharacterFormRules();
        return this;
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public Builder removeCharacterFormRules(int index) {
        copyOnWrite();
        instance.removeCharacterFormRules(index);
        return this;
      }

      /**
       * <pre>
       * Automatically switch composition mode.
       * </pre>
       *
       * <code>optional bool auto_switch_composition_mode = 56 [default = true];</code>
       * @return Whether the autoSwitchCompositionMode field is set.
       */
      @java.lang.Override
      public boolean hasAutoSwitchCompositionMode() {
        return instance.hasAutoSwitchCompositionMode();
      }
      /**
       * <pre>
       * Automatically switch composition mode.
       * </pre>
       *
       * <code>optional bool auto_switch_composition_mode = 56 [default = true];</code>
       * @return The autoSwitchCompositionMode.
       */
      @java.lang.Override
      public boolean getAutoSwitchCompositionMode() {
        return instance.getAutoSwitchCompositionMode();
      }
      /**
       * <pre>
       * Automatically switch composition mode.
       * </pre>
       *
       * <code>optional bool auto_switch_composition_mode = 56 [default = true];</code>
       * @param value The autoSwitchCompositionMode to set.
       * @return This builder for chaining.
       */
      public Builder setAutoSwitchCompositionMode(boolean value) {
        copyOnWrite();
        instance.setAutoSwitchCompositionMode(value);
        return this;
      }
      /**
       * <pre>
       * Automatically switch composition mode.
       * </pre>
       *
       * <code>optional bool auto_switch_composition_mode = 56 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearAutoSwitchCompositionMode() {
        copyOnWrite();
        instance.clearAutoSwitchCompositionMode();
        return this;
      }

      /**
       * <pre>
       * Toggle to use cascanding window for debugging.
       * </pre>
       *
       * <code>optional bool use_cascading_window = 58 [default = true];</code>
       * @return Whether the useCascadingWindow field is set.
       */
      @java.lang.Override
      public boolean hasUseCascadingWindow() {
        return instance.hasUseCascadingWindow();
      }
      /**
       * <pre>
       * Toggle to use cascanding window for debugging.
       * </pre>
       *
       * <code>optional bool use_cascading_window = 58 [default = true];</code>
       * @return The useCascadingWindow.
       */
      @java.lang.Override
      public boolean getUseCascadingWindow() {
        return instance.getUseCascadingWindow();
      }
      /**
       * <pre>
       * Toggle to use cascanding window for debugging.
       * </pre>
       *
       * <code>optional bool use_cascading_window = 58 [default = true];</code>
       * @param value The useCascadingWindow to set.
       * @return This builder for chaining.
       */
      public Builder setUseCascadingWindow(boolean value) {
        copyOnWrite();
        instance.setUseCascadingWindow(value);
        return this;
      }
      /**
       * <pre>
       * Toggle to use cascanding window for debugging.
       * </pre>
       *
       * <code>optional bool use_cascading_window = 58 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseCascadingWindow() {
        copyOnWrite();
        instance.clearUseCascadingWindow();
        return this;
      }

      /**
       * <code>optional .mozc.config.Config.ShiftKeyModeSwitch shift_key_mode_switch = 59 [default = ASCII_INPUT_MODE];</code>
       * @return Whether the shiftKeyModeSwitch field is set.
       */
      @java.lang.Override
      public boolean hasShiftKeyModeSwitch() {
        return instance.hasShiftKeyModeSwitch();
      }
      /**
       * <code>optional .mozc.config.Config.ShiftKeyModeSwitch shift_key_mode_switch = 59 [default = ASCII_INPUT_MODE];</code>
       * @return The shiftKeyModeSwitch.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch getShiftKeyModeSwitch() {
        return instance.getShiftKeyModeSwitch();
      }
      /**
       * <code>optional .mozc.config.Config.ShiftKeyModeSwitch shift_key_mode_switch = 59 [default = ASCII_INPUT_MODE];</code>
       * @param value The enum numeric value on the wire for shiftKeyModeSwitch to set.
       * @return This builder for chaining.
       */
      public Builder setShiftKeyModeSwitch(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch value) {
        copyOnWrite();
        instance.setShiftKeyModeSwitch(value);
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.ShiftKeyModeSwitch shift_key_mode_switch = 59 [default = ASCII_INPUT_MODE];</code>
       * @return This builder for chaining.
       */
      public Builder clearShiftKeyModeSwitch() {
        copyOnWrite();
        instance.clearShiftKeyModeSwitch();
        return this;
      }

      /**
       * <code>optional .mozc.config.Config.NumpadCharacterForm numpad_character_form = 60 [default = NUMPAD_HALF_WIDTH];</code>
       * @return Whether the numpadCharacterForm field is set.
       */
      @java.lang.Override
      public boolean hasNumpadCharacterForm() {
        return instance.hasNumpadCharacterForm();
      }
      /**
       * <code>optional .mozc.config.Config.NumpadCharacterForm numpad_character_form = 60 [default = NUMPAD_HALF_WIDTH];</code>
       * @return The numpadCharacterForm.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm getNumpadCharacterForm() {
        return instance.getNumpadCharacterForm();
      }
      /**
       * <code>optional .mozc.config.Config.NumpadCharacterForm numpad_character_form = 60 [default = NUMPAD_HALF_WIDTH];</code>
       * @param value The enum numeric value on the wire for numpadCharacterForm to set.
       * @return This builder for chaining.
       */
      public Builder setNumpadCharacterForm(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm value) {
        copyOnWrite();
        instance.setNumpadCharacterForm(value);
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.NumpadCharacterForm numpad_character_form = 60 [default = NUMPAD_HALF_WIDTH];</code>
       * @return This builder for chaining.
       */
      public Builder clearNumpadCharacterForm() {
        copyOnWrite();
        instance.clearNumpadCharacterForm();
        return this;
      }

      /**
       * <code>optional bool use_auto_conversion = 61 [default = false];</code>
       * @return Whether the useAutoConversion field is set.
       */
      @java.lang.Override
      public boolean hasUseAutoConversion() {
        return instance.hasUseAutoConversion();
      }
      /**
       * <code>optional bool use_auto_conversion = 61 [default = false];</code>
       * @return The useAutoConversion.
       */
      @java.lang.Override
      public boolean getUseAutoConversion() {
        return instance.getUseAutoConversion();
      }
      /**
       * <code>optional bool use_auto_conversion = 61 [default = false];</code>
       * @param value The useAutoConversion to set.
       * @return This builder for chaining.
       */
      public Builder setUseAutoConversion(boolean value) {
        copyOnWrite();
        instance.setUseAutoConversion(value);
        return this;
      }
      /**
       * <code>optional bool use_auto_conversion = 61 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseAutoConversion() {
        copyOnWrite();
        instance.clearUseAutoConversion();
        return this;
      }

      /**
       * <pre>
       * can't use AutoConversionKey as a type since
       * undefined enum type is not correctly handled.
       * </pre>
       *
       * <code>optional uint32 auto_conversion_key = 62 [default = 13];</code>
       * @return Whether the autoConversionKey field is set.
       */
      @java.lang.Override
      public boolean hasAutoConversionKey() {
        return instance.hasAutoConversionKey();
      }
      /**
       * <pre>
       * can't use AutoConversionKey as a type since
       * undefined enum type is not correctly handled.
       * </pre>
       *
       * <code>optional uint32 auto_conversion_key = 62 [default = 13];</code>
       * @return The autoConversionKey.
       */
      @java.lang.Override
      public int getAutoConversionKey() {
        return instance.getAutoConversionKey();
      }
      /**
       * <pre>
       * can't use AutoConversionKey as a type since
       * undefined enum type is not correctly handled.
       * </pre>
       *
       * <code>optional uint32 auto_conversion_key = 62 [default = 13];</code>
       * @param value The autoConversionKey to set.
       * @return This builder for chaining.
       */
      public Builder setAutoConversionKey(int value) {
        copyOnWrite();
        instance.setAutoConversionKey(value);
        return this;
      }
      /**
       * <pre>
       * can't use AutoConversionKey as a type since
       * undefined enum type is not correctly handled.
       * </pre>
       *
       * <code>optional uint32 auto_conversion_key = 62 [default = 13];</code>
       * @return This builder for chaining.
       */
      public Builder clearAutoConversionKey() {
        copyOnWrite();
        instance.clearAutoConversionKey();
        return this;
      }

      /**
       * <pre>
       * Mac-original JIS key layout has "yen-sign" key which generates
       * U+00A5 instead of U+005C and sometimes users get troubles with
       * them because they expect backslashes which are rendered as
       * yen-sign.  If this configuration is BACKSLASH, Mozc will
       * interpret U+005C even when the original key event is U+00A5.
       * </pre>
       *
       * <code>optional .mozc.config.Config.YenSignCharacter yen_sign_character = 63 [default = YEN_SIGN];</code>
       * @return Whether the yenSignCharacter field is set.
       */
      @java.lang.Override
      public boolean hasYenSignCharacter() {
        return instance.hasYenSignCharacter();
      }
      /**
       * <pre>
       * Mac-original JIS key layout has "yen-sign" key which generates
       * U+00A5 instead of U+005C and sometimes users get troubles with
       * them because they expect backslashes which are rendered as
       * yen-sign.  If this configuration is BACKSLASH, Mozc will
       * interpret U+005C even when the original key event is U+00A5.
       * </pre>
       *
       * <code>optional .mozc.config.Config.YenSignCharacter yen_sign_character = 63 [default = YEN_SIGN];</code>
       * @return The yenSignCharacter.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter getYenSignCharacter() {
        return instance.getYenSignCharacter();
      }
      /**
       * <pre>
       * Mac-original JIS key layout has "yen-sign" key which generates
       * U+00A5 instead of U+005C and sometimes users get troubles with
       * them because they expect backslashes which are rendered as
       * yen-sign.  If this configuration is BACKSLASH, Mozc will
       * interpret U+005C even when the original key event is U+00A5.
       * </pre>
       *
       * <code>optional .mozc.config.Config.YenSignCharacter yen_sign_character = 63 [default = YEN_SIGN];</code>
       * @param value The enum numeric value on the wire for yenSignCharacter to set.
       * @return This builder for chaining.
       */
      public Builder setYenSignCharacter(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter value) {
        copyOnWrite();
        instance.setYenSignCharacter(value);
        return this;
      }
      /**
       * <pre>
       * Mac-original JIS key layout has "yen-sign" key which generates
       * U+00A5 instead of U+005C and sometimes users get troubles with
       * them because they expect backslashes which are rendered as
       * yen-sign.  If this configuration is BACKSLASH, Mozc will
       * interpret U+005C even when the original key event is U+00A5.
       * </pre>
       *
       * <code>optional .mozc.config.Config.YenSignCharacter yen_sign_character = 63 [default = YEN_SIGN];</code>
       * @return This builder for chaining.
       */
      public Builder clearYenSignCharacter() {
        copyOnWrite();
        instance.clearYenSignCharacter();
        return this;
      }

      /**
       * <pre>
       * Use Japanese keyboard layout even when the user uses other
       * keyboard layouts.  In Mac OSX people can use several keyboard
       * layouts such like French or Spanish but some people want to use
       * Japanese layout for Japanese.  See http://b/2917320
       * </pre>
       *
       * <code>optional bool use_japanese_layout = 64 [default = false];</code>
       * @return Whether the useJapaneseLayout field is set.
       */
      @java.lang.Override
      public boolean hasUseJapaneseLayout() {
        return instance.hasUseJapaneseLayout();
      }
      /**
       * <pre>
       * Use Japanese keyboard layout even when the user uses other
       * keyboard layouts.  In Mac OSX people can use several keyboard
       * layouts such like French or Spanish but some people want to use
       * Japanese layout for Japanese.  See http://b/2917320
       * </pre>
       *
       * <code>optional bool use_japanese_layout = 64 [default = false];</code>
       * @return The useJapaneseLayout.
       */
      @java.lang.Override
      public boolean getUseJapaneseLayout() {
        return instance.getUseJapaneseLayout();
      }
      /**
       * <pre>
       * Use Japanese keyboard layout even when the user uses other
       * keyboard layouts.  In Mac OSX people can use several keyboard
       * layouts such like French or Spanish but some people want to use
       * Japanese layout for Japanese.  See http://b/2917320
       * </pre>
       *
       * <code>optional bool use_japanese_layout = 64 [default = false];</code>
       * @param value The useJapaneseLayout to set.
       * @return This builder for chaining.
       */
      public Builder setUseJapaneseLayout(boolean value) {
        copyOnWrite();
        instance.setUseJapaneseLayout(value);
        return this;
      }
      /**
       * <pre>
       * Use Japanese keyboard layout even when the user uses other
       * keyboard layouts.  In Mac OSX people can use several keyboard
       * layouts such like French or Spanish but some people want to use
       * Japanese layout for Japanese.  See http://b/2917320
       * </pre>
       *
       * <code>optional bool use_japanese_layout = 64 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseJapaneseLayout() {
        copyOnWrite();
        instance.clearUseJapaneseLayout();
        return this;
      }

      /**
       * <pre>
       * Use kana modifier insensitive conversion.
       * e.g.  -&gt; 
       * Note that Request message has the same field.
       * - Request's one is controlled by the client. A user cannot control it.
       *   On the other hand Config's is under a user's control.
       * - Whether the feature is activated or not is decided by logical-AND
       *   of Request's and Config's.
       * </pre>
       *
       * <code>optional bool use_kana_modifier_insensitive_conversion = 65 [default = false];</code>
       * @return Whether the useKanaModifierInsensitiveConversion field is set.
       */
      @java.lang.Override
      public boolean hasUseKanaModifierInsensitiveConversion() {
        return instance.hasUseKanaModifierInsensitiveConversion();
      }
      /**
       * <pre>
       * Use kana modifier insensitive conversion.
       * e.g.  -&gt; 
       * Note that Request message has the same field.
       * - Request's one is controlled by the client. A user cannot control it.
       *   On the other hand Config's is under a user's control.
       * - Whether the feature is activated or not is decided by logical-AND
       *   of Request's and Config's.
       * </pre>
       *
       * <code>optional bool use_kana_modifier_insensitive_conversion = 65 [default = false];</code>
       * @return The useKanaModifierInsensitiveConversion.
       */
      @java.lang.Override
      public boolean getUseKanaModifierInsensitiveConversion() {
        return instance.getUseKanaModifierInsensitiveConversion();
      }
      /**
       * <pre>
       * Use kana modifier insensitive conversion.
       * e.g.  -&gt; 
       * Note that Request message has the same field.
       * - Request's one is controlled by the client. A user cannot control it.
       *   On the other hand Config's is under a user's control.
       * - Whether the feature is activated or not is decided by logical-AND
       *   of Request's and Config's.
       * </pre>
       *
       * <code>optional bool use_kana_modifier_insensitive_conversion = 65 [default = false];</code>
       * @param value The useKanaModifierInsensitiveConversion to set.
       * @return This builder for chaining.
       */
      public Builder setUseKanaModifierInsensitiveConversion(boolean value) {
        copyOnWrite();
        instance.setUseKanaModifierInsensitiveConversion(value);
        return this;
      }
      /**
       * <pre>
       * Use kana modifier insensitive conversion.
       * e.g.  -&gt; 
       * Note that Request message has the same field.
       * - Request's one is controlled by the client. A user cannot control it.
       *   On the other hand Config's is under a user's control.
       * - Whether the feature is activated or not is decided by logical-AND
       *   of Request's and Config's.
       * </pre>
       *
       * <code>optional bool use_kana_modifier_insensitive_conversion = 65 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseKanaModifierInsensitiveConversion() {
        copyOnWrite();
        instance.clearUseKanaModifierInsensitiveConversion();
        return this;
      }

      /**
       * <pre>
       * Use typing correction feature.
       * e.g. sunkai -&gt; 
       * </pre>
       *
       * <code>optional bool use_typing_correction = 66 [default = false];</code>
       * @return Whether the useTypingCorrection field is set.
       */
      @java.lang.Override
      public boolean hasUseTypingCorrection() {
        return instance.hasUseTypingCorrection();
      }
      /**
       * <pre>
       * Use typing correction feature.
       * e.g. sunkai -&gt; 
       * </pre>
       *
       * <code>optional bool use_typing_correction = 66 [default = false];</code>
       * @return The useTypingCorrection.
       */
      @java.lang.Override
      public boolean getUseTypingCorrection() {
        return instance.getUseTypingCorrection();
      }
      /**
       * <pre>
       * Use typing correction feature.
       * e.g. sunkai -&gt; 
       * </pre>
       *
       * <code>optional bool use_typing_correction = 66 [default = false];</code>
       * @param value The useTypingCorrection to set.
       * @return This builder for chaining.
       */
      public Builder setUseTypingCorrection(boolean value) {
        copyOnWrite();
        instance.setUseTypingCorrection(value);
        return this;
      }
      /**
       * <pre>
       * Use typing correction feature.
       * e.g. sunkai -&gt; 
       * </pre>
       *
       * <code>optional bool use_typing_correction = 66 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseTypingCorrection() {
        copyOnWrite();
        instance.clearUseTypingCorrection();
        return this;
      }

      /**
       * <pre>
       * The duration in millisecond to determine the timeout.
       * If the duration between key inputs is more than this value,
       * a SessionCommand::STOP_KEY_TOGGLING is prepended to the next key input.
       * If the value is 0, STOP_KEY_TOGGLING is not sent.
       * </pre>
       *
       * <code>optional int32 composing_timeout_threshold_msec = 67 [default = 0];</code>
       * @return Whether the composingTimeoutThresholdMsec field is set.
       */
      @java.lang.Override
      public boolean hasComposingTimeoutThresholdMsec() {
        return instance.hasComposingTimeoutThresholdMsec();
      }
      /**
       * <pre>
       * The duration in millisecond to determine the timeout.
       * If the duration between key inputs is more than this value,
       * a SessionCommand::STOP_KEY_TOGGLING is prepended to the next key input.
       * If the value is 0, STOP_KEY_TOGGLING is not sent.
       * </pre>
       *
       * <code>optional int32 composing_timeout_threshold_msec = 67 [default = 0];</code>
       * @return The composingTimeoutThresholdMsec.
       */
      @java.lang.Override
      public int getComposingTimeoutThresholdMsec() {
        return instance.getComposingTimeoutThresholdMsec();
      }
      /**
       * <pre>
       * The duration in millisecond to determine the timeout.
       * If the duration between key inputs is more than this value,
       * a SessionCommand::STOP_KEY_TOGGLING is prepended to the next key input.
       * If the value is 0, STOP_KEY_TOGGLING is not sent.
       * </pre>
       *
       * <code>optional int32 composing_timeout_threshold_msec = 67 [default = 0];</code>
       * @param value The composingTimeoutThresholdMsec to set.
       * @return This builder for chaining.
       */
      public Builder setComposingTimeoutThresholdMsec(int value) {
        copyOnWrite();
        instance.setComposingTimeoutThresholdMsec(value);
        return this;
      }
      /**
       * <pre>
       * The duration in millisecond to determine the timeout.
       * If the duration between key inputs is more than this value,
       * a SessionCommand::STOP_KEY_TOGGLING is prepended to the next key input.
       * If the value is 0, STOP_KEY_TOGGLING is not sent.
       * </pre>
       *
       * <code>optional int32 composing_timeout_threshold_msec = 67 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearComposingTimeoutThresholdMsec() {
        copyOnWrite();
        instance.clearComposingTimeoutThresholdMsec();
        return this;
      }

      /**
       * <pre>
       * The keymaps which are loaded on top of `session_keymap`.
       * Overlay keymaps are prioritized over `session_keymap`.
       * They are used to partially modify the session keymap, for example
       * using Henkan key as IME_ON.
       * </pre>
       *
       * <code>repeated .mozc.config.Config.SessionKeymap overlay_keymaps = 68 [packed = true];</code>
       * @return A list containing the overlayKeymaps.
       */
      @java.lang.Override
      public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap> getOverlayKeymapsList() {
        return instance.getOverlayKeymapsList();
      }
      /**
       * <pre>
       * The keymaps which are loaded on top of `session_keymap`.
       * Overlay keymaps are prioritized over `session_keymap`.
       * They are used to partially modify the session keymap, for example
       * using Henkan key as IME_ON.
       * </pre>
       *
       * <code>repeated .mozc.config.Config.SessionKeymap overlay_keymaps = 68 [packed = true];</code>
       * @return The count of overlayKeymaps.
       */
      @java.lang.Override
      public int getOverlayKeymapsCount() {
        return instance.getOverlayKeymapsCount();
      }
      /**
       * <pre>
       * The keymaps which are loaded on top of `session_keymap`.
       * Overlay keymaps are prioritized over `session_keymap`.
       * They are used to partially modify the session keymap, for example
       * using Henkan key as IME_ON.
       * </pre>
       *
       * <code>repeated .mozc.config.Config.SessionKeymap overlay_keymaps = 68 [packed = true];</code>
       * @param index The index of the element to return.
       * @return The overlayKeymaps at the given index.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap getOverlayKeymaps(int index) {
        return instance.getOverlayKeymaps(index);
      }
      /**
       * <pre>
       * The keymaps which are loaded on top of `session_keymap`.
       * Overlay keymaps are prioritized over `session_keymap`.
       * They are used to partially modify the session keymap, for example
       * using Henkan key as IME_ON.
       * </pre>
       *
       * <code>repeated .mozc.config.Config.SessionKeymap overlay_keymaps = 68 [packed = true];</code>
       * @param index The index to set the value at.
       * @param value The overlayKeymaps to set.
       * @return This builder for chaining.
       */
      public Builder setOverlayKeymaps(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap value) {
        copyOnWrite();
        instance.setOverlayKeymaps(index, value);
        return this;
      }
      /**
       * <pre>
       * The keymaps which are loaded on top of `session_keymap`.
       * Overlay keymaps are prioritized over `session_keymap`.
       * They are used to partially modify the session keymap, for example
       * using Henkan key as IME_ON.
       * </pre>
       *
       * <code>repeated .mozc.config.Config.SessionKeymap overlay_keymaps = 68 [packed = true];</code>
       * @param value The overlayKeymaps to add.
       * @return This builder for chaining.
       */
      public Builder addOverlayKeymaps(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap value) {
        copyOnWrite();
        instance.addOverlayKeymaps(value);
        return this;
      }
      /**
       * <pre>
       * The keymaps which are loaded on top of `session_keymap`.
       * Overlay keymaps are prioritized over `session_keymap`.
       * They are used to partially modify the session keymap, for example
       * using Henkan key as IME_ON.
       * </pre>
       *
       * <code>repeated .mozc.config.Config.SessionKeymap overlay_keymaps = 68 [packed = true];</code>
       * @param values The overlayKeymaps to add.
       * @return This builder for chaining.
       */
      public Builder addAllOverlayKeymaps(
          java.lang.Iterable<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap> values) {
        copyOnWrite();
        instance.addAllOverlayKeymaps(values);  return this;
      }
      /**
       * <pre>
       * The keymaps which are loaded on top of `session_keymap`.
       * Overlay keymaps are prioritized over `session_keymap`.
       * They are used to partially modify the session keymap, for example
       * using Henkan key as IME_ON.
       * </pre>
       *
       * <code>repeated .mozc.config.Config.SessionKeymap overlay_keymaps = 68 [packed = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearOverlayKeymaps() {
        copyOnWrite();
        instance.clearOverlayKeymaps();
        return this;
      }

      /**
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       * Dictionary (80-99)
       * </pre>
       *
       * <code>optional bool use_date_conversion = 80 [default = true];</code>
       * @return Whether the useDateConversion field is set.
       */
      @java.lang.Override
      public boolean hasUseDateConversion() {
        return instance.hasUseDateConversion();
      }
      /**
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       * Dictionary (80-99)
       * </pre>
       *
       * <code>optional bool use_date_conversion = 80 [default = true];</code>
       * @return The useDateConversion.
       */
      @java.lang.Override
      public boolean getUseDateConversion() {
        return instance.getUseDateConversion();
      }
      /**
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       * Dictionary (80-99)
       * </pre>
       *
       * <code>optional bool use_date_conversion = 80 [default = true];</code>
       * @param value The useDateConversion to set.
       * @return This builder for chaining.
       */
      public Builder setUseDateConversion(boolean value) {
        copyOnWrite();
        instance.setUseDateConversion(value);
        return this;
      }
      /**
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       * Dictionary (80-99)
       * </pre>
       *
       * <code>optional bool use_date_conversion = 80 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseDateConversion() {
        copyOnWrite();
        instance.clearUseDateConversion();
        return this;
      }

      /**
       * <code>optional bool use_single_kanji_conversion = 81 [default = true];</code>
       * @return Whether the useSingleKanjiConversion field is set.
       */
      @java.lang.Override
      public boolean hasUseSingleKanjiConversion() {
        return instance.hasUseSingleKanjiConversion();
      }
      /**
       * <code>optional bool use_single_kanji_conversion = 81 [default = true];</code>
       * @return The useSingleKanjiConversion.
       */
      @java.lang.Override
      public boolean getUseSingleKanjiConversion() {
        return instance.getUseSingleKanjiConversion();
      }
      /**
       * <code>optional bool use_single_kanji_conversion = 81 [default = true];</code>
       * @param value The useSingleKanjiConversion to set.
       * @return This builder for chaining.
       */
      public Builder setUseSingleKanjiConversion(boolean value) {
        copyOnWrite();
        instance.setUseSingleKanjiConversion(value);
        return this;
      }
      /**
       * <code>optional bool use_single_kanji_conversion = 81 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseSingleKanjiConversion() {
        copyOnWrite();
        instance.clearUseSingleKanjiConversion();
        return this;
      }

      /**
       * <code>optional bool use_symbol_conversion = 82 [default = true];</code>
       * @return Whether the useSymbolConversion field is set.
       */
      @java.lang.Override
      public boolean hasUseSymbolConversion() {
        return instance.hasUseSymbolConversion();
      }
      /**
       * <code>optional bool use_symbol_conversion = 82 [default = true];</code>
       * @return The useSymbolConversion.
       */
      @java.lang.Override
      public boolean getUseSymbolConversion() {
        return instance.getUseSymbolConversion();
      }
      /**
       * <code>optional bool use_symbol_conversion = 82 [default = true];</code>
       * @param value The useSymbolConversion to set.
       * @return This builder for chaining.
       */
      public Builder setUseSymbolConversion(boolean value) {
        copyOnWrite();
        instance.setUseSymbolConversion(value);
        return this;
      }
      /**
       * <code>optional bool use_symbol_conversion = 82 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseSymbolConversion() {
        copyOnWrite();
        instance.clearUseSymbolConversion();
        return this;
      }

      /**
       * <code>optional bool use_number_conversion = 83 [default = true];</code>
       * @return Whether the useNumberConversion field is set.
       */
      @java.lang.Override
      public boolean hasUseNumberConversion() {
        return instance.hasUseNumberConversion();
      }
      /**
       * <code>optional bool use_number_conversion = 83 [default = true];</code>
       * @return The useNumberConversion.
       */
      @java.lang.Override
      public boolean getUseNumberConversion() {
        return instance.getUseNumberConversion();
      }
      /**
       * <code>optional bool use_number_conversion = 83 [default = true];</code>
       * @param value The useNumberConversion to set.
       * @return This builder for chaining.
       */
      public Builder setUseNumberConversion(boolean value) {
        copyOnWrite();
        instance.setUseNumberConversion(value);
        return this;
      }
      /**
       * <code>optional bool use_number_conversion = 83 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseNumberConversion() {
        copyOnWrite();
        instance.clearUseNumberConversion();
        return this;
      }

      /**
       * <code>optional bool use_emoticon_conversion = 84 [default = true];</code>
       * @return Whether the useEmoticonConversion field is set.
       */
      @java.lang.Override
      public boolean hasUseEmoticonConversion() {
        return instance.hasUseEmoticonConversion();
      }
      /**
       * <code>optional bool use_emoticon_conversion = 84 [default = true];</code>
       * @return The useEmoticonConversion.
       */
      @java.lang.Override
      public boolean getUseEmoticonConversion() {
        return instance.getUseEmoticonConversion();
      }
      /**
       * <code>optional bool use_emoticon_conversion = 84 [default = true];</code>
       * @param value The useEmoticonConversion to set.
       * @return This builder for chaining.
       */
      public Builder setUseEmoticonConversion(boolean value) {
        copyOnWrite();
        instance.setUseEmoticonConversion(value);
        return this;
      }
      /**
       * <code>optional bool use_emoticon_conversion = 84 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseEmoticonConversion() {
        copyOnWrite();
        instance.clearUseEmoticonConversion();
        return this;
      }

      /**
       * <code>optional bool use_calculator = 85 [default = true];</code>
       * @return Whether the useCalculator field is set.
       */
      @java.lang.Override
      public boolean hasUseCalculator() {
        return instance.hasUseCalculator();
      }
      /**
       * <code>optional bool use_calculator = 85 [default = true];</code>
       * @return The useCalculator.
       */
      @java.lang.Override
      public boolean getUseCalculator() {
        return instance.getUseCalculator();
      }
      /**
       * <code>optional bool use_calculator = 85 [default = true];</code>
       * @param value The useCalculator to set.
       * @return This builder for chaining.
       */
      public Builder setUseCalculator(boolean value) {
        copyOnWrite();
        instance.setUseCalculator(value);
        return this;
      }
      /**
       * <code>optional bool use_calculator = 85 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseCalculator() {
        copyOnWrite();
        instance.clearUseCalculator();
        return this;
      }

      /**
       * <code>optional bool use_t13n_conversion = 86 [default = true];</code>
       * @return Whether the useT13nConversion field is set.
       */
      @java.lang.Override
      public boolean hasUseT13NConversion() {
        return instance.hasUseT13NConversion();
      }
      /**
       * <code>optional bool use_t13n_conversion = 86 [default = true];</code>
       * @return The useT13nConversion.
       */
      @java.lang.Override
      public boolean getUseT13NConversion() {
        return instance.getUseT13NConversion();
      }
      /**
       * <code>optional bool use_t13n_conversion = 86 [default = true];</code>
       * @param value The useT13nConversion to set.
       * @return This builder for chaining.
       */
      public Builder setUseT13NConversion(boolean value) {
        copyOnWrite();
        instance.setUseT13NConversion(value);
        return this;
      }
      /**
       * <code>optional bool use_t13n_conversion = 86 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseT13NConversion() {
        copyOnWrite();
        instance.clearUseT13NConversion();
        return this;
      }

      /**
       * <code>optional bool use_zip_code_conversion = 87 [default = true];</code>
       * @return Whether the useZipCodeConversion field is set.
       */
      @java.lang.Override
      public boolean hasUseZipCodeConversion() {
        return instance.hasUseZipCodeConversion();
      }
      /**
       * <code>optional bool use_zip_code_conversion = 87 [default = true];</code>
       * @return The useZipCodeConversion.
       */
      @java.lang.Override
      public boolean getUseZipCodeConversion() {
        return instance.getUseZipCodeConversion();
      }
      /**
       * <code>optional bool use_zip_code_conversion = 87 [default = true];</code>
       * @param value The useZipCodeConversion to set.
       * @return This builder for chaining.
       */
      public Builder setUseZipCodeConversion(boolean value) {
        copyOnWrite();
        instance.setUseZipCodeConversion(value);
        return this;
      }
      /**
       * <code>optional bool use_zip_code_conversion = 87 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseZipCodeConversion() {
        copyOnWrite();
        instance.clearUseZipCodeConversion();
        return this;
      }

      /**
       * <code>optional bool use_spelling_correction = 88 [default = true];</code>
       * @return Whether the useSpellingCorrection field is set.
       */
      @java.lang.Override
      public boolean hasUseSpellingCorrection() {
        return instance.hasUseSpellingCorrection();
      }
      /**
       * <code>optional bool use_spelling_correction = 88 [default = true];</code>
       * @return The useSpellingCorrection.
       */
      @java.lang.Override
      public boolean getUseSpellingCorrection() {
        return instance.getUseSpellingCorrection();
      }
      /**
       * <code>optional bool use_spelling_correction = 88 [default = true];</code>
       * @param value The useSpellingCorrection to set.
       * @return This builder for chaining.
       */
      public Builder setUseSpellingCorrection(boolean value) {
        copyOnWrite();
        instance.setUseSpellingCorrection(value);
        return this;
      }
      /**
       * <code>optional bool use_spelling_correction = 88 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseSpellingCorrection() {
        copyOnWrite();
        instance.clearUseSpellingCorrection();
        return this;
      }

      /**
       * <pre>
       * If use_emoji_conversion is true, the user can input emoji characters
       * by converting from a query string (e.g. "  " [U+1F436]).
       * Even if it is false, users might be able to input emoji characters
       * with other ways.
       * Note: Some characters can be either of text and emoji.  It would be ideal
       * to use the variation sequence to specify emoji presentation [U+FE0E],
       * although it is not implemented yet.
       * See: http://unicode.org/reports/tr51/#Presentation_Style
       * </pre>
       *
       * <code>optional bool use_emoji_conversion = 89 [default = false];</code>
       * @return Whether the useEmojiConversion field is set.
       */
      @java.lang.Override
      public boolean hasUseEmojiConversion() {
        return instance.hasUseEmojiConversion();
      }
      /**
       * <pre>
       * If use_emoji_conversion is true, the user can input emoji characters
       * by converting from a query string (e.g. "  " [U+1F436]).
       * Even if it is false, users might be able to input emoji characters
       * with other ways.
       * Note: Some characters can be either of text and emoji.  It would be ideal
       * to use the variation sequence to specify emoji presentation [U+FE0E],
       * although it is not implemented yet.
       * See: http://unicode.org/reports/tr51/#Presentation_Style
       * </pre>
       *
       * <code>optional bool use_emoji_conversion = 89 [default = false];</code>
       * @return The useEmojiConversion.
       */
      @java.lang.Override
      public boolean getUseEmojiConversion() {
        return instance.getUseEmojiConversion();
      }
      /**
       * <pre>
       * If use_emoji_conversion is true, the user can input emoji characters
       * by converting from a query string (e.g. "  " [U+1F436]).
       * Even if it is false, users might be able to input emoji characters
       * with other ways.
       * Note: Some characters can be either of text and emoji.  It would be ideal
       * to use the variation sequence to specify emoji presentation [U+FE0E],
       * although it is not implemented yet.
       * See: http://unicode.org/reports/tr51/#Presentation_Style
       * </pre>
       *
       * <code>optional bool use_emoji_conversion = 89 [default = false];</code>
       * @param value The useEmojiConversion to set.
       * @return This builder for chaining.
       */
      public Builder setUseEmojiConversion(boolean value) {
        copyOnWrite();
        instance.setUseEmojiConversion(value);
        return this;
      }
      /**
       * <pre>
       * If use_emoji_conversion is true, the user can input emoji characters
       * by converting from a query string (e.g. "  " [U+1F436]).
       * Even if it is false, users might be able to input emoji characters
       * with other ways.
       * Note: Some characters can be either of text and emoji.  It would be ideal
       * to use the variation sequence to specify emoji presentation [U+FE0E],
       * although it is not implemented yet.
       * See: http://unicode.org/reports/tr51/#Presentation_Style
       * </pre>
       *
       * <code>optional bool use_emoji_conversion = 89 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseEmojiConversion() {
        copyOnWrite();
        instance.clearUseEmojiConversion();
        return this;
      }

      /**
       * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
       */
      @java.lang.Override
      public boolean hasInformationListConfig() {
        return instance.hasInformationListConfig();
      }
      /**
       * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig getInformationListConfig() {
        return instance.getInformationListConfig();
      }
      /**
       * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
       */
      public Builder setInformationListConfig(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig value) {
        copyOnWrite();
        instance.setInformationListConfig(value);
        return this;
        }
      /**
       * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
       */
      public Builder setInformationListConfig(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.Builder builderForValue) {
        copyOnWrite();
        instance.setInformationListConfig(builderForValue.build());
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
       */
      public Builder mergeInformationListConfig(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig value) {
        copyOnWrite();
        instance.mergeInformationListConfig(value);
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
       */
      public Builder clearInformationListConfig() {  copyOnWrite();
        instance.clearInformationListConfig();
        return this;
      }

      /**
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       * Suggest (100-119)
       * Suggest is a feature of word suggestion with prefix search.
       * When you type "", you may get "", "" (), "" ()
       * as suggested words.
       * Use history-based suggest feature.
       * If this is true, your previously typed words are prioritized.
       * </pre>
       *
       * <code>optional bool use_history_suggest = 100 [default = true];</code>
       * @return Whether the useHistorySuggest field is set.
       */
      @java.lang.Override
      public boolean hasUseHistorySuggest() {
        return instance.hasUseHistorySuggest();
      }
      /**
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       * Suggest (100-119)
       * Suggest is a feature of word suggestion with prefix search.
       * When you type "", you may get "", "" (), "" ()
       * as suggested words.
       * Use history-based suggest feature.
       * If this is true, your previously typed words are prioritized.
       * </pre>
       *
       * <code>optional bool use_history_suggest = 100 [default = true];</code>
       * @return The useHistorySuggest.
       */
      @java.lang.Override
      public boolean getUseHistorySuggest() {
        return instance.getUseHistorySuggest();
      }
      /**
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       * Suggest (100-119)
       * Suggest is a feature of word suggestion with prefix search.
       * When you type "", you may get "", "" (), "" ()
       * as suggested words.
       * Use history-based suggest feature.
       * If this is true, your previously typed words are prioritized.
       * </pre>
       *
       * <code>optional bool use_history_suggest = 100 [default = true];</code>
       * @param value The useHistorySuggest to set.
       * @return This builder for chaining.
       */
      public Builder setUseHistorySuggest(boolean value) {
        copyOnWrite();
        instance.setUseHistorySuggest(value);
        return this;
      }
      /**
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       * Suggest (100-119)
       * Suggest is a feature of word suggestion with prefix search.
       * When you type "", you may get "", "" (), "" ()
       * as suggested words.
       * Use history-based suggest feature.
       * If this is true, your previously typed words are prioritized.
       * </pre>
       *
       * <code>optional bool use_history_suggest = 100 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseHistorySuggest() {
        copyOnWrite();
        instance.clearUseHistorySuggest();
        return this;
      }

      /**
       * <pre>
       * Use dictionary-based suggest feature.
       * If this is true, words in the word dictionary are suggested even if
       * you haven't typed before.
       * </pre>
       *
       * <code>optional bool use_dictionary_suggest = 101 [default = true];</code>
       * @return Whether the useDictionarySuggest field is set.
       */
      @java.lang.Override
      public boolean hasUseDictionarySuggest() {
        return instance.hasUseDictionarySuggest();
      }
      /**
       * <pre>
       * Use dictionary-based suggest feature.
       * If this is true, words in the word dictionary are suggested even if
       * you haven't typed before.
       * </pre>
       *
       * <code>optional bool use_dictionary_suggest = 101 [default = true];</code>
       * @return The useDictionarySuggest.
       */
      @java.lang.Override
      public boolean getUseDictionarySuggest() {
        return instance.getUseDictionarySuggest();
      }
      /**
       * <pre>
       * Use dictionary-based suggest feature.
       * If this is true, words in the word dictionary are suggested even if
       * you haven't typed before.
       * </pre>
       *
       * <code>optional bool use_dictionary_suggest = 101 [default = true];</code>
       * @param value The useDictionarySuggest to set.
       * @return This builder for chaining.
       */
      public Builder setUseDictionarySuggest(boolean value) {
        copyOnWrite();
        instance.setUseDictionarySuggest(value);
        return this;
      }
      /**
       * <pre>
       * Use dictionary-based suggest feature.
       * If this is true, words in the word dictionary are suggested even if
       * you haven't typed before.
       * </pre>
       *
       * <code>optional bool use_dictionary_suggest = 101 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseDictionarySuggest() {
        copyOnWrite();
        instance.clearUseDictionarySuggest();
        return this;
      }

      /**
       * <pre>
       * Use realtime conversion feature.
       * </pre>
       *
       * <code>optional bool use_realtime_conversion = 102 [default = true];</code>
       * @return Whether the useRealtimeConversion field is set.
       */
      @java.lang.Override
      public boolean hasUseRealtimeConversion() {
        return instance.hasUseRealtimeConversion();
      }
      /**
       * <pre>
       * Use realtime conversion feature.
       * </pre>
       *
       * <code>optional bool use_realtime_conversion = 102 [default = true];</code>
       * @return The useRealtimeConversion.
       */
      @java.lang.Override
      public boolean getUseRealtimeConversion() {
        return instance.getUseRealtimeConversion();
      }
      /**
       * <pre>
       * Use realtime conversion feature.
       * </pre>
       *
       * <code>optional bool use_realtime_conversion = 102 [default = true];</code>
       * @param value The useRealtimeConversion to set.
       * @return This builder for chaining.
       */
      public Builder setUseRealtimeConversion(boolean value) {
        copyOnWrite();
        instance.setUseRealtimeConversion(value);
        return this;
      }
      /**
       * <pre>
       * Use realtime conversion feature.
       * </pre>
       *
       * <code>optional bool use_realtime_conversion = 102 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseRealtimeConversion() {
        copyOnWrite();
        instance.clearUseRealtimeConversion();
        return this;
      }

      /**
       * <pre>
       * Size of suggestions.
       * </pre>
       *
       * <code>optional uint32 suggestions_size = 110 [default = 3];</code>
       * @return Whether the suggestionsSize field is set.
       */
      @java.lang.Override
      public boolean hasSuggestionsSize() {
        return instance.hasSuggestionsSize();
      }
      /**
       * <pre>
       * Size of suggestions.
       * </pre>
       *
       * <code>optional uint32 suggestions_size = 110 [default = 3];</code>
       * @return The suggestionsSize.
       */
      @java.lang.Override
      public int getSuggestionsSize() {
        return instance.getSuggestionsSize();
      }
      /**
       * <pre>
       * Size of suggestions.
       * </pre>
       *
       * <code>optional uint32 suggestions_size = 110 [default = 3];</code>
       * @param value The suggestionsSize to set.
       * @return This builder for chaining.
       */
      public Builder setSuggestionsSize(int value) {
        copyOnWrite();
        instance.setSuggestionsSize(value);
        return this;
      }
      /**
       * <pre>
       * Size of suggestions.
       * </pre>
       *
       * <code>optional uint32 suggestions_size = 110 [default = 3];</code>
       * @return This builder for chaining.
       */
      public Builder clearSuggestionsSize() {
        copyOnWrite();
        instance.clearSuggestionsSize();
        return this;
      }

      /**
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       * Renderer (120-139)
       * Use mode indicator feature.
       * </pre>
       *
       * <code>optional bool use_mode_indicator = 120 [default = true];</code>
       * @return Whether the useModeIndicator field is set.
       */
      @java.lang.Override
      public boolean hasUseModeIndicator() {
        return instance.hasUseModeIndicator();
      }
      /**
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       * Renderer (120-139)
       * Use mode indicator feature.
       * </pre>
       *
       * <code>optional bool use_mode_indicator = 120 [default = true];</code>
       * @return The useModeIndicator.
       */
      @java.lang.Override
      public boolean getUseModeIndicator() {
        return instance.getUseModeIndicator();
      }
      /**
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       * Renderer (120-139)
       * Use mode indicator feature.
       * </pre>
       *
       * <code>optional bool use_mode_indicator = 120 [default = true];</code>
       * @param value The useModeIndicator to set.
       * @return This builder for chaining.
       */
      public Builder setUseModeIndicator(boolean value) {
        copyOnWrite();
        instance.setUseModeIndicator(value);
        return this;
      }
      /**
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       * Renderer (120-139)
       * Use mode indicator feature.
       * </pre>
       *
       * <code>optional bool use_mode_indicator = 120 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseModeIndicator() {
        copyOnWrite();
        instance.clearUseModeIndicator();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:mozc.config.Config)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "bitField1_",
              "generalConfig_",
              "verboseLevel_",
              "incognitoMode_",
              "checkDefault_",
              "presentationMode_",
              "preeditMethod_",
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod.internalGetVerifier(),
              "sessionKeymap_",
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap.internalGetVerifier(),
              "customKeymapTable_",
              "customRomanTable_",
              "punctuationMethod_",
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod.internalGetVerifier(),
              "symbolMethod_",
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod.internalGetVerifier(),
              "spaceCharacterForm_",
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm.internalGetVerifier(),
              "useKeyboardToChangePreeditMethod_",
              "historyLearningLevel_",
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel.internalGetVerifier(),
              "selectionShortcut_",
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut.internalGetVerifier(),
              "characterFormRules_",
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.class,
              "autoSwitchCompositionMode_",
              "useCascadingWindow_",
              "shiftKeyModeSwitch_",
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch.internalGetVerifier(),
              "numpadCharacterForm_",
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm.internalGetVerifier(),
              "useAutoConversion_",
              "autoConversionKey_",
              "yenSignCharacter_",
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter.internalGetVerifier(),
              "useJapaneseLayout_",
              "useKanaModifierInsensitiveConversion_",
              "useTypingCorrection_",
              "composingTimeoutThresholdMsec_",
              "overlayKeymaps_",
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap.internalGetVerifier(),
              "useDateConversion_",
              "useSingleKanjiConversion_",
              "useSymbolConversion_",
              "useNumberConversion_",
              "useEmoticonConversion_",
              "useCalculator_",
              "useT13NConversion_",
              "useZipCodeConversion_",
              "useSpellingCorrection_",
              "useEmojiConversion_",
              "informationListConfig_",
              "useHistorySuggest_",
              "useDictionarySuggest_",
              "useRealtimeConversion_",
              "suggestionsSize_",
              "useModeIndicator_",
            };
            java.lang.String info =
                "\u0001,\u0000\u0002\u0001x,\u0000\u0002\u0000\u0001\u1009\u0000\n\u1004\u0001\u0014" +
                "\u1007\u0002\u0016\u1007\u0003\u0017\u1007\u0004(\u100c\u0005)\u100c\u0006*\u100a" +
                "\u0007+\u100a\b-\u100c\t.\u100c\n/\u100c\u000b0\u1007\f2\u100c\r4\u100c\u000e6\u001b" +
                "8\u1007\u000f:\u1007\u0010;\u100c\u0011<\u100c\u0012=\u1007\u0013>\u100b\u0014?\u100c" +
                "\u0015@\u1007\u0016A\u1007\u0017B\u1007\u0018C\u1004\u0019D,P\u1007\u001aQ\u1007" +
                "\u001bR\u1007\u001cS\u1007\u001dT\u1007\u001eU\u1007\u001fV\u1007 W\u1007!X\u1007" +
                "\"Y\u1007#Z\u1009$d\u1007%e\u1007&f\u1007\'n\u100b(x\u1007)";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config> parser = PARSER;
          if (parser == null) {
            synchronized (org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:mozc.config.Config)
    private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config DEFAULT_INSTANCE;
    static {
      Config defaultInstance = new Config();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Config.class, defaultInstance);
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Config> PARSER;

    public static com.google.protobuf.Parser<Config> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }


  static {
  }

  // @@protoc_insertion_point(outer_class_scope)
}
